/// Generated by the Protocol Buffers 3.3.2 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "IM.Buddy.proto"
/// Syntax "Proto2"

import Foundation

public extension Im {
    public struct Buddy {}
}

public extension Im.Buddy {
    public struct ImbuddyRoot {
        public static let `default` = ImbuddyRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Im.BaseDefine.ImbaseDefineRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class ImrecentContactSessionReq : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImrecentContactSessionReq.Builder

        public static func == (lhs: Im.Buddy.ImrecentContactSessionReq, rhs: Im.Buddy.ImrecentContactSessionReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasLatestUpdateTime == rhs.hasLatestUpdateTime) && (!lhs.hasLatestUpdateTime || lhs.latestUpdateTime == rhs.latestUpdateTime)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0201
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var latestUpdateTime:UInt32! = nil
        public fileprivate(set) var hasLatestUpdateTime:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasLatestUpdateTime {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasLatestUpdateTime {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:latestUpdateTime)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasLatestUpdateTime {
                serialize_size += latestUpdateTime.computeUInt32Size(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImrecentContactSessionReq.Builder {
            return Im.Buddy.ImrecentContactSessionReq.classBuilder() as! Im.Buddy.ImrecentContactSessionReq.Builder
        }
        public func getBuilder() -> Im.Buddy.ImrecentContactSessionReq.Builder {
            return classBuilder() as! Im.Buddy.ImrecentContactSessionReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImrecentContactSessionReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImrecentContactSessionReq.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImrecentContactSessionReq.Builder {
            return try Im.Buddy.ImrecentContactSessionReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImrecentContactSessionReq) throws -> Im.Buddy.ImrecentContactSessionReq.Builder {
            return try Im.Buddy.ImrecentContactSessionReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasLatestUpdateTime {
                jsonMap["latestUpdateTime"] = UInt(latestUpdateTime)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImrecentContactSessionReq {
            return try Im.Buddy.ImrecentContactSessionReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImrecentContactSessionReq {
            return try Im.Buddy.ImrecentContactSessionReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasLatestUpdateTime {
                output += "\(indent) latestUpdateTime: \(latestUpdateTime) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasLatestUpdateTime {
                    hashCode = (hashCode &* 31) &+ latestUpdateTime.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImrecentContactSessionReq"
        }
        override public func className() -> String {
            return "Im.Buddy.ImrecentContactSessionReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImrecentContactSessionReq = Im.Buddy.ImrecentContactSessionReq()
            public func getMessage() -> Im.Buddy.ImrecentContactSessionReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0201
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImrecentContactSessionReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImrecentContactSessionReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var latestUpdateTime:UInt32 {
                get {
                    return builderResult.latestUpdateTime
                }
                set (value) {
                    builderResult.hasLatestUpdateTime = true
                    builderResult.latestUpdateTime = value
                }
            }
            public var hasLatestUpdateTime:Bool {
                get {
                    return builderResult.hasLatestUpdateTime
                }
            }
            @discardableResult
            public func setLatestUpdateTime(_ value:UInt32) -> Im.Buddy.ImrecentContactSessionReq.Builder {
                self.latestUpdateTime = value
                return self
            }
            @discardableResult
            public func clearLatestUpdateTime() -> Im.Buddy.ImrecentContactSessionReq.Builder{
                builderResult.hasLatestUpdateTime = false
                builderResult.latestUpdateTime = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImrecentContactSessionReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImrecentContactSessionReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImrecentContactSessionReq.Builder {
                builderResult = Im.Buddy.ImrecentContactSessionReq()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImrecentContactSessionReq.Builder {
                return try Im.Buddy.ImrecentContactSessionReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImrecentContactSessionReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImrecentContactSessionReq {
                let returnMe:Im.Buddy.ImrecentContactSessionReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImrecentContactSessionReq) throws -> Im.Buddy.ImrecentContactSessionReq.Builder {
                if other == Im.Buddy.ImrecentContactSessionReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasLatestUpdateTime {
                    latestUpdateTime = other.latestUpdateTime
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImrecentContactSessionReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImrecentContactSessionReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        latestUpdateTime = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImrecentContactSessionReq.Builder {
                let resultDecodedBuilder = Im.Buddy.ImrecentContactSessionReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? UInt {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)
                } else if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? String {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImrecentContactSessionReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImrecentContactSessionReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImrecentContactSessionRsp : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImrecentContactSessionRsp.Builder

        public static func == (lhs: Im.Buddy.ImrecentContactSessionRsp, rhs: Im.Buddy.ImrecentContactSessionRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.contactSessionList == rhs.contactSessionList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0202
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var contactSessionList:Array<Im.BaseDefine.ContactSessionInfo>  = Array<Im.BaseDefine.ContactSessionInfo>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            var isInitContactSessionList:Bool = true
            for oneElementContactSessionList in contactSessionList {
                if !oneElementContactSessionList.isInitialized() {
                    isInitContactSessionList = false
                    break 
                }
            }
            if !isInitContactSessionList {
                return isInitContactSessionList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            for oneElementContactSessionList in contactSessionList {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementContactSessionList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            for oneElementContactSessionList in contactSessionList {
                serialize_size += oneElementContactSessionList.computeMessageSize(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImrecentContactSessionRsp.Builder {
            return Im.Buddy.ImrecentContactSessionRsp.classBuilder() as! Im.Buddy.ImrecentContactSessionRsp.Builder
        }
        public func getBuilder() -> Im.Buddy.ImrecentContactSessionRsp.Builder {
            return classBuilder() as! Im.Buddy.ImrecentContactSessionRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImrecentContactSessionRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImrecentContactSessionRsp.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImrecentContactSessionRsp.Builder {
            return try Im.Buddy.ImrecentContactSessionRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImrecentContactSessionRsp) throws -> Im.Buddy.ImrecentContactSessionRsp.Builder {
            return try Im.Buddy.ImrecentContactSessionRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if !contactSessionList.isEmpty {
                var jsonArrayContactSessionList:Array<Dictionary<String,Any>> = []
                for oneValueContactSessionList in contactSessionList {
                    let ecodedMessageContactSessionList = try oneValueContactSessionList.encode()
                    jsonArrayContactSessionList.append(ecodedMessageContactSessionList)
                }
                jsonMap["contactSessionList"] = jsonArrayContactSessionList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImrecentContactSessionRsp {
            return try Im.Buddy.ImrecentContactSessionRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImrecentContactSessionRsp {
            return try Im.Buddy.ImrecentContactSessionRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            var contactSessionListElementIndex:Int = 0
            for oneElementContactSessionList in contactSessionList {
                output += "\(indent) contactSessionList[\(contactSessionListElementIndex)] {\n"
                output += try oneElementContactSessionList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                contactSessionListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                for oneElementContactSessionList in contactSessionList {
                    hashCode = (hashCode &* 31) &+ oneElementContactSessionList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImrecentContactSessionRsp"
        }
        override public func className() -> String {
            return "Im.Buddy.ImrecentContactSessionRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImrecentContactSessionRsp = Im.Buddy.ImrecentContactSessionRsp()
            public func getMessage() -> Im.Buddy.ImrecentContactSessionRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0202
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImrecentContactSessionRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImrecentContactSessionRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var contactSessionList:Array<Im.BaseDefine.ContactSessionInfo> {
                get {
                    return builderResult.contactSessionList
                }
                set (value) {
                    builderResult.contactSessionList = value
                }
            }
            @discardableResult
            public func setContactSessionList(_ value:Array<Im.BaseDefine.ContactSessionInfo>) -> Im.Buddy.ImrecentContactSessionRsp.Builder {
                self.contactSessionList = value
                return self
            }
            @discardableResult
            public func clearContactSessionList() -> Im.Buddy.ImrecentContactSessionRsp.Builder {
                builderResult.contactSessionList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImrecentContactSessionRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImrecentContactSessionRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImrecentContactSessionRsp.Builder {
                builderResult = Im.Buddy.ImrecentContactSessionRsp()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImrecentContactSessionRsp.Builder {
                return try Im.Buddy.ImrecentContactSessionRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImrecentContactSessionRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImrecentContactSessionRsp {
                let returnMe:Im.Buddy.ImrecentContactSessionRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImrecentContactSessionRsp) throws -> Im.Buddy.ImrecentContactSessionRsp.Builder {
                if other == Im.Buddy.ImrecentContactSessionRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if !other.contactSessionList.isEmpty  {
                     builderResult.contactSessionList += other.contactSessionList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImrecentContactSessionRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImrecentContactSessionRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 18:
                        let subBuilder = Im.BaseDefine.ContactSessionInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        contactSessionList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImrecentContactSessionRsp.Builder {
                let resultDecodedBuilder = Im.Buddy.ImrecentContactSessionRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueContactSessionList = jsonMap["contactSessionList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayContactSessionList:Array<Im.BaseDefine.ContactSessionInfo> = []
                    for oneValueContactSessionList in jsonValueContactSessionList {
                        let messageFromStringContactSessionList = try Im.BaseDefine.ContactSessionInfo.Builder.decodeToBuilder(jsonMap:oneValueContactSessionList).build()

                        jsonArrayContactSessionList.append(messageFromStringContactSessionList)
                    }
                    resultDecodedBuilder.contactSessionList = jsonArrayContactSessionList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImrecentContactSessionRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImrecentContactSessionRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImuserStatNotify : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImuserStatNotify.Builder

        public static func == (lhs: Im.Buddy.ImuserStatNotify, rhs: Im.Buddy.ImuserStatNotify) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserStat == rhs.hasUserStat) && (!lhs.hasUserStat || lhs.userStat == rhs.userStat)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userStat:Im.BaseDefine.UserStat!
        public fileprivate(set) var hasUserStat:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserStat {
                return false
            }
            if !userStat.isInitialized() {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserStat {
                try codedOutputStream.writeMessage(fieldNumber: 1, value:userStat)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserStat {
                if let varSizeuserStat = userStat?.computeMessageSize(fieldNumber: 1) {
                    serialize_size += varSizeuserStat
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImuserStatNotify.Builder {
            return Im.Buddy.ImuserStatNotify.classBuilder() as! Im.Buddy.ImuserStatNotify.Builder
        }
        public func getBuilder() -> Im.Buddy.ImuserStatNotify.Builder {
            return classBuilder() as! Im.Buddy.ImuserStatNotify.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImuserStatNotify.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImuserStatNotify.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImuserStatNotify.Builder {
            return try Im.Buddy.ImuserStatNotify.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImuserStatNotify) throws -> Im.Buddy.ImuserStatNotify.Builder {
            return try Im.Buddy.ImuserStatNotify.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserStat {
                jsonMap["userStat"] = try userStat.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImuserStatNotify {
            return try Im.Buddy.ImuserStatNotify.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImuserStatNotify {
            return try Im.Buddy.ImuserStatNotify.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserStat {
                output += "\(indent) userStat {\n"
                if let outDescUserStat = userStat {
                    output += try outDescUserStat.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserStat {
                    if let hashValueuserStat = userStat?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuserStat
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImuserStatNotify"
        }
        override public func className() -> String {
            return "Im.Buddy.ImuserStatNotify"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImuserStatNotify = Im.Buddy.ImuserStatNotify()
            public func getMessage() -> Im.Buddy.ImuserStatNotify {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0203
            public var userStat:Im.BaseDefine.UserStat! {
                get {
                    if userStatBuilder_ != nil {
                        builderResult.userStat = userStatBuilder_.getMessage()
                    }
                    return builderResult.userStat
                }
                set (value) {
                    builderResult.hasUserStat = true
                    builderResult.userStat = value
                }
            }
            public var hasUserStat:Bool {
                get {
                    return builderResult.hasUserStat
                }
            }
            fileprivate var userStatBuilder_:Im.BaseDefine.UserStat.Builder! {
                didSet {
                    builderResult.hasUserStat = true
                }
            }
            public func getUserStatBuilder() -> Im.BaseDefine.UserStat.Builder {
                if userStatBuilder_ == nil {
                    userStatBuilder_ = Im.BaseDefine.UserStat.Builder()
                    builderResult.userStat = userStatBuilder_.getMessage()
                    if userStat != nil {
                        try! userStatBuilder_.mergeFrom(other: userStat)
                    }
                }
                return userStatBuilder_
            }
            @discardableResult
            public func setUserStat(_ value:Im.BaseDefine.UserStat!) -> Im.Buddy.ImuserStatNotify.Builder {
                self.userStat = value
                return self
            }
            @discardableResult
            public func mergeUserStat(value:Im.BaseDefine.UserStat) throws -> Im.Buddy.ImuserStatNotify.Builder {
                if builderResult.hasUserStat {
                    builderResult.userStat = try Im.BaseDefine.UserStat.builderWithPrototype(prototype:builderResult.userStat).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.userStat = value
                }
                builderResult.hasUserStat = true
                return self
            }
            @discardableResult
            public func clearUserStat() -> Im.Buddy.ImuserStatNotify.Builder {
                userStatBuilder_ = nil
                builderResult.hasUserStat = false
                builderResult.userStat = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImuserStatNotify.Builder {
                builderResult = Im.Buddy.ImuserStatNotify()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImuserStatNotify.Builder {
                return try Im.Buddy.ImuserStatNotify.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImuserStatNotify {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImuserStatNotify {
                let returnMe:Im.Buddy.ImuserStatNotify = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImuserStatNotify) throws -> Im.Buddy.ImuserStatNotify.Builder {
                if other == Im.Buddy.ImuserStatNotify() {
                    return self
                }
                if (other.hasUserStat) {
                    try mergeUserStat(value: other.userStat)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImuserStatNotify.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImuserStatNotify.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder:Im.BaseDefine.UserStat.Builder = Im.BaseDefine.UserStat.Builder()
                        if hasUserStat {
                            try subBuilder.mergeFrom(other: userStat)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        userStat = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImuserStatNotify.Builder {
                let resultDecodedBuilder = Im.Buddy.ImuserStatNotify.Builder()
                if let jsonValueUserStat = jsonMap["userStat"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.userStat = try Im.BaseDefine.UserStat.Builder.decodeToBuilder(jsonMap:jsonValueUserStat).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImuserStatNotify.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImuserStatNotify.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImusersInfoReq : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImusersInfoReq.Builder

        public static func == (lhs: Im.Buddy.ImusersInfoReq, rhs: Im.Buddy.ImusersInfoReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.userIdList == rhs.userIdList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0204
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var userIdList:Array<UInt32> = Array<UInt32>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if !userIdList.isEmpty {
                for oneValueuserIdList in userIdList {
                    try codedOutputStream.writeUInt32(fieldNumber: 2, value:oneValueuserIdList)
                }
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            var dataSizeUserIdList:Int32 = 0
            for oneValueuserIdList in userIdList {
                dataSizeUserIdList += oneValueuserIdList.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeUserIdList
            serialize_size += 1 * Int32(userIdList.count)
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImusersInfoReq.Builder {
            return Im.Buddy.ImusersInfoReq.classBuilder() as! Im.Buddy.ImusersInfoReq.Builder
        }
        public func getBuilder() -> Im.Buddy.ImusersInfoReq.Builder {
            return classBuilder() as! Im.Buddy.ImusersInfoReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImusersInfoReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImusersInfoReq.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImusersInfoReq.Builder {
            return try Im.Buddy.ImusersInfoReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImusersInfoReq) throws -> Im.Buddy.ImusersInfoReq.Builder {
            return try Im.Buddy.ImusersInfoReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if !userIdList.isEmpty {
                var jsonArrayUserIdList:Array<UInt> = []
                for oneValueUserIdList in userIdList {
                    jsonArrayUserIdList.append(UInt(oneValueUserIdList))
                }
                jsonMap["userIdList"] = jsonArrayUserIdList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImusersInfoReq {
            return try Im.Buddy.ImusersInfoReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImusersInfoReq {
            return try Im.Buddy.ImusersInfoReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            var userIdListElementIndex:Int = 0
            for oneValueUserIdList in userIdList  {
                output += "\(indent) userIdList[\(userIdListElementIndex)]: \(oneValueUserIdList)\n"
                userIdListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                for oneValueUserIdList in userIdList {
                    hashCode = (hashCode &* 31) &+ oneValueUserIdList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImusersInfoReq"
        }
        override public func className() -> String {
            return "Im.Buddy.ImusersInfoReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImusersInfoReq = Im.Buddy.ImusersInfoReq()
            public func getMessage() -> Im.Buddy.ImusersInfoReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0204
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImusersInfoReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImusersInfoReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var userIdList:Array<UInt32> {
                get {
                    return builderResult.userIdList
                }
                set (array) {
                    builderResult.userIdList = array
                }
            }
            @discardableResult
            public func setUserIdList(_ value:Array<UInt32>) -> Im.Buddy.ImusersInfoReq.Builder {
                self.userIdList = value
                return self
            }
            @discardableResult
            public func clearUserIdList() -> Im.Buddy.ImusersInfoReq.Builder {
                builderResult.userIdList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImusersInfoReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImusersInfoReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImusersInfoReq.Builder {
                builderResult = Im.Buddy.ImusersInfoReq()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImusersInfoReq.Builder {
                return try Im.Buddy.ImusersInfoReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImusersInfoReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImusersInfoReq {
                let returnMe:Im.Buddy.ImusersInfoReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImusersInfoReq) throws -> Im.Buddy.ImusersInfoReq.Builder {
                if other == Im.Buddy.ImusersInfoReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if !other.userIdList.isEmpty {
                    builderResult.userIdList += other.userIdList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImusersInfoReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersInfoReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        userIdList += [try codedInputStream.readUInt32()]

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImusersInfoReq.Builder {
                let resultDecodedBuilder = Im.Buddy.ImusersInfoReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueUserIdList = jsonMap["userIdList"] as? Array<UInt> {
                    var jsonArrayUserIdList:Array<UInt32> = []
                    for oneValueUserIdList in jsonValueUserIdList {
                        jsonArrayUserIdList.append(UInt32(oneValueUserIdList))
                    }
                    resultDecodedBuilder.userIdList = jsonArrayUserIdList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImusersInfoReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImusersInfoReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImusersInfoRsp : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImusersInfoRsp.Builder

        public static func == (lhs: Im.Buddy.ImusersInfoRsp, rhs: Im.Buddy.ImusersInfoRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.userInfoList == rhs.userInfoList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0205
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var userInfoList:Array<Im.BaseDefine.UserInfo>  = Array<Im.BaseDefine.UserInfo>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            var isInitUserInfoList:Bool = true
            for oneElementUserInfoList in userInfoList {
                if !oneElementUserInfoList.isInitialized() {
                    isInitUserInfoList = false
                    break 
                }
            }
            if !isInitUserInfoList {
                return isInitUserInfoList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            for oneElementUserInfoList in userInfoList {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementUserInfoList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            for oneElementUserInfoList in userInfoList {
                serialize_size += oneElementUserInfoList.computeMessageSize(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImusersInfoRsp.Builder {
            return Im.Buddy.ImusersInfoRsp.classBuilder() as! Im.Buddy.ImusersInfoRsp.Builder
        }
        public func getBuilder() -> Im.Buddy.ImusersInfoRsp.Builder {
            return classBuilder() as! Im.Buddy.ImusersInfoRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImusersInfoRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImusersInfoRsp.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImusersInfoRsp.Builder {
            return try Im.Buddy.ImusersInfoRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImusersInfoRsp) throws -> Im.Buddy.ImusersInfoRsp.Builder {
            return try Im.Buddy.ImusersInfoRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if !userInfoList.isEmpty {
                var jsonArrayUserInfoList:Array<Dictionary<String,Any>> = []
                for oneValueUserInfoList in userInfoList {
                    let ecodedMessageUserInfoList = try oneValueUserInfoList.encode()
                    jsonArrayUserInfoList.append(ecodedMessageUserInfoList)
                }
                jsonMap["userInfoList"] = jsonArrayUserInfoList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImusersInfoRsp {
            return try Im.Buddy.ImusersInfoRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImusersInfoRsp {
            return try Im.Buddy.ImusersInfoRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            var userInfoListElementIndex:Int = 0
            for oneElementUserInfoList in userInfoList {
                output += "\(indent) userInfoList[\(userInfoListElementIndex)] {\n"
                output += try oneElementUserInfoList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                userInfoListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                for oneElementUserInfoList in userInfoList {
                    hashCode = (hashCode &* 31) &+ oneElementUserInfoList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImusersInfoRsp"
        }
        override public func className() -> String {
            return "Im.Buddy.ImusersInfoRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImusersInfoRsp = Im.Buddy.ImusersInfoRsp()
            public func getMessage() -> Im.Buddy.ImusersInfoRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0205
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImusersInfoRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImusersInfoRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var userInfoList:Array<Im.BaseDefine.UserInfo> {
                get {
                    return builderResult.userInfoList
                }
                set (value) {
                    builderResult.userInfoList = value
                }
            }
            @discardableResult
            public func setUserInfoList(_ value:Array<Im.BaseDefine.UserInfo>) -> Im.Buddy.ImusersInfoRsp.Builder {
                self.userInfoList = value
                return self
            }
            @discardableResult
            public func clearUserInfoList() -> Im.Buddy.ImusersInfoRsp.Builder {
                builderResult.userInfoList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImusersInfoRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImusersInfoRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImusersInfoRsp.Builder {
                builderResult = Im.Buddy.ImusersInfoRsp()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImusersInfoRsp.Builder {
                return try Im.Buddy.ImusersInfoRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImusersInfoRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImusersInfoRsp {
                let returnMe:Im.Buddy.ImusersInfoRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImusersInfoRsp) throws -> Im.Buddy.ImusersInfoRsp.Builder {
                if other == Im.Buddy.ImusersInfoRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if !other.userInfoList.isEmpty  {
                     builderResult.userInfoList += other.userInfoList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImusersInfoRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersInfoRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 18:
                        let subBuilder = Im.BaseDefine.UserInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        userInfoList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImusersInfoRsp.Builder {
                let resultDecodedBuilder = Im.Buddy.ImusersInfoRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueUserInfoList = jsonMap["userInfoList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayUserInfoList:Array<Im.BaseDefine.UserInfo> = []
                    for oneValueUserInfoList in jsonValueUserInfoList {
                        let messageFromStringUserInfoList = try Im.BaseDefine.UserInfo.Builder.decodeToBuilder(jsonMap:oneValueUserInfoList).build()

                        jsonArrayUserInfoList.append(messageFromStringUserInfoList)
                    }
                    resultDecodedBuilder.userInfoList = jsonArrayUserInfoList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImusersInfoRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImusersInfoRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImremoveSessionReq : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImremoveSessionReq.Builder

        public static func == (lhs: Im.Buddy.ImremoveSessionReq, rhs: Im.Buddy.ImremoveSessionReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0206
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasSessionType {
                return false
            }
            if !hasSessionId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:sessionType.rawValue)
            }
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:sessionId)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 3)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImremoveSessionReq.Builder {
            return Im.Buddy.ImremoveSessionReq.classBuilder() as! Im.Buddy.ImremoveSessionReq.Builder
        }
        public func getBuilder() -> Im.Buddy.ImremoveSessionReq.Builder {
            return classBuilder() as! Im.Buddy.ImremoveSessionReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImremoveSessionReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImremoveSessionReq.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImremoveSessionReq.Builder {
            return try Im.Buddy.ImremoveSessionReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImremoveSessionReq) throws -> Im.Buddy.ImremoveSessionReq.Builder {
            return try Im.Buddy.ImremoveSessionReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImremoveSessionReq {
            return try Im.Buddy.ImremoveSessionReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImremoveSessionReq {
            return try Im.Buddy.ImremoveSessionReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImremoveSessionReq"
        }
        override public func className() -> String {
            return "Im.Buddy.ImremoveSessionReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImremoveSessionReq = Im.Buddy.ImremoveSessionReq()
            public func getMessage() -> Im.Buddy.ImremoveSessionReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0206
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImremoveSessionReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImremoveSessionReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.Buddy.ImremoveSessionReq.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.Buddy.ImremoveSessionReq.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.Buddy.ImremoveSessionReq.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.Buddy.ImremoveSessionReq.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImremoveSessionReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImremoveSessionReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImremoveSessionReq.Builder {
                builderResult = Im.Buddy.ImremoveSessionReq()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImremoveSessionReq.Builder {
                return try Im.Buddy.ImremoveSessionReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImremoveSessionReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImremoveSessionReq {
                let returnMe:Im.Buddy.ImremoveSessionReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImremoveSessionReq) throws -> Im.Buddy.ImremoveSessionReq.Builder {
                if other == Im.Buddy.ImremoveSessionReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImremoveSessionReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImremoveSessionReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntsessionType))
                        }

                    case 24:
                        sessionId = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImremoveSessionReq.Builder {
                let resultDecodedBuilder = Im.Buddy.ImremoveSessionReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImremoveSessionReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImremoveSessionReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImremoveSessionRsp : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImremoveSessionRsp.Builder

        public static func == (lhs: Im.Buddy.ImremoveSessionRsp, rhs: Im.Buddy.ImremoveSessionRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0207
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasResultCode {
                return false
            }
            if !hasSessionType {
                return false
            }
            if !hasSessionId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:resultCode)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 3, value:sessionType.rawValue)
            }
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:sessionId)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 2)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 3)
            }
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 4)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImremoveSessionRsp.Builder {
            return Im.Buddy.ImremoveSessionRsp.classBuilder() as! Im.Buddy.ImremoveSessionRsp.Builder
        }
        public func getBuilder() -> Im.Buddy.ImremoveSessionRsp.Builder {
            return classBuilder() as! Im.Buddy.ImremoveSessionRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImremoveSessionRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImremoveSessionRsp.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImremoveSessionRsp.Builder {
            return try Im.Buddy.ImremoveSessionRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImremoveSessionRsp) throws -> Im.Buddy.ImremoveSessionRsp.Builder {
            return try Im.Buddy.ImremoveSessionRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImremoveSessionRsp {
            return try Im.Buddy.ImremoveSessionRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImremoveSessionRsp {
            return try Im.Buddy.ImremoveSessionRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImremoveSessionRsp"
        }
        override public func className() -> String {
            return "Im.Buddy.ImremoveSessionRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImremoveSessionRsp = Im.Buddy.ImremoveSessionRsp()
            public func getMessage() -> Im.Buddy.ImremoveSessionRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0207
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImremoveSessionRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImremoveSessionRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.Buddy.ImremoveSessionRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.Buddy.ImremoveSessionRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.Buddy.ImremoveSessionRsp.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.Buddy.ImremoveSessionRsp.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.Buddy.ImremoveSessionRsp.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.Buddy.ImremoveSessionRsp.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImremoveSessionRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImremoveSessionRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImremoveSessionRsp.Builder {
                builderResult = Im.Buddy.ImremoveSessionRsp()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImremoveSessionRsp.Builder {
                return try Im.Buddy.ImremoveSessionRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImremoveSessionRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImremoveSessionRsp {
                let returnMe:Im.Buddy.ImremoveSessionRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImremoveSessionRsp) throws -> Im.Buddy.ImremoveSessionRsp.Builder {
                if other == Im.Buddy.ImremoveSessionRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImremoveSessionRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImremoveSessionRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        resultCode = try codedInputStream.readUInt32()

                    case 24:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntsessionType))
                        }

                    case 32:
                        sessionId = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImremoveSessionRsp.Builder {
                let resultDecodedBuilder = Im.Buddy.ImremoveSessionRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImremoveSessionRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImremoveSessionRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImallUserReq : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImallUserReq.Builder

        public static func == (lhs: Im.Buddy.ImallUserReq, rhs: Im.Buddy.ImallUserReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasLatestUpdateTime == rhs.hasLatestUpdateTime) && (!lhs.hasLatestUpdateTime || lhs.latestUpdateTime == rhs.latestUpdateTime)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0208
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var latestUpdateTime:UInt32! = nil
        public fileprivate(set) var hasLatestUpdateTime:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasLatestUpdateTime {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasLatestUpdateTime {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:latestUpdateTime)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasLatestUpdateTime {
                serialize_size += latestUpdateTime.computeUInt32Size(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImallUserReq.Builder {
            return Im.Buddy.ImallUserReq.classBuilder() as! Im.Buddy.ImallUserReq.Builder
        }
        public func getBuilder() -> Im.Buddy.ImallUserReq.Builder {
            return classBuilder() as! Im.Buddy.ImallUserReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImallUserReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImallUserReq.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImallUserReq.Builder {
            return try Im.Buddy.ImallUserReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImallUserReq) throws -> Im.Buddy.ImallUserReq.Builder {
            return try Im.Buddy.ImallUserReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasLatestUpdateTime {
                jsonMap["latestUpdateTime"] = UInt(latestUpdateTime)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImallUserReq {
            return try Im.Buddy.ImallUserReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImallUserReq {
            return try Im.Buddy.ImallUserReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasLatestUpdateTime {
                output += "\(indent) latestUpdateTime: \(latestUpdateTime) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasLatestUpdateTime {
                    hashCode = (hashCode &* 31) &+ latestUpdateTime.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImallUserReq"
        }
        override public func className() -> String {
            return "Im.Buddy.ImallUserReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImallUserReq = Im.Buddy.ImallUserReq()
            public func getMessage() -> Im.Buddy.ImallUserReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0208
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImallUserReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImallUserReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var latestUpdateTime:UInt32 {
                get {
                    return builderResult.latestUpdateTime
                }
                set (value) {
                    builderResult.hasLatestUpdateTime = true
                    builderResult.latestUpdateTime = value
                }
            }
            public var hasLatestUpdateTime:Bool {
                get {
                    return builderResult.hasLatestUpdateTime
                }
            }
            @discardableResult
            public func setLatestUpdateTime(_ value:UInt32) -> Im.Buddy.ImallUserReq.Builder {
                self.latestUpdateTime = value
                return self
            }
            @discardableResult
            public func clearLatestUpdateTime() -> Im.Buddy.ImallUserReq.Builder{
                builderResult.hasLatestUpdateTime = false
                builderResult.latestUpdateTime = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImallUserReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImallUserReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImallUserReq.Builder {
                builderResult = Im.Buddy.ImallUserReq()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImallUserReq.Builder {
                return try Im.Buddy.ImallUserReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImallUserReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImallUserReq {
                let returnMe:Im.Buddy.ImallUserReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImallUserReq) throws -> Im.Buddy.ImallUserReq.Builder {
                if other == Im.Buddy.ImallUserReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasLatestUpdateTime {
                    latestUpdateTime = other.latestUpdateTime
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImallUserReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImallUserReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        latestUpdateTime = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImallUserReq.Builder {
                let resultDecodedBuilder = Im.Buddy.ImallUserReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? UInt {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)
                } else if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? String {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImallUserReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImallUserReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImallUserRsp : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImallUserRsp.Builder

        public static func == (lhs: Im.Buddy.ImallUserRsp, rhs: Im.Buddy.ImallUserRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasLatestUpdateTime == rhs.hasLatestUpdateTime) && (!lhs.hasLatestUpdateTime || lhs.latestUpdateTime == rhs.latestUpdateTime)
            fieldCheck = fieldCheck && (lhs.userList == rhs.userList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0209
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var latestUpdateTime:UInt32! = nil
        public fileprivate(set) var hasLatestUpdateTime:Bool = false

        public fileprivate(set) var userList:Array<Im.BaseDefine.UserInfo>  = Array<Im.BaseDefine.UserInfo>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasLatestUpdateTime {
                return false
            }
            var isInitUserList:Bool = true
            for oneElementUserList in userList {
                if !oneElementUserList.isInitialized() {
                    isInitUserList = false
                    break 
                }
            }
            if !isInitUserList {
                return isInitUserList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasLatestUpdateTime {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:latestUpdateTime)
            }
            for oneElementUserList in userList {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementUserList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasLatestUpdateTime {
                serialize_size += latestUpdateTime.computeUInt32Size(fieldNumber: 2)
            }
            for oneElementUserList in userList {
                serialize_size += oneElementUserList.computeMessageSize(fieldNumber: 3)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImallUserRsp.Builder {
            return Im.Buddy.ImallUserRsp.classBuilder() as! Im.Buddy.ImallUserRsp.Builder
        }
        public func getBuilder() -> Im.Buddy.ImallUserRsp.Builder {
            return classBuilder() as! Im.Buddy.ImallUserRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImallUserRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImallUserRsp.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImallUserRsp.Builder {
            return try Im.Buddy.ImallUserRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImallUserRsp) throws -> Im.Buddy.ImallUserRsp.Builder {
            return try Im.Buddy.ImallUserRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasLatestUpdateTime {
                jsonMap["latestUpdateTime"] = UInt(latestUpdateTime)
            }
            if !userList.isEmpty {
                var jsonArrayUserList:Array<Dictionary<String,Any>> = []
                for oneValueUserList in userList {
                    let ecodedMessageUserList = try oneValueUserList.encode()
                    jsonArrayUserList.append(ecodedMessageUserList)
                }
                jsonMap["userList"] = jsonArrayUserList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImallUserRsp {
            return try Im.Buddy.ImallUserRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImallUserRsp {
            return try Im.Buddy.ImallUserRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasLatestUpdateTime {
                output += "\(indent) latestUpdateTime: \(latestUpdateTime) \n"
            }
            var userListElementIndex:Int = 0
            for oneElementUserList in userList {
                output += "\(indent) userList[\(userListElementIndex)] {\n"
                output += try oneElementUserList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                userListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasLatestUpdateTime {
                    hashCode = (hashCode &* 31) &+ latestUpdateTime.hashValue
                }
                for oneElementUserList in userList {
                    hashCode = (hashCode &* 31) &+ oneElementUserList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImallUserRsp"
        }
        override public func className() -> String {
            return "Im.Buddy.ImallUserRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImallUserRsp = Im.Buddy.ImallUserRsp()
            public func getMessage() -> Im.Buddy.ImallUserRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0209
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImallUserRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImallUserRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var latestUpdateTime:UInt32 {
                get {
                    return builderResult.latestUpdateTime
                }
                set (value) {
                    builderResult.hasLatestUpdateTime = true
                    builderResult.latestUpdateTime = value
                }
            }
            public var hasLatestUpdateTime:Bool {
                get {
                    return builderResult.hasLatestUpdateTime
                }
            }
            @discardableResult
            public func setLatestUpdateTime(_ value:UInt32) -> Im.Buddy.ImallUserRsp.Builder {
                self.latestUpdateTime = value
                return self
            }
            @discardableResult
            public func clearLatestUpdateTime() -> Im.Buddy.ImallUserRsp.Builder{
                builderResult.hasLatestUpdateTime = false
                builderResult.latestUpdateTime = nil
                return self
            }
            public var userList:Array<Im.BaseDefine.UserInfo> {
                get {
                    return builderResult.userList
                }
                set (value) {
                    builderResult.userList = value
                }
            }
            @discardableResult
            public func setUserList(_ value:Array<Im.BaseDefine.UserInfo>) -> Im.Buddy.ImallUserRsp.Builder {
                self.userList = value
                return self
            }
            @discardableResult
            public func clearUserList() -> Im.Buddy.ImallUserRsp.Builder {
                builderResult.userList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImallUserRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImallUserRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImallUserRsp.Builder {
                builderResult = Im.Buddy.ImallUserRsp()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImallUserRsp.Builder {
                return try Im.Buddy.ImallUserRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImallUserRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImallUserRsp {
                let returnMe:Im.Buddy.ImallUserRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImallUserRsp) throws -> Im.Buddy.ImallUserRsp.Builder {
                if other == Im.Buddy.ImallUserRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasLatestUpdateTime {
                    latestUpdateTime = other.latestUpdateTime
                }
                if !other.userList.isEmpty  {
                     builderResult.userList += other.userList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImallUserRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImallUserRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        latestUpdateTime = try codedInputStream.readUInt32()

                    case 26:
                        let subBuilder = Im.BaseDefine.UserInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        userList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImallUserRsp.Builder {
                let resultDecodedBuilder = Im.Buddy.ImallUserRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? UInt {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)
                } else if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? String {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)!
                }
                if let jsonValueUserList = jsonMap["userList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayUserList:Array<Im.BaseDefine.UserInfo> = []
                    for oneValueUserList in jsonValueUserList {
                        let messageFromStringUserList = try Im.BaseDefine.UserInfo.Builder.decodeToBuilder(jsonMap:oneValueUserList).build()

                        jsonArrayUserList.append(messageFromStringUserList)
                    }
                    resultDecodedBuilder.userList = jsonArrayUserList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImallUserRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImallUserRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImusersStatReq : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImusersStatReq.Builder

        public static func == (lhs: Im.Buddy.ImusersStatReq, rhs: Im.Buddy.ImusersStatReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.userIdList == rhs.userIdList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x020a
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var userIdList:Array<UInt32> = Array<UInt32>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if !userIdList.isEmpty {
                for oneValueuserIdList in userIdList {
                    try codedOutputStream.writeUInt32(fieldNumber: 2, value:oneValueuserIdList)
                }
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            var dataSizeUserIdList:Int32 = 0
            for oneValueuserIdList in userIdList {
                dataSizeUserIdList += oneValueuserIdList.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeUserIdList
            serialize_size += 1 * Int32(userIdList.count)
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImusersStatReq.Builder {
            return Im.Buddy.ImusersStatReq.classBuilder() as! Im.Buddy.ImusersStatReq.Builder
        }
        public func getBuilder() -> Im.Buddy.ImusersStatReq.Builder {
            return classBuilder() as! Im.Buddy.ImusersStatReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImusersStatReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImusersStatReq.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImusersStatReq.Builder {
            return try Im.Buddy.ImusersStatReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImusersStatReq) throws -> Im.Buddy.ImusersStatReq.Builder {
            return try Im.Buddy.ImusersStatReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if !userIdList.isEmpty {
                var jsonArrayUserIdList:Array<UInt> = []
                for oneValueUserIdList in userIdList {
                    jsonArrayUserIdList.append(UInt(oneValueUserIdList))
                }
                jsonMap["userIdList"] = jsonArrayUserIdList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImusersStatReq {
            return try Im.Buddy.ImusersStatReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImusersStatReq {
            return try Im.Buddy.ImusersStatReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            var userIdListElementIndex:Int = 0
            for oneValueUserIdList in userIdList  {
                output += "\(indent) userIdList[\(userIdListElementIndex)]: \(oneValueUserIdList)\n"
                userIdListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                for oneValueUserIdList in userIdList {
                    hashCode = (hashCode &* 31) &+ oneValueUserIdList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImusersStatReq"
        }
        override public func className() -> String {
            return "Im.Buddy.ImusersStatReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImusersStatReq = Im.Buddy.ImusersStatReq()
            public func getMessage() -> Im.Buddy.ImusersStatReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x020a
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImusersStatReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImusersStatReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var userIdList:Array<UInt32> {
                get {
                    return builderResult.userIdList
                }
                set (array) {
                    builderResult.userIdList = array
                }
            }
            @discardableResult
            public func setUserIdList(_ value:Array<UInt32>) -> Im.Buddy.ImusersStatReq.Builder {
                self.userIdList = value
                return self
            }
            @discardableResult
            public func clearUserIdList() -> Im.Buddy.ImusersStatReq.Builder {
                builderResult.userIdList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImusersStatReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImusersStatReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImusersStatReq.Builder {
                builderResult = Im.Buddy.ImusersStatReq()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImusersStatReq.Builder {
                return try Im.Buddy.ImusersStatReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImusersStatReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImusersStatReq {
                let returnMe:Im.Buddy.ImusersStatReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImusersStatReq) throws -> Im.Buddy.ImusersStatReq.Builder {
                if other == Im.Buddy.ImusersStatReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if !other.userIdList.isEmpty {
                    builderResult.userIdList += other.userIdList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImusersStatReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersStatReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        userIdList += [try codedInputStream.readUInt32()]

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImusersStatReq.Builder {
                let resultDecodedBuilder = Im.Buddy.ImusersStatReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueUserIdList = jsonMap["userIdList"] as? Array<UInt> {
                    var jsonArrayUserIdList:Array<UInt32> = []
                    for oneValueUserIdList in jsonValueUserIdList {
                        jsonArrayUserIdList.append(UInt32(oneValueUserIdList))
                    }
                    resultDecodedBuilder.userIdList = jsonArrayUserIdList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImusersStatReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImusersStatReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImusersStatRsp : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImusersStatRsp.Builder

        public static func == (lhs: Im.Buddy.ImusersStatRsp, rhs: Im.Buddy.ImusersStatRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.userStatList == rhs.userStatList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x020b
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var userStatList:Array<Im.BaseDefine.UserStat>  = Array<Im.BaseDefine.UserStat>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            var isInitUserStatList:Bool = true
            for oneElementUserStatList in userStatList {
                if !oneElementUserStatList.isInitialized() {
                    isInitUserStatList = false
                    break 
                }
            }
            if !isInitUserStatList {
                return isInitUserStatList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            for oneElementUserStatList in userStatList {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementUserStatList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            for oneElementUserStatList in userStatList {
                serialize_size += oneElementUserStatList.computeMessageSize(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImusersStatRsp.Builder {
            return Im.Buddy.ImusersStatRsp.classBuilder() as! Im.Buddy.ImusersStatRsp.Builder
        }
        public func getBuilder() -> Im.Buddy.ImusersStatRsp.Builder {
            return classBuilder() as! Im.Buddy.ImusersStatRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImusersStatRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImusersStatRsp.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImusersStatRsp.Builder {
            return try Im.Buddy.ImusersStatRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImusersStatRsp) throws -> Im.Buddy.ImusersStatRsp.Builder {
            return try Im.Buddy.ImusersStatRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if !userStatList.isEmpty {
                var jsonArrayUserStatList:Array<Dictionary<String,Any>> = []
                for oneValueUserStatList in userStatList {
                    let ecodedMessageUserStatList = try oneValueUserStatList.encode()
                    jsonArrayUserStatList.append(ecodedMessageUserStatList)
                }
                jsonMap["userStatList"] = jsonArrayUserStatList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImusersStatRsp {
            return try Im.Buddy.ImusersStatRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImusersStatRsp {
            return try Im.Buddy.ImusersStatRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            var userStatListElementIndex:Int = 0
            for oneElementUserStatList in userStatList {
                output += "\(indent) userStatList[\(userStatListElementIndex)] {\n"
                output += try oneElementUserStatList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                userStatListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                for oneElementUserStatList in userStatList {
                    hashCode = (hashCode &* 31) &+ oneElementUserStatList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImusersStatRsp"
        }
        override public func className() -> String {
            return "Im.Buddy.ImusersStatRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImusersStatRsp = Im.Buddy.ImusersStatRsp()
            public func getMessage() -> Im.Buddy.ImusersStatRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x020b
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImusersStatRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImusersStatRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var userStatList:Array<Im.BaseDefine.UserStat> {
                get {
                    return builderResult.userStatList
                }
                set (value) {
                    builderResult.userStatList = value
                }
            }
            @discardableResult
            public func setUserStatList(_ value:Array<Im.BaseDefine.UserStat>) -> Im.Buddy.ImusersStatRsp.Builder {
                self.userStatList = value
                return self
            }
            @discardableResult
            public func clearUserStatList() -> Im.Buddy.ImusersStatRsp.Builder {
                builderResult.userStatList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImusersStatRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImusersStatRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImusersStatRsp.Builder {
                builderResult = Im.Buddy.ImusersStatRsp()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImusersStatRsp.Builder {
                return try Im.Buddy.ImusersStatRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImusersStatRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImusersStatRsp {
                let returnMe:Im.Buddy.ImusersStatRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImusersStatRsp) throws -> Im.Buddy.ImusersStatRsp.Builder {
                if other == Im.Buddy.ImusersStatRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if !other.userStatList.isEmpty  {
                     builderResult.userStatList += other.userStatList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImusersStatRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersStatRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 18:
                        let subBuilder = Im.BaseDefine.UserStat.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        userStatList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImusersStatRsp.Builder {
                let resultDecodedBuilder = Im.Buddy.ImusersStatRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueUserStatList = jsonMap["userStatList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayUserStatList:Array<Im.BaseDefine.UserStat> = []
                    for oneValueUserStatList in jsonValueUserStatList {
                        let messageFromStringUserStatList = try Im.BaseDefine.UserStat.Builder.decodeToBuilder(jsonMap:oneValueUserStatList).build()

                        jsonArrayUserStatList.append(messageFromStringUserStatList)
                    }
                    resultDecodedBuilder.userStatList = jsonArrayUserStatList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImusersStatRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImusersStatRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImchangeAvatarReq : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImchangeAvatarReq.Builder

        public static func == (lhs: Im.Buddy.ImchangeAvatarReq, rhs: Im.Buddy.ImchangeAvatarReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasAvatarUrl == rhs.hasAvatarUrl) && (!lhs.hasAvatarUrl || lhs.avatarUrl == rhs.avatarUrl)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x020c
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var avatarUrl:String! = nil
        public fileprivate(set) var hasAvatarUrl:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasAvatarUrl {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasAvatarUrl {
                try codedOutputStream.writeString(fieldNumber: 2, value:avatarUrl)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasAvatarUrl {
                serialize_size += avatarUrl.computeStringSize(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImchangeAvatarReq.Builder {
            return Im.Buddy.ImchangeAvatarReq.classBuilder() as! Im.Buddy.ImchangeAvatarReq.Builder
        }
        public func getBuilder() -> Im.Buddy.ImchangeAvatarReq.Builder {
            return classBuilder() as! Im.Buddy.ImchangeAvatarReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImchangeAvatarReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImchangeAvatarReq.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImchangeAvatarReq.Builder {
            return try Im.Buddy.ImchangeAvatarReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImchangeAvatarReq) throws -> Im.Buddy.ImchangeAvatarReq.Builder {
            return try Im.Buddy.ImchangeAvatarReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasAvatarUrl {
                jsonMap["avatarUrl"] = avatarUrl
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImchangeAvatarReq {
            return try Im.Buddy.ImchangeAvatarReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImchangeAvatarReq {
            return try Im.Buddy.ImchangeAvatarReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasAvatarUrl {
                output += "\(indent) avatarUrl: \(avatarUrl) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasAvatarUrl {
                    hashCode = (hashCode &* 31) &+ avatarUrl.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImchangeAvatarReq"
        }
        override public func className() -> String {
            return "Im.Buddy.ImchangeAvatarReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImchangeAvatarReq = Im.Buddy.ImchangeAvatarReq()
            public func getMessage() -> Im.Buddy.ImchangeAvatarReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x020c
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImchangeAvatarReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImchangeAvatarReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var avatarUrl:String {
                get {
                    return builderResult.avatarUrl
                }
                set (value) {
                    builderResult.hasAvatarUrl = true
                    builderResult.avatarUrl = value
                }
            }
            public var hasAvatarUrl:Bool {
                get {
                    return builderResult.hasAvatarUrl
                }
            }
            @discardableResult
            public func setAvatarUrl(_ value:String) -> Im.Buddy.ImchangeAvatarReq.Builder {
                self.avatarUrl = value
                return self
            }
            @discardableResult
            public func clearAvatarUrl() -> Im.Buddy.ImchangeAvatarReq.Builder{
                builderResult.hasAvatarUrl = false
                builderResult.avatarUrl = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImchangeAvatarReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImchangeAvatarReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImchangeAvatarReq.Builder {
                builderResult = Im.Buddy.ImchangeAvatarReq()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImchangeAvatarReq.Builder {
                return try Im.Buddy.ImchangeAvatarReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImchangeAvatarReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImchangeAvatarReq {
                let returnMe:Im.Buddy.ImchangeAvatarReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImchangeAvatarReq) throws -> Im.Buddy.ImchangeAvatarReq.Builder {
                if other == Im.Buddy.ImchangeAvatarReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasAvatarUrl {
                    avatarUrl = other.avatarUrl
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImchangeAvatarReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeAvatarReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 18:
                        avatarUrl = try codedInputStream.readString()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImchangeAvatarReq.Builder {
                let resultDecodedBuilder = Im.Buddy.ImchangeAvatarReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueAvatarUrl = jsonMap["avatarUrl"] as? String {
                    resultDecodedBuilder.avatarUrl = jsonValueAvatarUrl
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImchangeAvatarReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImchangeAvatarReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImchangeAvatarRsp : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImchangeAvatarRsp.Builder

        public static func == (lhs: Im.Buddy.ImchangeAvatarRsp, rhs: Im.Buddy.ImchangeAvatarRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x020d
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasResultCode {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:resultCode)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImchangeAvatarRsp.Builder {
            return Im.Buddy.ImchangeAvatarRsp.classBuilder() as! Im.Buddy.ImchangeAvatarRsp.Builder
        }
        public func getBuilder() -> Im.Buddy.ImchangeAvatarRsp.Builder {
            return classBuilder() as! Im.Buddy.ImchangeAvatarRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImchangeAvatarRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImchangeAvatarRsp.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImchangeAvatarRsp.Builder {
            return try Im.Buddy.ImchangeAvatarRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImchangeAvatarRsp) throws -> Im.Buddy.ImchangeAvatarRsp.Builder {
            return try Im.Buddy.ImchangeAvatarRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImchangeAvatarRsp {
            return try Im.Buddy.ImchangeAvatarRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImchangeAvatarRsp {
            return try Im.Buddy.ImchangeAvatarRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImchangeAvatarRsp"
        }
        override public func className() -> String {
            return "Im.Buddy.ImchangeAvatarRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImchangeAvatarRsp = Im.Buddy.ImchangeAvatarRsp()
            public func getMessage() -> Im.Buddy.ImchangeAvatarRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x020d
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImchangeAvatarRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImchangeAvatarRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.Buddy.ImchangeAvatarRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.Buddy.ImchangeAvatarRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImchangeAvatarRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImchangeAvatarRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImchangeAvatarRsp.Builder {
                builderResult = Im.Buddy.ImchangeAvatarRsp()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImchangeAvatarRsp.Builder {
                return try Im.Buddy.ImchangeAvatarRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImchangeAvatarRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImchangeAvatarRsp {
                let returnMe:Im.Buddy.ImchangeAvatarRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImchangeAvatarRsp) throws -> Im.Buddy.ImchangeAvatarRsp.Builder {
                if other == Im.Buddy.ImchangeAvatarRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImchangeAvatarRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeAvatarRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        resultCode = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImchangeAvatarRsp.Builder {
                let resultDecodedBuilder = Im.Buddy.ImchangeAvatarRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImchangeAvatarRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImchangeAvatarRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///只给移动端通知
    final public class ImpcloginStatusNotify : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImpcloginStatusNotify.Builder

        public static func == (lhs: Im.Buddy.ImpcloginStatusNotify, rhs: Im.Buddy.ImpcloginStatusNotify) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasLoginStat == rhs.hasLoginStat) && (!lhs.hasLoginStat || lhs.loginStat == rhs.loginStat)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x020e
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var loginStat:Im.BaseDefine.UserStatType = Im.BaseDefine.UserStatType.userStatusOnline
        public fileprivate(set) var hasLoginStat:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasLoginStat {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasLoginStat {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:loginStat.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasLoginStat) {
                serialize_size += loginStat.rawValue.computeEnumSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImpcloginStatusNotify.Builder {
            return Im.Buddy.ImpcloginStatusNotify.classBuilder() as! Im.Buddy.ImpcloginStatusNotify.Builder
        }
        public func getBuilder() -> Im.Buddy.ImpcloginStatusNotify.Builder {
            return classBuilder() as! Im.Buddy.ImpcloginStatusNotify.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImpcloginStatusNotify.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImpcloginStatusNotify.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImpcloginStatusNotify.Builder {
            return try Im.Buddy.ImpcloginStatusNotify.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImpcloginStatusNotify) throws -> Im.Buddy.ImpcloginStatusNotify.Builder {
            return try Im.Buddy.ImpcloginStatusNotify.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasLoginStat {
                jsonMap["loginStat"] = loginStat.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImpcloginStatusNotify {
            return try Im.Buddy.ImpcloginStatusNotify.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImpcloginStatusNotify {
            return try Im.Buddy.ImpcloginStatusNotify.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasLoginStat) {
                output += "\(indent) loginStat: \(loginStat.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasLoginStat {
                     hashCode = (hashCode &* 31) &+ loginStat.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImpcloginStatusNotify"
        }
        override public func className() -> String {
            return "Im.Buddy.ImpcloginStatusNotify"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImpcloginStatusNotify = Im.Buddy.ImpcloginStatusNotify()
            public func getMessage() -> Im.Buddy.ImpcloginStatusNotify {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x020e
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImpcloginStatusNotify.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImpcloginStatusNotify.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var loginStat:Im.BaseDefine.UserStatType {
                    get {
                        return builderResult.loginStat
                    }
                    set (value) {
                        builderResult.hasLoginStat = true
                        builderResult.loginStat = value
                    }
                }
                public var hasLoginStat:Bool{
                    get {
                        return builderResult.hasLoginStat
                    }
                }
            @discardableResult
                public func setLoginStat(_ value:Im.BaseDefine.UserStatType) -> Im.Buddy.ImpcloginStatusNotify.Builder {
                  self.loginStat = value
                  return self
                }
            @discardableResult
                public func clearLoginStat() -> Im.Buddy.ImpcloginStatusNotify.Builder {
                   builderResult.hasLoginStat = false
                   builderResult.loginStat = .userStatusOnline
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImpcloginStatusNotify.Builder {
                builderResult = Im.Buddy.ImpcloginStatusNotify()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImpcloginStatusNotify.Builder {
                return try Im.Buddy.ImpcloginStatusNotify.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImpcloginStatusNotify {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImpcloginStatusNotify {
                let returnMe:Im.Buddy.ImpcloginStatusNotify = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImpcloginStatusNotify) throws -> Im.Buddy.ImpcloginStatusNotify.Builder {
                if other == Im.Buddy.ImpcloginStatusNotify() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasLoginStat {
                    loginStat = other.loginStat
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImpcloginStatusNotify.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImpcloginStatusNotify.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntloginStat = try codedInputStream.readEnum()
                        if let enumsloginStat = Im.BaseDefine.UserStatType(rawValue:valueIntloginStat){
                            loginStat = enumsloginStat
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntloginStat))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImpcloginStatusNotify.Builder {
                let resultDecodedBuilder = Im.Buddy.ImpcloginStatusNotify.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueLoginStat = jsonMap["loginStat"] as? String {
                    resultDecodedBuilder.loginStat = try Im.BaseDefine.UserStatType.fromString(jsonValueLoginStat)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImpcloginStatusNotify.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImpcloginStatusNotify.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImremoveSessionNotify : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImremoveSessionNotify.Builder

        public static func == (lhs: Im.Buddy.ImremoveSessionNotify, rhs: Im.Buddy.ImremoveSessionNotify) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x020f
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasSessionType {
                return false
            }
            if !hasSessionId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:sessionType.rawValue)
            }
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:sessionId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImremoveSessionNotify.Builder {
            return Im.Buddy.ImremoveSessionNotify.classBuilder() as! Im.Buddy.ImremoveSessionNotify.Builder
        }
        public func getBuilder() -> Im.Buddy.ImremoveSessionNotify.Builder {
            return classBuilder() as! Im.Buddy.ImremoveSessionNotify.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImremoveSessionNotify.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImremoveSessionNotify.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImremoveSessionNotify.Builder {
            return try Im.Buddy.ImremoveSessionNotify.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImremoveSessionNotify) throws -> Im.Buddy.ImremoveSessionNotify.Builder {
            return try Im.Buddy.ImremoveSessionNotify.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImremoveSessionNotify {
            return try Im.Buddy.ImremoveSessionNotify.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImremoveSessionNotify {
            return try Im.Buddy.ImremoveSessionNotify.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImremoveSessionNotify"
        }
        override public func className() -> String {
            return "Im.Buddy.ImremoveSessionNotify"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImremoveSessionNotify = Im.Buddy.ImremoveSessionNotify()
            public func getMessage() -> Im.Buddy.ImremoveSessionNotify {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x020f
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImremoveSessionNotify.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImremoveSessionNotify.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.Buddy.ImremoveSessionNotify.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.Buddy.ImremoveSessionNotify.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.Buddy.ImremoveSessionNotify.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.Buddy.ImremoveSessionNotify.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImremoveSessionNotify.Builder {
                builderResult = Im.Buddy.ImremoveSessionNotify()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImremoveSessionNotify.Builder {
                return try Im.Buddy.ImremoveSessionNotify.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImremoveSessionNotify {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImremoveSessionNotify {
                let returnMe:Im.Buddy.ImremoveSessionNotify = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImremoveSessionNotify) throws -> Im.Buddy.ImremoveSessionNotify.Builder {
                if other == Im.Buddy.ImremoveSessionNotify() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImremoveSessionNotify.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImremoveSessionNotify.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntsessionType))
                        }

                    case 24:
                        sessionId = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImremoveSessionNotify.Builder {
                let resultDecodedBuilder = Im.Buddy.ImremoveSessionNotify.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImremoveSessionNotify.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImremoveSessionNotify.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImdepartmentReq : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImdepartmentReq.Builder

        public static func == (lhs: Im.Buddy.ImdepartmentReq, rhs: Im.Buddy.ImdepartmentReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasLatestUpdateTime == rhs.hasLatestUpdateTime) && (!lhs.hasLatestUpdateTime || lhs.latestUpdateTime == rhs.latestUpdateTime)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0210
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var latestUpdateTime:UInt32! = nil
        public fileprivate(set) var hasLatestUpdateTime:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasLatestUpdateTime {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasLatestUpdateTime {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:latestUpdateTime)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasLatestUpdateTime {
                serialize_size += latestUpdateTime.computeUInt32Size(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImdepartmentReq.Builder {
            return Im.Buddy.ImdepartmentReq.classBuilder() as! Im.Buddy.ImdepartmentReq.Builder
        }
        public func getBuilder() -> Im.Buddy.ImdepartmentReq.Builder {
            return classBuilder() as! Im.Buddy.ImdepartmentReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImdepartmentReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImdepartmentReq.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImdepartmentReq.Builder {
            return try Im.Buddy.ImdepartmentReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImdepartmentReq) throws -> Im.Buddy.ImdepartmentReq.Builder {
            return try Im.Buddy.ImdepartmentReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasLatestUpdateTime {
                jsonMap["latestUpdateTime"] = UInt(latestUpdateTime)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImdepartmentReq {
            return try Im.Buddy.ImdepartmentReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImdepartmentReq {
            return try Im.Buddy.ImdepartmentReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasLatestUpdateTime {
                output += "\(indent) latestUpdateTime: \(latestUpdateTime) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasLatestUpdateTime {
                    hashCode = (hashCode &* 31) &+ latestUpdateTime.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImdepartmentReq"
        }
        override public func className() -> String {
            return "Im.Buddy.ImdepartmentReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImdepartmentReq = Im.Buddy.ImdepartmentReq()
            public func getMessage() -> Im.Buddy.ImdepartmentReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0210
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImdepartmentReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImdepartmentReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var latestUpdateTime:UInt32 {
                get {
                    return builderResult.latestUpdateTime
                }
                set (value) {
                    builderResult.hasLatestUpdateTime = true
                    builderResult.latestUpdateTime = value
                }
            }
            public var hasLatestUpdateTime:Bool {
                get {
                    return builderResult.hasLatestUpdateTime
                }
            }
            @discardableResult
            public func setLatestUpdateTime(_ value:UInt32) -> Im.Buddy.ImdepartmentReq.Builder {
                self.latestUpdateTime = value
                return self
            }
            @discardableResult
            public func clearLatestUpdateTime() -> Im.Buddy.ImdepartmentReq.Builder{
                builderResult.hasLatestUpdateTime = false
                builderResult.latestUpdateTime = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImdepartmentReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImdepartmentReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImdepartmentReq.Builder {
                builderResult = Im.Buddy.ImdepartmentReq()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImdepartmentReq.Builder {
                return try Im.Buddy.ImdepartmentReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImdepartmentReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImdepartmentReq {
                let returnMe:Im.Buddy.ImdepartmentReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImdepartmentReq) throws -> Im.Buddy.ImdepartmentReq.Builder {
                if other == Im.Buddy.ImdepartmentReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasLatestUpdateTime {
                    latestUpdateTime = other.latestUpdateTime
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImdepartmentReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImdepartmentReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        latestUpdateTime = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImdepartmentReq.Builder {
                let resultDecodedBuilder = Im.Buddy.ImdepartmentReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? UInt {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)
                } else if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? String {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImdepartmentReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImdepartmentReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImdepartmentRsp : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImdepartmentRsp.Builder

        public static func == (lhs: Im.Buddy.ImdepartmentRsp, rhs: Im.Buddy.ImdepartmentRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasLatestUpdateTime == rhs.hasLatestUpdateTime) && (!lhs.hasLatestUpdateTime || lhs.latestUpdateTime == rhs.latestUpdateTime)
            fieldCheck = fieldCheck && (lhs.deptList == rhs.deptList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0211
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var latestUpdateTime:UInt32! = nil
        public fileprivate(set) var hasLatestUpdateTime:Bool = false

        public fileprivate(set) var deptList:Array<Im.BaseDefine.DepartInfo>  = Array<Im.BaseDefine.DepartInfo>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasLatestUpdateTime {
                return false
            }
            var isInitDeptList:Bool = true
            for oneElementDeptList in deptList {
                if !oneElementDeptList.isInitialized() {
                    isInitDeptList = false
                    break 
                }
            }
            if !isInitDeptList {
                return isInitDeptList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasLatestUpdateTime {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:latestUpdateTime)
            }
            for oneElementDeptList in deptList {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementDeptList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasLatestUpdateTime {
                serialize_size += latestUpdateTime.computeUInt32Size(fieldNumber: 2)
            }
            for oneElementDeptList in deptList {
                serialize_size += oneElementDeptList.computeMessageSize(fieldNumber: 3)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImdepartmentRsp.Builder {
            return Im.Buddy.ImdepartmentRsp.classBuilder() as! Im.Buddy.ImdepartmentRsp.Builder
        }
        public func getBuilder() -> Im.Buddy.ImdepartmentRsp.Builder {
            return classBuilder() as! Im.Buddy.ImdepartmentRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImdepartmentRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImdepartmentRsp.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImdepartmentRsp.Builder {
            return try Im.Buddy.ImdepartmentRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImdepartmentRsp) throws -> Im.Buddy.ImdepartmentRsp.Builder {
            return try Im.Buddy.ImdepartmentRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasLatestUpdateTime {
                jsonMap["latestUpdateTime"] = UInt(latestUpdateTime)
            }
            if !deptList.isEmpty {
                var jsonArrayDeptList:Array<Dictionary<String,Any>> = []
                for oneValueDeptList in deptList {
                    let ecodedMessageDeptList = try oneValueDeptList.encode()
                    jsonArrayDeptList.append(ecodedMessageDeptList)
                }
                jsonMap["deptList"] = jsonArrayDeptList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImdepartmentRsp {
            return try Im.Buddy.ImdepartmentRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImdepartmentRsp {
            return try Im.Buddy.ImdepartmentRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasLatestUpdateTime {
                output += "\(indent) latestUpdateTime: \(latestUpdateTime) \n"
            }
            var deptListElementIndex:Int = 0
            for oneElementDeptList in deptList {
                output += "\(indent) deptList[\(deptListElementIndex)] {\n"
                output += try oneElementDeptList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                deptListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasLatestUpdateTime {
                    hashCode = (hashCode &* 31) &+ latestUpdateTime.hashValue
                }
                for oneElementDeptList in deptList {
                    hashCode = (hashCode &* 31) &+ oneElementDeptList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImdepartmentRsp"
        }
        override public func className() -> String {
            return "Im.Buddy.ImdepartmentRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImdepartmentRsp = Im.Buddy.ImdepartmentRsp()
            public func getMessage() -> Im.Buddy.ImdepartmentRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0211
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImdepartmentRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImdepartmentRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var latestUpdateTime:UInt32 {
                get {
                    return builderResult.latestUpdateTime
                }
                set (value) {
                    builderResult.hasLatestUpdateTime = true
                    builderResult.latestUpdateTime = value
                }
            }
            public var hasLatestUpdateTime:Bool {
                get {
                    return builderResult.hasLatestUpdateTime
                }
            }
            @discardableResult
            public func setLatestUpdateTime(_ value:UInt32) -> Im.Buddy.ImdepartmentRsp.Builder {
                self.latestUpdateTime = value
                return self
            }
            @discardableResult
            public func clearLatestUpdateTime() -> Im.Buddy.ImdepartmentRsp.Builder{
                builderResult.hasLatestUpdateTime = false
                builderResult.latestUpdateTime = nil
                return self
            }
            public var deptList:Array<Im.BaseDefine.DepartInfo> {
                get {
                    return builderResult.deptList
                }
                set (value) {
                    builderResult.deptList = value
                }
            }
            @discardableResult
            public func setDeptList(_ value:Array<Im.BaseDefine.DepartInfo>) -> Im.Buddy.ImdepartmentRsp.Builder {
                self.deptList = value
                return self
            }
            @discardableResult
            public func clearDeptList() -> Im.Buddy.ImdepartmentRsp.Builder {
                builderResult.deptList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImdepartmentRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImdepartmentRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImdepartmentRsp.Builder {
                builderResult = Im.Buddy.ImdepartmentRsp()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImdepartmentRsp.Builder {
                return try Im.Buddy.ImdepartmentRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImdepartmentRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImdepartmentRsp {
                let returnMe:Im.Buddy.ImdepartmentRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImdepartmentRsp) throws -> Im.Buddy.ImdepartmentRsp.Builder {
                if other == Im.Buddy.ImdepartmentRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasLatestUpdateTime {
                    latestUpdateTime = other.latestUpdateTime
                }
                if !other.deptList.isEmpty  {
                     builderResult.deptList += other.deptList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImdepartmentRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImdepartmentRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        latestUpdateTime = try codedInputStream.readUInt32()

                    case 26:
                        let subBuilder = Im.BaseDefine.DepartInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        deptList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImdepartmentRsp.Builder {
                let resultDecodedBuilder = Im.Buddy.ImdepartmentRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? UInt {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)
                } else if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? String {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)!
                }
                if let jsonValueDeptList = jsonMap["deptList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayDeptList:Array<Im.BaseDefine.DepartInfo> = []
                    for oneValueDeptList in jsonValueDeptList {
                        let messageFromStringDeptList = try Im.BaseDefine.DepartInfo.Builder.decodeToBuilder(jsonMap:oneValueDeptList).build()

                        jsonArrayDeptList.append(messageFromStringDeptList)
                    }
                    resultDecodedBuilder.deptList = jsonArrayDeptList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImdepartmentRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImdepartmentRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImavatarChangedNotify : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImavatarChangedNotify.Builder

        public static func == (lhs: Im.Buddy.ImavatarChangedNotify, rhs: Im.Buddy.ImavatarChangedNotify) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChangedUserId == rhs.hasChangedUserId) && (!lhs.hasChangedUserId || lhs.changedUserId == rhs.changedUserId)
            fieldCheck = fieldCheck && (lhs.hasAvatarUrl == rhs.hasAvatarUrl) && (!lhs.hasAvatarUrl || lhs.avatarUrl == rhs.avatarUrl)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x02012
        public fileprivate(set) var changedUserId:UInt32! = nil
        public fileprivate(set) var hasChangedUserId:Bool = false

        public fileprivate(set) var avatarUrl:String! = nil
        public fileprivate(set) var hasAvatarUrl:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasChangedUserId {
                return false
            }
            if !hasAvatarUrl {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChangedUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:changedUserId)
            }
            if hasAvatarUrl {
                try codedOutputStream.writeString(fieldNumber: 2, value:avatarUrl)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChangedUserId {
                serialize_size += changedUserId.computeUInt32Size(fieldNumber: 1)
            }
            if hasAvatarUrl {
                serialize_size += avatarUrl.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImavatarChangedNotify.Builder {
            return Im.Buddy.ImavatarChangedNotify.classBuilder() as! Im.Buddy.ImavatarChangedNotify.Builder
        }
        public func getBuilder() -> Im.Buddy.ImavatarChangedNotify.Builder {
            return classBuilder() as! Im.Buddy.ImavatarChangedNotify.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImavatarChangedNotify.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImavatarChangedNotify.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImavatarChangedNotify.Builder {
            return try Im.Buddy.ImavatarChangedNotify.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImavatarChangedNotify) throws -> Im.Buddy.ImavatarChangedNotify.Builder {
            return try Im.Buddy.ImavatarChangedNotify.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChangedUserId {
                jsonMap["changedUserId"] = UInt(changedUserId)
            }
            if hasAvatarUrl {
                jsonMap["avatarUrl"] = avatarUrl
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImavatarChangedNotify {
            return try Im.Buddy.ImavatarChangedNotify.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImavatarChangedNotify {
            return try Im.Buddy.ImavatarChangedNotify.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChangedUserId {
                output += "\(indent) changedUserId: \(changedUserId) \n"
            }
            if hasAvatarUrl {
                output += "\(indent) avatarUrl: \(avatarUrl) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChangedUserId {
                    hashCode = (hashCode &* 31) &+ changedUserId.hashValue
                }
                if hasAvatarUrl {
                    hashCode = (hashCode &* 31) &+ avatarUrl.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImavatarChangedNotify"
        }
        override public func className() -> String {
            return "Im.Buddy.ImavatarChangedNotify"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImavatarChangedNotify = Im.Buddy.ImavatarChangedNotify()
            public func getMessage() -> Im.Buddy.ImavatarChangedNotify {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x02012
            public var changedUserId:UInt32 {
                get {
                    return builderResult.changedUserId
                }
                set (value) {
                    builderResult.hasChangedUserId = true
                    builderResult.changedUserId = value
                }
            }
            public var hasChangedUserId:Bool {
                get {
                    return builderResult.hasChangedUserId
                }
            }
            @discardableResult
            public func setChangedUserId(_ value:UInt32) -> Im.Buddy.ImavatarChangedNotify.Builder {
                self.changedUserId = value
                return self
            }
            @discardableResult
            public func clearChangedUserId() -> Im.Buddy.ImavatarChangedNotify.Builder{
                builderResult.hasChangedUserId = false
                builderResult.changedUserId = nil
                return self
            }
            public var avatarUrl:String {
                get {
                    return builderResult.avatarUrl
                }
                set (value) {
                    builderResult.hasAvatarUrl = true
                    builderResult.avatarUrl = value
                }
            }
            public var hasAvatarUrl:Bool {
                get {
                    return builderResult.hasAvatarUrl
                }
            }
            @discardableResult
            public func setAvatarUrl(_ value:String) -> Im.Buddy.ImavatarChangedNotify.Builder {
                self.avatarUrl = value
                return self
            }
            @discardableResult
            public func clearAvatarUrl() -> Im.Buddy.ImavatarChangedNotify.Builder{
                builderResult.hasAvatarUrl = false
                builderResult.avatarUrl = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImavatarChangedNotify.Builder {
                builderResult = Im.Buddy.ImavatarChangedNotify()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImavatarChangedNotify.Builder {
                return try Im.Buddy.ImavatarChangedNotify.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImavatarChangedNotify {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImavatarChangedNotify {
                let returnMe:Im.Buddy.ImavatarChangedNotify = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImavatarChangedNotify) throws -> Im.Buddy.ImavatarChangedNotify.Builder {
                if other == Im.Buddy.ImavatarChangedNotify() {
                    return self
                }
                if other.hasChangedUserId {
                    changedUserId = other.changedUserId
                }
                if other.hasAvatarUrl {
                    avatarUrl = other.avatarUrl
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImavatarChangedNotify.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImavatarChangedNotify.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        changedUserId = try codedInputStream.readUInt32()

                    case 18:
                        avatarUrl = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImavatarChangedNotify.Builder {
                let resultDecodedBuilder = Im.Buddy.ImavatarChangedNotify.Builder()
                if let jsonValueChangedUserId = jsonMap["changedUserId"] as? UInt {
                    resultDecodedBuilder.changedUserId = UInt32(jsonValueChangedUserId)
                } else if let jsonValueChangedUserId = jsonMap["changedUserId"] as? String {
                    resultDecodedBuilder.changedUserId = UInt32(jsonValueChangedUserId)!
                }
                if let jsonValueAvatarUrl = jsonMap["avatarUrl"] as? String {
                    resultDecodedBuilder.avatarUrl = jsonValueAvatarUrl
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImavatarChangedNotify.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImavatarChangedNotify.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImchangeSignInfoReq : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImchangeSignInfoReq.Builder

        public static func == (lhs: Im.Buddy.ImchangeSignInfoReq, rhs: Im.Buddy.ImchangeSignInfoReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasSignInfo == rhs.hasSignInfo) && (!lhs.hasSignInfo || lhs.signInfo == rhs.signInfo)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0213
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var signInfo:String! = nil
        public fileprivate(set) var hasSignInfo:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasSignInfo {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasSignInfo {
                try codedOutputStream.writeString(fieldNumber: 2, value:signInfo)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasSignInfo {
                serialize_size += signInfo.computeStringSize(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImchangeSignInfoReq.Builder {
            return Im.Buddy.ImchangeSignInfoReq.classBuilder() as! Im.Buddy.ImchangeSignInfoReq.Builder
        }
        public func getBuilder() -> Im.Buddy.ImchangeSignInfoReq.Builder {
            return classBuilder() as! Im.Buddy.ImchangeSignInfoReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImchangeSignInfoReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImchangeSignInfoReq.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImchangeSignInfoReq.Builder {
            return try Im.Buddy.ImchangeSignInfoReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImchangeSignInfoReq) throws -> Im.Buddy.ImchangeSignInfoReq.Builder {
            return try Im.Buddy.ImchangeSignInfoReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasSignInfo {
                jsonMap["signInfo"] = signInfo
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImchangeSignInfoReq {
            return try Im.Buddy.ImchangeSignInfoReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImchangeSignInfoReq {
            return try Im.Buddy.ImchangeSignInfoReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasSignInfo {
                output += "\(indent) signInfo: \(signInfo) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasSignInfo {
                    hashCode = (hashCode &* 31) &+ signInfo.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImchangeSignInfoReq"
        }
        override public func className() -> String {
            return "Im.Buddy.ImchangeSignInfoReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImchangeSignInfoReq = Im.Buddy.ImchangeSignInfoReq()
            public func getMessage() -> Im.Buddy.ImchangeSignInfoReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0213
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImchangeSignInfoReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImchangeSignInfoReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var signInfo:String {
                get {
                    return builderResult.signInfo
                }
                set (value) {
                    builderResult.hasSignInfo = true
                    builderResult.signInfo = value
                }
            }
            public var hasSignInfo:Bool {
                get {
                    return builderResult.hasSignInfo
                }
            }
            @discardableResult
            public func setSignInfo(_ value:String) -> Im.Buddy.ImchangeSignInfoReq.Builder {
                self.signInfo = value
                return self
            }
            @discardableResult
            public func clearSignInfo() -> Im.Buddy.ImchangeSignInfoReq.Builder{
                builderResult.hasSignInfo = false
                builderResult.signInfo = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImchangeSignInfoReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImchangeSignInfoReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImchangeSignInfoReq.Builder {
                builderResult = Im.Buddy.ImchangeSignInfoReq()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImchangeSignInfoReq.Builder {
                return try Im.Buddy.ImchangeSignInfoReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImchangeSignInfoReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImchangeSignInfoReq {
                let returnMe:Im.Buddy.ImchangeSignInfoReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImchangeSignInfoReq) throws -> Im.Buddy.ImchangeSignInfoReq.Builder {
                if other == Im.Buddy.ImchangeSignInfoReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasSignInfo {
                    signInfo = other.signInfo
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImchangeSignInfoReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeSignInfoReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 18:
                        signInfo = try codedInputStream.readString()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImchangeSignInfoReq.Builder {
                let resultDecodedBuilder = Im.Buddy.ImchangeSignInfoReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueSignInfo = jsonMap["signInfo"] as? String {
                    resultDecodedBuilder.signInfo = jsonValueSignInfo
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImchangeSignInfoReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImchangeSignInfoReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }
    }

    final public class ImchangeSignInfoRsp : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImchangeSignInfoRsp.Builder

        public static func == (lhs: Im.Buddy.ImchangeSignInfoRsp, rhs: Im.Buddy.ImchangeSignInfoRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasSignInfo == rhs.hasSignInfo) && (!lhs.hasSignInfo || lhs.signInfo == rhs.signInfo)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0214
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        /// 此字段服务端用，客户端直接忽略
        public fileprivate(set) var signInfo:String! = nil
        public fileprivate(set) var hasSignInfo:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasResultCode {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:resultCode)
            }
            if hasSignInfo {
                try codedOutputStream.writeString(fieldNumber: 3, value:signInfo)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 2)
            }
            if hasSignInfo {
                serialize_size += signInfo.computeStringSize(fieldNumber: 3)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImchangeSignInfoRsp.Builder {
            return Im.Buddy.ImchangeSignInfoRsp.classBuilder() as! Im.Buddy.ImchangeSignInfoRsp.Builder
        }
        public func getBuilder() -> Im.Buddy.ImchangeSignInfoRsp.Builder {
            return classBuilder() as! Im.Buddy.ImchangeSignInfoRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImchangeSignInfoRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImchangeSignInfoRsp.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImchangeSignInfoRsp.Builder {
            return try Im.Buddy.ImchangeSignInfoRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImchangeSignInfoRsp) throws -> Im.Buddy.ImchangeSignInfoRsp.Builder {
            return try Im.Buddy.ImchangeSignInfoRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            if hasSignInfo {
                jsonMap["signInfo"] = signInfo
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImchangeSignInfoRsp {
            return try Im.Buddy.ImchangeSignInfoRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImchangeSignInfoRsp {
            return try Im.Buddy.ImchangeSignInfoRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            if hasSignInfo {
                output += "\(indent) signInfo: \(signInfo) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasSignInfo {
                    hashCode = (hashCode &* 31) &+ signInfo.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImchangeSignInfoRsp"
        }
        override public func className() -> String {
            return "Im.Buddy.ImchangeSignInfoRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImchangeSignInfoRsp = Im.Buddy.ImchangeSignInfoRsp()
            public func getMessage() -> Im.Buddy.ImchangeSignInfoRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0214
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImchangeSignInfoRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImchangeSignInfoRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.Buddy.ImchangeSignInfoRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.Buddy.ImchangeSignInfoRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            /// 此字段服务端用，客户端直接忽略
            public var signInfo:String {
                get {
                    return builderResult.signInfo
                }
                set (value) {
                    builderResult.hasSignInfo = true
                    builderResult.signInfo = value
                }
            }
            public var hasSignInfo:Bool {
                get {
                    return builderResult.hasSignInfo
                }
            }
            @discardableResult
            public func setSignInfo(_ value:String) -> Im.Buddy.ImchangeSignInfoRsp.Builder {
                self.signInfo = value
                return self
            }
            @discardableResult
            public func clearSignInfo() -> Im.Buddy.ImchangeSignInfoRsp.Builder{
                builderResult.hasSignInfo = false
                builderResult.signInfo = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImchangeSignInfoRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImchangeSignInfoRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImchangeSignInfoRsp.Builder {
                builderResult = Im.Buddy.ImchangeSignInfoRsp()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImchangeSignInfoRsp.Builder {
                return try Im.Buddy.ImchangeSignInfoRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImchangeSignInfoRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImchangeSignInfoRsp {
                let returnMe:Im.Buddy.ImchangeSignInfoRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImchangeSignInfoRsp) throws -> Im.Buddy.ImchangeSignInfoRsp.Builder {
                if other == Im.Buddy.ImchangeSignInfoRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasSignInfo {
                    signInfo = other.signInfo
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImchangeSignInfoRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeSignInfoRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        resultCode = try codedInputStream.readUInt32()

                    case 26:
                        signInfo = try codedInputStream.readString()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImchangeSignInfoRsp.Builder {
                let resultDecodedBuilder = Im.Buddy.ImchangeSignInfoRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                if let jsonValueSignInfo = jsonMap["signInfo"] as? String {
                    resultDecodedBuilder.signInfo = jsonValueSignInfo
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImchangeSignInfoRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImchangeSignInfoRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// 个性签名修改通知（广播）
    final public class ImsignInfoChangedNotify : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImsignInfoChangedNotify.Builder

        public static func == (lhs: Im.Buddy.ImsignInfoChangedNotify, rhs: Im.Buddy.ImsignInfoChangedNotify) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasChangedUserId == rhs.hasChangedUserId) && (!lhs.hasChangedUserId || lhs.changedUserId == rhs.changedUserId)
            fieldCheck = fieldCheck && (lhs.hasSignInfo == rhs.hasSignInfo) && (!lhs.hasSignInfo || lhs.signInfo == rhs.signInfo)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0215
        public fileprivate(set) var changedUserId:UInt32! = nil
        public fileprivate(set) var hasChangedUserId:Bool = false

        public fileprivate(set) var signInfo:String! = nil
        public fileprivate(set) var hasSignInfo:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasChangedUserId {
                return false
            }
            if !hasSignInfo {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasChangedUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:changedUserId)
            }
            if hasSignInfo {
                try codedOutputStream.writeString(fieldNumber: 2, value:signInfo)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasChangedUserId {
                serialize_size += changedUserId.computeUInt32Size(fieldNumber: 1)
            }
            if hasSignInfo {
                serialize_size += signInfo.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImsignInfoChangedNotify.Builder {
            return Im.Buddy.ImsignInfoChangedNotify.classBuilder() as! Im.Buddy.ImsignInfoChangedNotify.Builder
        }
        public func getBuilder() -> Im.Buddy.ImsignInfoChangedNotify.Builder {
            return classBuilder() as! Im.Buddy.ImsignInfoChangedNotify.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImsignInfoChangedNotify.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImsignInfoChangedNotify.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImsignInfoChangedNotify.Builder {
            return try Im.Buddy.ImsignInfoChangedNotify.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImsignInfoChangedNotify) throws -> Im.Buddy.ImsignInfoChangedNotify.Builder {
            return try Im.Buddy.ImsignInfoChangedNotify.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasChangedUserId {
                jsonMap["changedUserId"] = UInt(changedUserId)
            }
            if hasSignInfo {
                jsonMap["signInfo"] = signInfo
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImsignInfoChangedNotify {
            return try Im.Buddy.ImsignInfoChangedNotify.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImsignInfoChangedNotify {
            return try Im.Buddy.ImsignInfoChangedNotify.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasChangedUserId {
                output += "\(indent) changedUserId: \(changedUserId) \n"
            }
            if hasSignInfo {
                output += "\(indent) signInfo: \(signInfo) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasChangedUserId {
                    hashCode = (hashCode &* 31) &+ changedUserId.hashValue
                }
                if hasSignInfo {
                    hashCode = (hashCode &* 31) &+ signInfo.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImsignInfoChangedNotify"
        }
        override public func className() -> String {
            return "Im.Buddy.ImsignInfoChangedNotify"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImsignInfoChangedNotify = Im.Buddy.ImsignInfoChangedNotify()
            public func getMessage() -> Im.Buddy.ImsignInfoChangedNotify {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0215
            public var changedUserId:UInt32 {
                get {
                    return builderResult.changedUserId
                }
                set (value) {
                    builderResult.hasChangedUserId = true
                    builderResult.changedUserId = value
                }
            }
            public var hasChangedUserId:Bool {
                get {
                    return builderResult.hasChangedUserId
                }
            }
            @discardableResult
            public func setChangedUserId(_ value:UInt32) -> Im.Buddy.ImsignInfoChangedNotify.Builder {
                self.changedUserId = value
                return self
            }
            @discardableResult
            public func clearChangedUserId() -> Im.Buddy.ImsignInfoChangedNotify.Builder{
                builderResult.hasChangedUserId = false
                builderResult.changedUserId = nil
                return self
            }
            public var signInfo:String {
                get {
                    return builderResult.signInfo
                }
                set (value) {
                    builderResult.hasSignInfo = true
                    builderResult.signInfo = value
                }
            }
            public var hasSignInfo:Bool {
                get {
                    return builderResult.hasSignInfo
                }
            }
            @discardableResult
            public func setSignInfo(_ value:String) -> Im.Buddy.ImsignInfoChangedNotify.Builder {
                self.signInfo = value
                return self
            }
            @discardableResult
            public func clearSignInfo() -> Im.Buddy.ImsignInfoChangedNotify.Builder{
                builderResult.hasSignInfo = false
                builderResult.signInfo = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImsignInfoChangedNotify.Builder {
                builderResult = Im.Buddy.ImsignInfoChangedNotify()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImsignInfoChangedNotify.Builder {
                return try Im.Buddy.ImsignInfoChangedNotify.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImsignInfoChangedNotify {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImsignInfoChangedNotify {
                let returnMe:Im.Buddy.ImsignInfoChangedNotify = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImsignInfoChangedNotify) throws -> Im.Buddy.ImsignInfoChangedNotify.Builder {
                if other == Im.Buddy.ImsignInfoChangedNotify() {
                    return self
                }
                if other.hasChangedUserId {
                    changedUserId = other.changedUserId
                }
                if other.hasSignInfo {
                    signInfo = other.signInfo
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImsignInfoChangedNotify.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImsignInfoChangedNotify.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        changedUserId = try codedInputStream.readUInt32()

                    case 18:
                        signInfo = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImsignInfoChangedNotify.Builder {
                let resultDecodedBuilder = Im.Buddy.ImsignInfoChangedNotify.Builder()
                if let jsonValueChangedUserId = jsonMap["changedUserId"] as? UInt {
                    resultDecodedBuilder.changedUserId = UInt32(jsonValueChangedUserId)
                } else if let jsonValueChangedUserId = jsonMap["changedUserId"] as? String {
                    resultDecodedBuilder.changedUserId = UInt32(jsonValueChangedUserId)!
                }
                if let jsonValueSignInfo = jsonMap["signInfo"] as? String {
                    resultDecodedBuilder.signInfo = jsonValueSignInfo
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImsignInfoChangedNotify.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImsignInfoChangedNotify.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfriendListRequest : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImfriendListRequest.Builder

        public static func == (lhs: Im.Buddy.ImfriendListRequest, rhs: Im.Buddy.ImfriendListRequest) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasLatestUpdateTime == rhs.hasLatestUpdateTime) && (!lhs.hasLatestUpdateTime || lhs.latestUpdateTime == rhs.latestUpdateTime)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0216
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var latestUpdateTime:UInt32! = nil
        public fileprivate(set) var hasLatestUpdateTime:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasLatestUpdateTime {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasLatestUpdateTime {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:latestUpdateTime)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasLatestUpdateTime {
                serialize_size += latestUpdateTime.computeUInt32Size(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImfriendListRequest.Builder {
            return Im.Buddy.ImfriendListRequest.classBuilder() as! Im.Buddy.ImfriendListRequest.Builder
        }
        public func getBuilder() -> Im.Buddy.ImfriendListRequest.Builder {
            return classBuilder() as! Im.Buddy.ImfriendListRequest.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImfriendListRequest.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImfriendListRequest.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImfriendListRequest.Builder {
            return try Im.Buddy.ImfriendListRequest.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImfriendListRequest) throws -> Im.Buddy.ImfriendListRequest.Builder {
            return try Im.Buddy.ImfriendListRequest.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasLatestUpdateTime {
                jsonMap["latestUpdateTime"] = UInt(latestUpdateTime)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImfriendListRequest {
            return try Im.Buddy.ImfriendListRequest.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImfriendListRequest {
            return try Im.Buddy.ImfriendListRequest.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasLatestUpdateTime {
                output += "\(indent) latestUpdateTime: \(latestUpdateTime) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasLatestUpdateTime {
                    hashCode = (hashCode &* 31) &+ latestUpdateTime.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImfriendListRequest"
        }
        override public func className() -> String {
            return "Im.Buddy.ImfriendListRequest"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImfriendListRequest = Im.Buddy.ImfriendListRequest()
            public func getMessage() -> Im.Buddy.ImfriendListRequest {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0216
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImfriendListRequest.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImfriendListRequest.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var latestUpdateTime:UInt32 {
                get {
                    return builderResult.latestUpdateTime
                }
                set (value) {
                    builderResult.hasLatestUpdateTime = true
                    builderResult.latestUpdateTime = value
                }
            }
            public var hasLatestUpdateTime:Bool {
                get {
                    return builderResult.hasLatestUpdateTime
                }
            }
            @discardableResult
            public func setLatestUpdateTime(_ value:UInt32) -> Im.Buddy.ImfriendListRequest.Builder {
                self.latestUpdateTime = value
                return self
            }
            @discardableResult
            public func clearLatestUpdateTime() -> Im.Buddy.ImfriendListRequest.Builder{
                builderResult.hasLatestUpdateTime = false
                builderResult.latestUpdateTime = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImfriendListRequest.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImfriendListRequest.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImfriendListRequest.Builder {
                builderResult = Im.Buddy.ImfriendListRequest()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImfriendListRequest.Builder {
                return try Im.Buddy.ImfriendListRequest.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImfriendListRequest {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImfriendListRequest {
                let returnMe:Im.Buddy.ImfriendListRequest = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImfriendListRequest) throws -> Im.Buddy.ImfriendListRequest.Builder {
                if other == Im.Buddy.ImfriendListRequest() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasLatestUpdateTime {
                    latestUpdateTime = other.latestUpdateTime
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImfriendListRequest.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImfriendListRequest.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        latestUpdateTime = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImfriendListRequest.Builder {
                let resultDecodedBuilder = Im.Buddy.ImfriendListRequest.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? UInt {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)
                } else if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? String {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImfriendListRequest.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImfriendListRequest.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfriendListResponse : GeneratedMessage {
        public typealias BuilderType = Im.Buddy.ImfriendListResponse.Builder

        public static func == (lhs: Im.Buddy.ImfriendListResponse, rhs: Im.Buddy.ImfriendListResponse) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasLatestUpdateTime == rhs.hasLatestUpdateTime) && (!lhs.hasLatestUpdateTime || lhs.latestUpdateTime == rhs.latestUpdateTime)
            fieldCheck = fieldCheck && (lhs.userInfoList == rhs.userInfoList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:    0x0217
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var latestUpdateTime:UInt32! = nil
        public fileprivate(set) var hasLatestUpdateTime:Bool = false

        public fileprivate(set) var userInfoList:Array<Im.BaseDefine.UserInfo>  = Array<Im.BaseDefine.UserInfo>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasLatestUpdateTime {
                return false
            }
            var isInitUserInfoList:Bool = true
            for oneElementUserInfoList in userInfoList {
                if !oneElementUserInfoList.isInitialized() {
                    isInitUserInfoList = false
                    break 
                }
            }
            if !isInitUserInfoList {
                return isInitUserInfoList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasLatestUpdateTime {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:latestUpdateTime)
            }
            for oneElementUserInfoList in userInfoList {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementUserInfoList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasLatestUpdateTime {
                serialize_size += latestUpdateTime.computeUInt32Size(fieldNumber: 2)
            }
            for oneElementUserInfoList in userInfoList {
                serialize_size += oneElementUserInfoList.computeMessageSize(fieldNumber: 3)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Buddy.ImfriendListResponse.Builder {
            return Im.Buddy.ImfriendListResponse.classBuilder() as! Im.Buddy.ImfriendListResponse.Builder
        }
        public func getBuilder() -> Im.Buddy.ImfriendListResponse.Builder {
            return classBuilder() as! Im.Buddy.ImfriendListResponse.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImfriendListResponse.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Buddy.ImfriendListResponse.Builder()
        }
        public func toBuilder() throws -> Im.Buddy.ImfriendListResponse.Builder {
            return try Im.Buddy.ImfriendListResponse.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Buddy.ImfriendListResponse) throws -> Im.Buddy.ImfriendListResponse.Builder {
            return try Im.Buddy.ImfriendListResponse.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasLatestUpdateTime {
                jsonMap["latestUpdateTime"] = UInt(latestUpdateTime)
            }
            if !userInfoList.isEmpty {
                var jsonArrayUserInfoList:Array<Dictionary<String,Any>> = []
                for oneValueUserInfoList in userInfoList {
                    let ecodedMessageUserInfoList = try oneValueUserInfoList.encode()
                    jsonArrayUserInfoList.append(ecodedMessageUserInfoList)
                }
                jsonMap["userInfoList"] = jsonArrayUserInfoList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImfriendListResponse {
            return try Im.Buddy.ImfriendListResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Buddy.ImfriendListResponse {
            return try Im.Buddy.ImfriendListResponse.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasLatestUpdateTime {
                output += "\(indent) latestUpdateTime: \(latestUpdateTime) \n"
            }
            var userInfoListElementIndex:Int = 0
            for oneElementUserInfoList in userInfoList {
                output += "\(indent) userInfoList[\(userInfoListElementIndex)] {\n"
                output += try oneElementUserInfoList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                userInfoListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasLatestUpdateTime {
                    hashCode = (hashCode &* 31) &+ latestUpdateTime.hashValue
                }
                for oneElementUserInfoList in userInfoList {
                    hashCode = (hashCode &* 31) &+ oneElementUserInfoList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Buddy.ImfriendListResponse"
        }
        override public func className() -> String {
            return "Im.Buddy.ImfriendListResponse"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Buddy.ImfriendListResponse = Im.Buddy.ImfriendListResponse()
            public func getMessage() -> Im.Buddy.ImfriendListResponse {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:    0x0217
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Buddy.ImfriendListResponse.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Buddy.ImfriendListResponse.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var latestUpdateTime:UInt32 {
                get {
                    return builderResult.latestUpdateTime
                }
                set (value) {
                    builderResult.hasLatestUpdateTime = true
                    builderResult.latestUpdateTime = value
                }
            }
            public var hasLatestUpdateTime:Bool {
                get {
                    return builderResult.hasLatestUpdateTime
                }
            }
            @discardableResult
            public func setLatestUpdateTime(_ value:UInt32) -> Im.Buddy.ImfriendListResponse.Builder {
                self.latestUpdateTime = value
                return self
            }
            @discardableResult
            public func clearLatestUpdateTime() -> Im.Buddy.ImfriendListResponse.Builder{
                builderResult.hasLatestUpdateTime = false
                builderResult.latestUpdateTime = nil
                return self
            }
            public var userInfoList:Array<Im.BaseDefine.UserInfo> {
                get {
                    return builderResult.userInfoList
                }
                set (value) {
                    builderResult.userInfoList = value
                }
            }
            @discardableResult
            public func setUserInfoList(_ value:Array<Im.BaseDefine.UserInfo>) -> Im.Buddy.ImfriendListResponse.Builder {
                self.userInfoList = value
                return self
            }
            @discardableResult
            public func clearUserInfoList() -> Im.Buddy.ImfriendListResponse.Builder {
                builderResult.userInfoList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Buddy.ImfriendListResponse.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Buddy.ImfriendListResponse.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Buddy.ImfriendListResponse.Builder {
                builderResult = Im.Buddy.ImfriendListResponse()
                return self
            }
            override public func clone() throws -> Im.Buddy.ImfriendListResponse.Builder {
                return try Im.Buddy.ImfriendListResponse.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Buddy.ImfriendListResponse {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Buddy.ImfriendListResponse {
                let returnMe:Im.Buddy.ImfriendListResponse = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Buddy.ImfriendListResponse) throws -> Im.Buddy.ImfriendListResponse.Builder {
                if other == Im.Buddy.ImfriendListResponse() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasLatestUpdateTime {
                    latestUpdateTime = other.latestUpdateTime
                }
                if !other.userInfoList.isEmpty  {
                     builderResult.userInfoList += other.userInfoList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImfriendListResponse.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImfriendListResponse.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        latestUpdateTime = try codedInputStream.readUInt32()

                    case 26:
                        let subBuilder = Im.BaseDefine.UserInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        userInfoList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Buddy.ImfriendListResponse.Builder {
                let resultDecodedBuilder = Im.Buddy.ImfriendListResponse.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? UInt {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)
                } else if let jsonValueLatestUpdateTime = jsonMap["latestUpdateTime"] as? String {
                    resultDecodedBuilder.latestUpdateTime = UInt32(jsonValueLatestUpdateTime)!
                }
                if let jsonValueUserInfoList = jsonMap["userInfoList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayUserInfoList:Array<Im.BaseDefine.UserInfo> = []
                    for oneValueUserInfoList in jsonValueUserInfoList {
                        let messageFromStringUserInfoList = try Im.BaseDefine.UserInfo.Builder.decodeToBuilder(jsonMap:oneValueUserInfoList).build()

                        jsonArrayUserInfoList.append(messageFromStringUserInfoList)
                    }
                    resultDecodedBuilder.userInfoList = jsonArrayUserInfoList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Buddy.ImfriendListResponse.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Buddy.ImfriendListResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Im.Buddy.ImrecentContactSessionReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImrecentContactSessionReq> {
        var mergedArray = Array<Im.Buddy.ImrecentContactSessionReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImrecentContactSessionReq? {
        return try Im.Buddy.ImrecentContactSessionReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImrecentContactSessionReq {
        return try Im.Buddy.ImrecentContactSessionReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImrecentContactSessionReq {
        return try Im.Buddy.ImrecentContactSessionReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImrecentContactSessionReq {
        return try Im.Buddy.ImrecentContactSessionReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImrecentContactSessionReq {
        return try Im.Buddy.ImrecentContactSessionReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImrecentContactSessionReq {
        return try Im.Buddy.ImrecentContactSessionReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImrecentContactSessionReq {
        return try Im.Buddy.ImrecentContactSessionReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "latestUpdateTime": return self.latestUpdateTime
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImrecentContactSessionReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImrecentContactSessionReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "latestUpdateTime": return self.latestUpdateTime
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "latestUpdateTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.latestUpdateTime = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImrecentContactSessionRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImrecentContactSessionRsp> {
        var mergedArray = Array<Im.Buddy.ImrecentContactSessionRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImrecentContactSessionRsp? {
        return try Im.Buddy.ImrecentContactSessionRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImrecentContactSessionRsp {
        return try Im.Buddy.ImrecentContactSessionRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImrecentContactSessionRsp {
        return try Im.Buddy.ImrecentContactSessionRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImrecentContactSessionRsp {
        return try Im.Buddy.ImrecentContactSessionRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImrecentContactSessionRsp {
        return try Im.Buddy.ImrecentContactSessionRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImrecentContactSessionRsp {
        return try Im.Buddy.ImrecentContactSessionRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImrecentContactSessionRsp {
        return try Im.Buddy.ImrecentContactSessionRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "contactSessionList": return self.contactSessionList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImrecentContactSessionRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImrecentContactSessionRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "contactSessionList": return self.contactSessionList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "contactSessionList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.ContactSessionInfo> else {
                    return
                }
                self.contactSessionList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImuserStatNotify: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImuserStatNotify> {
        var mergedArray = Array<Im.Buddy.ImuserStatNotify>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImuserStatNotify? {
        return try Im.Buddy.ImuserStatNotify.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImuserStatNotify {
        return try Im.Buddy.ImuserStatNotify.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImuserStatNotify {
        return try Im.Buddy.ImuserStatNotify.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImuserStatNotify {
        return try Im.Buddy.ImuserStatNotify.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImuserStatNotify {
        return try Im.Buddy.ImuserStatNotify.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImuserStatNotify {
        return try Im.Buddy.ImuserStatNotify.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImuserStatNotify {
        return try Im.Buddy.ImuserStatNotify.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userStat": return self.userStat
        default: return nil
        }
    }
}
extension Im.Buddy.ImuserStatNotify.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImuserStatNotify
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userStat": return self.userStat
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userStat":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.UserStat else {
                    return
                }
                self.userStat = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImusersInfoReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImusersInfoReq> {
        var mergedArray = Array<Im.Buddy.ImusersInfoReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImusersInfoReq? {
        return try Im.Buddy.ImusersInfoReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImusersInfoReq {
        return try Im.Buddy.ImusersInfoReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersInfoReq {
        return try Im.Buddy.ImusersInfoReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImusersInfoReq {
        return try Im.Buddy.ImusersInfoReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersInfoReq {
        return try Im.Buddy.ImusersInfoReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImusersInfoReq {
        return try Im.Buddy.ImusersInfoReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersInfoReq {
        return try Im.Buddy.ImusersInfoReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "userIdList": return self.userIdList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImusersInfoReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImusersInfoReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "userIdList": return self.userIdList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "userIdList":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.userIdList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImusersInfoRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImusersInfoRsp> {
        var mergedArray = Array<Im.Buddy.ImusersInfoRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImusersInfoRsp? {
        return try Im.Buddy.ImusersInfoRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImusersInfoRsp {
        return try Im.Buddy.ImusersInfoRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersInfoRsp {
        return try Im.Buddy.ImusersInfoRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImusersInfoRsp {
        return try Im.Buddy.ImusersInfoRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersInfoRsp {
        return try Im.Buddy.ImusersInfoRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImusersInfoRsp {
        return try Im.Buddy.ImusersInfoRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersInfoRsp {
        return try Im.Buddy.ImusersInfoRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "userInfoList": return self.userInfoList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImusersInfoRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImusersInfoRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "userInfoList": return self.userInfoList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "userInfoList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.UserInfo> else {
                    return
                }
                self.userInfoList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImremoveSessionReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImremoveSessionReq> {
        var mergedArray = Array<Im.Buddy.ImremoveSessionReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImremoveSessionReq? {
        return try Im.Buddy.ImremoveSessionReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImremoveSessionReq {
        return try Im.Buddy.ImremoveSessionReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImremoveSessionReq {
        return try Im.Buddy.ImremoveSessionReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImremoveSessionReq {
        return try Im.Buddy.ImremoveSessionReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImremoveSessionReq {
        return try Im.Buddy.ImremoveSessionReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImremoveSessionReq {
        return try Im.Buddy.ImremoveSessionReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImremoveSessionReq {
        return try Im.Buddy.ImremoveSessionReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "sessionType": return self.sessionType
        case "sessionId": return self.sessionId
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImremoveSessionReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImremoveSessionReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "sessionType": return self.sessionType
            case "sessionId": return self.sessionId
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImremoveSessionRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImremoveSessionRsp> {
        var mergedArray = Array<Im.Buddy.ImremoveSessionRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImremoveSessionRsp? {
        return try Im.Buddy.ImremoveSessionRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImremoveSessionRsp {
        return try Im.Buddy.ImremoveSessionRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImremoveSessionRsp {
        return try Im.Buddy.ImremoveSessionRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImremoveSessionRsp {
        return try Im.Buddy.ImremoveSessionRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImremoveSessionRsp {
        return try Im.Buddy.ImremoveSessionRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImremoveSessionRsp {
        return try Im.Buddy.ImremoveSessionRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImremoveSessionRsp {
        return try Im.Buddy.ImremoveSessionRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "resultCode": return self.resultCode
        case "sessionType": return self.sessionType
        case "sessionId": return self.sessionId
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImremoveSessionRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImremoveSessionRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "resultCode": return self.resultCode
            case "sessionType": return self.sessionType
            case "sessionId": return self.sessionId
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImallUserReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImallUserReq> {
        var mergedArray = Array<Im.Buddy.ImallUserReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImallUserReq? {
        return try Im.Buddy.ImallUserReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImallUserReq {
        return try Im.Buddy.ImallUserReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImallUserReq {
        return try Im.Buddy.ImallUserReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImallUserReq {
        return try Im.Buddy.ImallUserReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImallUserReq {
        return try Im.Buddy.ImallUserReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImallUserReq {
        return try Im.Buddy.ImallUserReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImallUserReq {
        return try Im.Buddy.ImallUserReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "latestUpdateTime": return self.latestUpdateTime
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImallUserReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImallUserReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "latestUpdateTime": return self.latestUpdateTime
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "latestUpdateTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.latestUpdateTime = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImallUserRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImallUserRsp> {
        var mergedArray = Array<Im.Buddy.ImallUserRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImallUserRsp? {
        return try Im.Buddy.ImallUserRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImallUserRsp {
        return try Im.Buddy.ImallUserRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImallUserRsp {
        return try Im.Buddy.ImallUserRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImallUserRsp {
        return try Im.Buddy.ImallUserRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImallUserRsp {
        return try Im.Buddy.ImallUserRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImallUserRsp {
        return try Im.Buddy.ImallUserRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImallUserRsp {
        return try Im.Buddy.ImallUserRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "latestUpdateTime": return self.latestUpdateTime
        case "userList": return self.userList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImallUserRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImallUserRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "latestUpdateTime": return self.latestUpdateTime
            case "userList": return self.userList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "latestUpdateTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.latestUpdateTime = newSubscriptValue
            case "userList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.UserInfo> else {
                    return
                }
                self.userList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImusersStatReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImusersStatReq> {
        var mergedArray = Array<Im.Buddy.ImusersStatReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImusersStatReq? {
        return try Im.Buddy.ImusersStatReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImusersStatReq {
        return try Im.Buddy.ImusersStatReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersStatReq {
        return try Im.Buddy.ImusersStatReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImusersStatReq {
        return try Im.Buddy.ImusersStatReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersStatReq {
        return try Im.Buddy.ImusersStatReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImusersStatReq {
        return try Im.Buddy.ImusersStatReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersStatReq {
        return try Im.Buddy.ImusersStatReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "userIdList": return self.userIdList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImusersStatReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImusersStatReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "userIdList": return self.userIdList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "userIdList":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.userIdList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImusersStatRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImusersStatRsp> {
        var mergedArray = Array<Im.Buddy.ImusersStatRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImusersStatRsp? {
        return try Im.Buddy.ImusersStatRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImusersStatRsp {
        return try Im.Buddy.ImusersStatRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersStatRsp {
        return try Im.Buddy.ImusersStatRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImusersStatRsp {
        return try Im.Buddy.ImusersStatRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersStatRsp {
        return try Im.Buddy.ImusersStatRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImusersStatRsp {
        return try Im.Buddy.ImusersStatRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImusersStatRsp {
        return try Im.Buddy.ImusersStatRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "userStatList": return self.userStatList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImusersStatRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImusersStatRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "userStatList": return self.userStatList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "userStatList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.UserStat> else {
                    return
                }
                self.userStatList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImchangeAvatarReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImchangeAvatarReq> {
        var mergedArray = Array<Im.Buddy.ImchangeAvatarReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImchangeAvatarReq? {
        return try Im.Buddy.ImchangeAvatarReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImchangeAvatarReq {
        return try Im.Buddy.ImchangeAvatarReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeAvatarReq {
        return try Im.Buddy.ImchangeAvatarReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImchangeAvatarReq {
        return try Im.Buddy.ImchangeAvatarReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeAvatarReq {
        return try Im.Buddy.ImchangeAvatarReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImchangeAvatarReq {
        return try Im.Buddy.ImchangeAvatarReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeAvatarReq {
        return try Im.Buddy.ImchangeAvatarReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "avatarUrl": return self.avatarUrl
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImchangeAvatarReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImchangeAvatarReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "avatarUrl": return self.avatarUrl
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "avatarUrl":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.avatarUrl = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImchangeAvatarRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImchangeAvatarRsp> {
        var mergedArray = Array<Im.Buddy.ImchangeAvatarRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImchangeAvatarRsp? {
        return try Im.Buddy.ImchangeAvatarRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImchangeAvatarRsp {
        return try Im.Buddy.ImchangeAvatarRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeAvatarRsp {
        return try Im.Buddy.ImchangeAvatarRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImchangeAvatarRsp {
        return try Im.Buddy.ImchangeAvatarRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeAvatarRsp {
        return try Im.Buddy.ImchangeAvatarRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImchangeAvatarRsp {
        return try Im.Buddy.ImchangeAvatarRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeAvatarRsp {
        return try Im.Buddy.ImchangeAvatarRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "resultCode": return self.resultCode
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImchangeAvatarRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImchangeAvatarRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "resultCode": return self.resultCode
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImpcloginStatusNotify: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImpcloginStatusNotify> {
        var mergedArray = Array<Im.Buddy.ImpcloginStatusNotify>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImpcloginStatusNotify? {
        return try Im.Buddy.ImpcloginStatusNotify.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImpcloginStatusNotify {
        return try Im.Buddy.ImpcloginStatusNotify.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImpcloginStatusNotify {
        return try Im.Buddy.ImpcloginStatusNotify.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImpcloginStatusNotify {
        return try Im.Buddy.ImpcloginStatusNotify.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImpcloginStatusNotify {
        return try Im.Buddy.ImpcloginStatusNotify.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImpcloginStatusNotify {
        return try Im.Buddy.ImpcloginStatusNotify.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImpcloginStatusNotify {
        return try Im.Buddy.ImpcloginStatusNotify.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "loginStat": return self.loginStat
        default: return nil
        }
    }
}
extension Im.Buddy.ImpcloginStatusNotify.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImpcloginStatusNotify
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "loginStat": return self.loginStat
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "loginStat":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.UserStatType else {
                    return
                }
                self.loginStat = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImremoveSessionNotify: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImremoveSessionNotify> {
        var mergedArray = Array<Im.Buddy.ImremoveSessionNotify>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImremoveSessionNotify? {
        return try Im.Buddy.ImremoveSessionNotify.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImremoveSessionNotify {
        return try Im.Buddy.ImremoveSessionNotify.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImremoveSessionNotify {
        return try Im.Buddy.ImremoveSessionNotify.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImremoveSessionNotify {
        return try Im.Buddy.ImremoveSessionNotify.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImremoveSessionNotify {
        return try Im.Buddy.ImremoveSessionNotify.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImremoveSessionNotify {
        return try Im.Buddy.ImremoveSessionNotify.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImremoveSessionNotify {
        return try Im.Buddy.ImremoveSessionNotify.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "sessionType": return self.sessionType
        case "sessionId": return self.sessionId
        default: return nil
        }
    }
}
extension Im.Buddy.ImremoveSessionNotify.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImremoveSessionNotify
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "sessionType": return self.sessionType
            case "sessionId": return self.sessionId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImdepartmentReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImdepartmentReq> {
        var mergedArray = Array<Im.Buddy.ImdepartmentReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImdepartmentReq? {
        return try Im.Buddy.ImdepartmentReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImdepartmentReq {
        return try Im.Buddy.ImdepartmentReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImdepartmentReq {
        return try Im.Buddy.ImdepartmentReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImdepartmentReq {
        return try Im.Buddy.ImdepartmentReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImdepartmentReq {
        return try Im.Buddy.ImdepartmentReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImdepartmentReq {
        return try Im.Buddy.ImdepartmentReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImdepartmentReq {
        return try Im.Buddy.ImdepartmentReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "latestUpdateTime": return self.latestUpdateTime
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImdepartmentReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImdepartmentReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "latestUpdateTime": return self.latestUpdateTime
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "latestUpdateTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.latestUpdateTime = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImdepartmentRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImdepartmentRsp> {
        var mergedArray = Array<Im.Buddy.ImdepartmentRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImdepartmentRsp? {
        return try Im.Buddy.ImdepartmentRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImdepartmentRsp {
        return try Im.Buddy.ImdepartmentRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImdepartmentRsp {
        return try Im.Buddy.ImdepartmentRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImdepartmentRsp {
        return try Im.Buddy.ImdepartmentRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImdepartmentRsp {
        return try Im.Buddy.ImdepartmentRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImdepartmentRsp {
        return try Im.Buddy.ImdepartmentRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImdepartmentRsp {
        return try Im.Buddy.ImdepartmentRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "latestUpdateTime": return self.latestUpdateTime
        case "deptList": return self.deptList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImdepartmentRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImdepartmentRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "latestUpdateTime": return self.latestUpdateTime
            case "deptList": return self.deptList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "latestUpdateTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.latestUpdateTime = newSubscriptValue
            case "deptList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.DepartInfo> else {
                    return
                }
                self.deptList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImavatarChangedNotify: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImavatarChangedNotify> {
        var mergedArray = Array<Im.Buddy.ImavatarChangedNotify>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImavatarChangedNotify? {
        return try Im.Buddy.ImavatarChangedNotify.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImavatarChangedNotify {
        return try Im.Buddy.ImavatarChangedNotify.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImavatarChangedNotify {
        return try Im.Buddy.ImavatarChangedNotify.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImavatarChangedNotify {
        return try Im.Buddy.ImavatarChangedNotify.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImavatarChangedNotify {
        return try Im.Buddy.ImavatarChangedNotify.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImavatarChangedNotify {
        return try Im.Buddy.ImavatarChangedNotify.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImavatarChangedNotify {
        return try Im.Buddy.ImavatarChangedNotify.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "changedUserId": return self.changedUserId
        case "avatarUrl": return self.avatarUrl
        default: return nil
        }
    }
}
extension Im.Buddy.ImavatarChangedNotify.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImavatarChangedNotify
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "changedUserId": return self.changedUserId
            case "avatarUrl": return self.avatarUrl
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "changedUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.changedUserId = newSubscriptValue
            case "avatarUrl":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.avatarUrl = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImchangeSignInfoReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImchangeSignInfoReq> {
        var mergedArray = Array<Im.Buddy.ImchangeSignInfoReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImchangeSignInfoReq? {
        return try Im.Buddy.ImchangeSignInfoReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImchangeSignInfoReq {
        return try Im.Buddy.ImchangeSignInfoReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeSignInfoReq {
        return try Im.Buddy.ImchangeSignInfoReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImchangeSignInfoReq {
        return try Im.Buddy.ImchangeSignInfoReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeSignInfoReq {
        return try Im.Buddy.ImchangeSignInfoReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImchangeSignInfoReq {
        return try Im.Buddy.ImchangeSignInfoReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeSignInfoReq {
        return try Im.Buddy.ImchangeSignInfoReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "signInfo": return self.signInfo
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImchangeSignInfoReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImchangeSignInfoReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "signInfo": return self.signInfo
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "signInfo":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.signInfo = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImchangeSignInfoRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImchangeSignInfoRsp> {
        var mergedArray = Array<Im.Buddy.ImchangeSignInfoRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImchangeSignInfoRsp? {
        return try Im.Buddy.ImchangeSignInfoRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImchangeSignInfoRsp {
        return try Im.Buddy.ImchangeSignInfoRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeSignInfoRsp {
        return try Im.Buddy.ImchangeSignInfoRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImchangeSignInfoRsp {
        return try Im.Buddy.ImchangeSignInfoRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeSignInfoRsp {
        return try Im.Buddy.ImchangeSignInfoRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImchangeSignInfoRsp {
        return try Im.Buddy.ImchangeSignInfoRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImchangeSignInfoRsp {
        return try Im.Buddy.ImchangeSignInfoRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "resultCode": return self.resultCode
        case "signInfo": return self.signInfo
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImchangeSignInfoRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImchangeSignInfoRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "resultCode": return self.resultCode
            case "signInfo": return self.signInfo
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "signInfo":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.signInfo = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImsignInfoChangedNotify: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImsignInfoChangedNotify> {
        var mergedArray = Array<Im.Buddy.ImsignInfoChangedNotify>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImsignInfoChangedNotify? {
        return try Im.Buddy.ImsignInfoChangedNotify.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImsignInfoChangedNotify {
        return try Im.Buddy.ImsignInfoChangedNotify.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImsignInfoChangedNotify {
        return try Im.Buddy.ImsignInfoChangedNotify.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImsignInfoChangedNotify {
        return try Im.Buddy.ImsignInfoChangedNotify.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImsignInfoChangedNotify {
        return try Im.Buddy.ImsignInfoChangedNotify.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImsignInfoChangedNotify {
        return try Im.Buddy.ImsignInfoChangedNotify.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImsignInfoChangedNotify {
        return try Im.Buddy.ImsignInfoChangedNotify.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "changedUserId": return self.changedUserId
        case "signInfo": return self.signInfo
        default: return nil
        }
    }
}
extension Im.Buddy.ImsignInfoChangedNotify.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImsignInfoChangedNotify
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "changedUserId": return self.changedUserId
            case "signInfo": return self.signInfo
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "changedUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.changedUserId = newSubscriptValue
            case "signInfo":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.signInfo = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImfriendListRequest: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImfriendListRequest> {
        var mergedArray = Array<Im.Buddy.ImfriendListRequest>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImfriendListRequest? {
        return try Im.Buddy.ImfriendListRequest.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImfriendListRequest {
        return try Im.Buddy.ImfriendListRequest.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImfriendListRequest {
        return try Im.Buddy.ImfriendListRequest.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImfriendListRequest {
        return try Im.Buddy.ImfriendListRequest.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImfriendListRequest {
        return try Im.Buddy.ImfriendListRequest.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImfriendListRequest {
        return try Im.Buddy.ImfriendListRequest.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImfriendListRequest {
        return try Im.Buddy.ImfriendListRequest.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "latestUpdateTime": return self.latestUpdateTime
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImfriendListRequest.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImfriendListRequest
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "latestUpdateTime": return self.latestUpdateTime
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "latestUpdateTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.latestUpdateTime = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Buddy.ImfriendListResponse: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Buddy.ImfriendListResponse> {
        var mergedArray = Array<Im.Buddy.ImfriendListResponse>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Buddy.ImfriendListResponse? {
        return try Im.Buddy.ImfriendListResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Buddy.ImfriendListResponse {
        return try Im.Buddy.ImfriendListResponse.Builder().mergeFrom(data: data, extensionRegistry:Im.Buddy.ImbuddyRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImfriendListResponse {
        return try Im.Buddy.ImfriendListResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Buddy.ImfriendListResponse {
        return try Im.Buddy.ImfriendListResponse.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImfriendListResponse {
        return try Im.Buddy.ImfriendListResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Buddy.ImfriendListResponse {
        return try Im.Buddy.ImfriendListResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Buddy.ImfriendListResponse {
        return try Im.Buddy.ImfriendListResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "latestUpdateTime": return self.latestUpdateTime
        case "userInfoList": return self.userInfoList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Buddy.ImfriendListResponse.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Buddy.ImfriendListResponse
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "latestUpdateTime": return self.latestUpdateTime
            case "userInfoList": return self.userInfoList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "latestUpdateTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.latestUpdateTime = newSubscriptValue
            case "userInfoList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.UserInfo> else {
                    return
                }
                self.userInfoList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
