/// Generated by the Protocol Buffers 3.3.2 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "IM.Login.proto"
/// Syntax "Proto2"

import Foundation

public extension Im {
    public struct Login {}
}

public extension Im.Login {
    public struct ImloginRoot {
        public static let `default` = ImloginRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Im.BaseDefine.ImbaseDefineRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    ///cmd id:		0x0101
    final public class ImmsgServReq : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImmsgServReq.Builder

        public static func == (lhs: Im.Login.ImmsgServReq, rhs: Im.Login.ImmsgServReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImmsgServReq.Builder {
            return Im.Login.ImmsgServReq.classBuilder() as! Im.Login.ImmsgServReq.Builder
        }
        public func getBuilder() -> Im.Login.ImmsgServReq.Builder {
            return classBuilder() as! Im.Login.ImmsgServReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImmsgServReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImmsgServReq.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImmsgServReq.Builder {
            return try Im.Login.ImmsgServReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImmsgServReq) throws -> Im.Login.ImmsgServReq.Builder {
            return try Im.Login.ImmsgServReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImmsgServReq {
            return try Im.Login.ImmsgServReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImmsgServReq {
            return try Im.Login.ImmsgServReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImmsgServReq"
        }
        override public func className() -> String {
            return "Im.Login.ImmsgServReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImmsgServReq = Im.Login.ImmsgServReq()
            public func getMessage() -> Im.Login.ImmsgServReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImmsgServReq.Builder {
                builderResult = Im.Login.ImmsgServReq()
                return self
            }
            override public func clone() throws -> Im.Login.ImmsgServReq.Builder {
                return try Im.Login.ImmsgServReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImmsgServReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImmsgServReq {
                let returnMe:Im.Login.ImmsgServReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImmsgServReq) throws -> Im.Login.ImmsgServReq.Builder {
                if other == Im.Login.ImmsgServReq() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImmsgServReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmsgServReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImmsgServReq.Builder {
                let resultDecodedBuilder = Im.Login.ImmsgServReq.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImmsgServReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImmsgServReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImmsgServRsp : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImmsgServRsp.Builder

        public static func == (lhs: Im.Login.ImmsgServRsp, rhs: Im.Login.ImmsgServRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasPriorIp == rhs.hasPriorIp) && (!lhs.hasPriorIp || lhs.priorIp == rhs.priorIp)
            fieldCheck = fieldCheck && (lhs.hasBackipIp == rhs.hasBackipIp) && (!lhs.hasBackipIp || lhs.backipIp == rhs.backipIp)
            fieldCheck = fieldCheck && (lhs.hasPort == rhs.hasPort) && (!lhs.hasPort || lhs.port == rhs.port)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var resultCode:Im.BaseDefine.ResultType = Im.BaseDefine.ResultType.refuseReasonNone
        public fileprivate(set) var hasResultCode:Bool = false
        public fileprivate(set) var priorIp:String! = nil
        public fileprivate(set) var hasPriorIp:Bool = false

        public fileprivate(set) var backipIp:String! = nil
        public fileprivate(set) var hasBackipIp:Bool = false

        public fileprivate(set) var port:UInt32! = nil
        public fileprivate(set) var hasPort:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasResultCode {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasResultCode {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:resultCode.rawValue)
            }
            if hasPriorIp {
                try codedOutputStream.writeString(fieldNumber: 2, value:priorIp)
            }
            if hasBackipIp {
                try codedOutputStream.writeString(fieldNumber: 3, value:backipIp)
            }
            if hasPort {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:port)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasResultCode) {
                serialize_size += resultCode.rawValue.computeEnumSize(fieldNumber: 1)
            }
            if hasPriorIp {
                serialize_size += priorIp.computeStringSize(fieldNumber: 2)
            }
            if hasBackipIp {
                serialize_size += backipIp.computeStringSize(fieldNumber: 3)
            }
            if hasPort {
                serialize_size += port.computeUInt32Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImmsgServRsp.Builder {
            return Im.Login.ImmsgServRsp.classBuilder() as! Im.Login.ImmsgServRsp.Builder
        }
        public func getBuilder() -> Im.Login.ImmsgServRsp.Builder {
            return classBuilder() as! Im.Login.ImmsgServRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImmsgServRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImmsgServRsp.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImmsgServRsp.Builder {
            return try Im.Login.ImmsgServRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImmsgServRsp) throws -> Im.Login.ImmsgServRsp.Builder {
            return try Im.Login.ImmsgServRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasResultCode {
                jsonMap["resultCode"] = resultCode.toString()
            }
            if hasPriorIp {
                jsonMap["priorIp"] = priorIp
            }
            if hasBackipIp {
                jsonMap["backipIp"] = backipIp
            }
            if hasPort {
                jsonMap["port"] = UInt(port)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImmsgServRsp {
            return try Im.Login.ImmsgServRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImmsgServRsp {
            return try Im.Login.ImmsgServRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasResultCode) {
                output += "\(indent) resultCode: \(resultCode.description)\n"
            }
            if hasPriorIp {
                output += "\(indent) priorIp: \(priorIp) \n"
            }
            if hasBackipIp {
                output += "\(indent) backipIp: \(backipIp) \n"
            }
            if hasPort {
                output += "\(indent) port: \(port) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasResultCode {
                     hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasPriorIp {
                    hashCode = (hashCode &* 31) &+ priorIp.hashValue
                }
                if hasBackipIp {
                    hashCode = (hashCode &* 31) &+ backipIp.hashValue
                }
                if hasPort {
                    hashCode = (hashCode &* 31) &+ port.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImmsgServRsp"
        }
        override public func className() -> String {
            return "Im.Login.ImmsgServRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImmsgServRsp = Im.Login.ImmsgServRsp()
            public func getMessage() -> Im.Login.ImmsgServRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0102
                public var resultCode:Im.BaseDefine.ResultType {
                    get {
                        return builderResult.resultCode
                    }
                    set (value) {
                        builderResult.hasResultCode = true
                        builderResult.resultCode = value
                    }
                }
                public var hasResultCode:Bool{
                    get {
                        return builderResult.hasResultCode
                    }
                }
            @discardableResult
                public func setResultCode(_ value:Im.BaseDefine.ResultType) -> Im.Login.ImmsgServRsp.Builder {
                  self.resultCode = value
                  return self
                }
            @discardableResult
                public func clearResultCode() -> Im.Login.ImmsgServRsp.Builder {
                   builderResult.hasResultCode = false
                   builderResult.resultCode = .refuseReasonNone
                   return self
                }
            public var priorIp:String {
                get {
                    return builderResult.priorIp
                }
                set (value) {
                    builderResult.hasPriorIp = true
                    builderResult.priorIp = value
                }
            }
            public var hasPriorIp:Bool {
                get {
                    return builderResult.hasPriorIp
                }
            }
            @discardableResult
            public func setPriorIp(_ value:String) -> Im.Login.ImmsgServRsp.Builder {
                self.priorIp = value
                return self
            }
            @discardableResult
            public func clearPriorIp() -> Im.Login.ImmsgServRsp.Builder{
                builderResult.hasPriorIp = false
                builderResult.priorIp = nil
                return self
            }
            public var backipIp:String {
                get {
                    return builderResult.backipIp
                }
                set (value) {
                    builderResult.hasBackipIp = true
                    builderResult.backipIp = value
                }
            }
            public var hasBackipIp:Bool {
                get {
                    return builderResult.hasBackipIp
                }
            }
            @discardableResult
            public func setBackipIp(_ value:String) -> Im.Login.ImmsgServRsp.Builder {
                self.backipIp = value
                return self
            }
            @discardableResult
            public func clearBackipIp() -> Im.Login.ImmsgServRsp.Builder{
                builderResult.hasBackipIp = false
                builderResult.backipIp = nil
                return self
            }
            public var port:UInt32 {
                get {
                    return builderResult.port
                }
                set (value) {
                    builderResult.hasPort = true
                    builderResult.port = value
                }
            }
            public var hasPort:Bool {
                get {
                    return builderResult.hasPort
                }
            }
            @discardableResult
            public func setPort(_ value:UInt32) -> Im.Login.ImmsgServRsp.Builder {
                self.port = value
                return self
            }
            @discardableResult
            public func clearPort() -> Im.Login.ImmsgServRsp.Builder{
                builderResult.hasPort = false
                builderResult.port = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImmsgServRsp.Builder {
                builderResult = Im.Login.ImmsgServRsp()
                return self
            }
            override public func clone() throws -> Im.Login.ImmsgServRsp.Builder {
                return try Im.Login.ImmsgServRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImmsgServRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImmsgServRsp {
                let returnMe:Im.Login.ImmsgServRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImmsgServRsp) throws -> Im.Login.ImmsgServRsp.Builder {
                if other == Im.Login.ImmsgServRsp() {
                    return self
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasPriorIp {
                    priorIp = other.priorIp
                }
                if other.hasBackipIp {
                    backipIp = other.backipIp
                }
                if other.hasPort {
                    port = other.port
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImmsgServRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmsgServRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueIntresultCode = try codedInputStream.readEnum()
                        if let enumsresultCode = Im.BaseDefine.ResultType(rawValue:valueIntresultCode){
                            resultCode = enumsresultCode
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresultCode))
                        }

                    case 18:
                        priorIp = try codedInputStream.readString()

                    case 26:
                        backipIp = try codedInputStream.readString()

                    case 32:
                        port = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImmsgServRsp.Builder {
                let resultDecodedBuilder = Im.Login.ImmsgServRsp.Builder()
                if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = try Im.BaseDefine.ResultType.fromString(jsonValueResultCode)
                }
                if let jsonValuePriorIp = jsonMap["priorIp"] as? String {
                    resultDecodedBuilder.priorIp = jsonValuePriorIp
                }
                if let jsonValueBackipIp = jsonMap["backipIp"] as? String {
                    resultDecodedBuilder.backipIp = jsonValueBackipIp
                }
                if let jsonValuePort = jsonMap["port"] as? UInt {
                    resultDecodedBuilder.port = UInt32(jsonValuePort)
                } else if let jsonValuePort = jsonMap["port"] as? String {
                    resultDecodedBuilder.port = UInt32(jsonValuePort)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImmsgServRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImmsgServRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImloginReq : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImloginReq.Builder

        public static func == (lhs: Im.Login.ImloginReq, rhs: Im.Login.ImloginReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserName == rhs.hasUserName) && (!lhs.hasUserName || lhs.userName == rhs.userName)
            fieldCheck = fieldCheck && (lhs.hasPassword == rhs.hasPassword) && (!lhs.hasPassword || lhs.password == rhs.password)
            fieldCheck = fieldCheck && (lhs.hasOnlineStatus == rhs.hasOnlineStatus) && (!lhs.hasOnlineStatus || lhs.onlineStatus == rhs.onlineStatus)
            fieldCheck = fieldCheck && (lhs.hasClientType == rhs.hasClientType) && (!lhs.hasClientType || lhs.clientType == rhs.clientType)
            fieldCheck = fieldCheck && (lhs.hasClientVersion == rhs.hasClientVersion) && (!lhs.hasClientVersion || lhs.clientVersion == rhs.clientVersion)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x0103
        public fileprivate(set) var userName:String! = nil
        public fileprivate(set) var hasUserName:Bool = false

        public fileprivate(set) var password:String! = nil
        public fileprivate(set) var hasPassword:Bool = false

        public fileprivate(set) var onlineStatus:Im.BaseDefine.UserStatType = Im.BaseDefine.UserStatType.userStatusOnline
        public fileprivate(set) var hasOnlineStatus:Bool = false
        public fileprivate(set) var clientType:Im.BaseDefine.ClientType = Im.BaseDefine.ClientType.clientTypeWindows
        public fileprivate(set) var hasClientType:Bool = false
        public fileprivate(set) var clientVersion:String! = nil
        public fileprivate(set) var hasClientVersion:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserName {
                return false
            }
            if !hasPassword {
                return false
            }
            if !hasOnlineStatus {
                return false
            }
            if !hasClientType {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserName {
                try codedOutputStream.writeString(fieldNumber: 1, value:userName)
            }
            if hasPassword {
                try codedOutputStream.writeString(fieldNumber: 2, value:password)
            }
            if hasOnlineStatus {
                try codedOutputStream.writeEnum(fieldNumber: 3, value:onlineStatus.rawValue)
            }
            if hasClientType {
                try codedOutputStream.writeEnum(fieldNumber: 4, value:clientType.rawValue)
            }
            if hasClientVersion {
                try codedOutputStream.writeString(fieldNumber: 5, value:clientVersion)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserName {
                serialize_size += userName.computeStringSize(fieldNumber: 1)
            }
            if hasPassword {
                serialize_size += password.computeStringSize(fieldNumber: 2)
            }
            if (hasOnlineStatus) {
                serialize_size += onlineStatus.rawValue.computeEnumSize(fieldNumber: 3)
            }
            if (hasClientType) {
                serialize_size += clientType.rawValue.computeEnumSize(fieldNumber: 4)
            }
            if hasClientVersion {
                serialize_size += clientVersion.computeStringSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImloginReq.Builder {
            return Im.Login.ImloginReq.classBuilder() as! Im.Login.ImloginReq.Builder
        }
        public func getBuilder() -> Im.Login.ImloginReq.Builder {
            return classBuilder() as! Im.Login.ImloginReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImloginReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImloginReq.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImloginReq.Builder {
            return try Im.Login.ImloginReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImloginReq) throws -> Im.Login.ImloginReq.Builder {
            return try Im.Login.ImloginReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserName {
                jsonMap["userName"] = userName
            }
            if hasPassword {
                jsonMap["password"] = password
            }
            if hasOnlineStatus {
                jsonMap["onlineStatus"] = onlineStatus.toString()
            }
            if hasClientType {
                jsonMap["clientType"] = clientType.toString()
            }
            if hasClientVersion {
                jsonMap["clientVersion"] = clientVersion
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImloginReq {
            return try Im.Login.ImloginReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImloginReq {
            return try Im.Login.ImloginReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserName {
                output += "\(indent) userName: \(userName) \n"
            }
            if hasPassword {
                output += "\(indent) password: \(password) \n"
            }
            if (hasOnlineStatus) {
                output += "\(indent) onlineStatus: \(onlineStatus.description)\n"
            }
            if (hasClientType) {
                output += "\(indent) clientType: \(clientType.description)\n"
            }
            if hasClientVersion {
                output += "\(indent) clientVersion: \(clientVersion) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserName {
                    hashCode = (hashCode &* 31) &+ userName.hashValue
                }
                if hasPassword {
                    hashCode = (hashCode &* 31) &+ password.hashValue
                }
                if hasOnlineStatus {
                     hashCode = (hashCode &* 31) &+ onlineStatus.hashValue
                }
                if hasClientType {
                     hashCode = (hashCode &* 31) &+ clientType.hashValue
                }
                if hasClientVersion {
                    hashCode = (hashCode &* 31) &+ clientVersion.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImloginReq"
        }
        override public func className() -> String {
            return "Im.Login.ImloginReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImloginReq = Im.Login.ImloginReq()
            public func getMessage() -> Im.Login.ImloginReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0103
            public var userName:String {
                get {
                    return builderResult.userName
                }
                set (value) {
                    builderResult.hasUserName = true
                    builderResult.userName = value
                }
            }
            public var hasUserName:Bool {
                get {
                    return builderResult.hasUserName
                }
            }
            @discardableResult
            public func setUserName(_ value:String) -> Im.Login.ImloginReq.Builder {
                self.userName = value
                return self
            }
            @discardableResult
            public func clearUserName() -> Im.Login.ImloginReq.Builder{
                builderResult.hasUserName = false
                builderResult.userName = nil
                return self
            }
            public var password:String {
                get {
                    return builderResult.password
                }
                set (value) {
                    builderResult.hasPassword = true
                    builderResult.password = value
                }
            }
            public var hasPassword:Bool {
                get {
                    return builderResult.hasPassword
                }
            }
            @discardableResult
            public func setPassword(_ value:String) -> Im.Login.ImloginReq.Builder {
                self.password = value
                return self
            }
            @discardableResult
            public func clearPassword() -> Im.Login.ImloginReq.Builder{
                builderResult.hasPassword = false
                builderResult.password = nil
                return self
            }
                public var onlineStatus:Im.BaseDefine.UserStatType {
                    get {
                        return builderResult.onlineStatus
                    }
                    set (value) {
                        builderResult.hasOnlineStatus = true
                        builderResult.onlineStatus = value
                    }
                }
                public var hasOnlineStatus:Bool{
                    get {
                        return builderResult.hasOnlineStatus
                    }
                }
            @discardableResult
                public func setOnlineStatus(_ value:Im.BaseDefine.UserStatType) -> Im.Login.ImloginReq.Builder {
                  self.onlineStatus = value
                  return self
                }
            @discardableResult
                public func clearOnlineStatus() -> Im.Login.ImloginReq.Builder {
                   builderResult.hasOnlineStatus = false
                   builderResult.onlineStatus = .userStatusOnline
                   return self
                }
                public var clientType:Im.BaseDefine.ClientType {
                    get {
                        return builderResult.clientType
                    }
                    set (value) {
                        builderResult.hasClientType = true
                        builderResult.clientType = value
                    }
                }
                public var hasClientType:Bool{
                    get {
                        return builderResult.hasClientType
                    }
                }
            @discardableResult
                public func setClientType(_ value:Im.BaseDefine.ClientType) -> Im.Login.ImloginReq.Builder {
                  self.clientType = value
                  return self
                }
            @discardableResult
                public func clearClientType() -> Im.Login.ImloginReq.Builder {
                   builderResult.hasClientType = false
                   builderResult.clientType = .clientTypeWindows
                   return self
                }
            public var clientVersion:String {
                get {
                    return builderResult.clientVersion
                }
                set (value) {
                    builderResult.hasClientVersion = true
                    builderResult.clientVersion = value
                }
            }
            public var hasClientVersion:Bool {
                get {
                    return builderResult.hasClientVersion
                }
            }
            @discardableResult
            public func setClientVersion(_ value:String) -> Im.Login.ImloginReq.Builder {
                self.clientVersion = value
                return self
            }
            @discardableResult
            public func clearClientVersion() -> Im.Login.ImloginReq.Builder{
                builderResult.hasClientVersion = false
                builderResult.clientVersion = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImloginReq.Builder {
                builderResult = Im.Login.ImloginReq()
                return self
            }
            override public func clone() throws -> Im.Login.ImloginReq.Builder {
                return try Im.Login.ImloginReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImloginReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImloginReq {
                let returnMe:Im.Login.ImloginReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImloginReq) throws -> Im.Login.ImloginReq.Builder {
                if other == Im.Login.ImloginReq() {
                    return self
                }
                if other.hasUserName {
                    userName = other.userName
                }
                if other.hasPassword {
                    password = other.password
                }
                if other.hasOnlineStatus {
                    onlineStatus = other.onlineStatus
                }
                if other.hasClientType {
                    clientType = other.clientType
                }
                if other.hasClientVersion {
                    clientVersion = other.clientVersion
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImloginReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImloginReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        userName = try codedInputStream.readString()

                    case 18:
                        password = try codedInputStream.readString()

                    case 24:
                        let valueIntonlineStatus = try codedInputStream.readEnum()
                        if let enumsonlineStatus = Im.BaseDefine.UserStatType(rawValue:valueIntonlineStatus){
                            onlineStatus = enumsonlineStatus
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntonlineStatus))
                        }

                    case 32:
                        let valueIntclientType = try codedInputStream.readEnum()
                        if let enumsclientType = Im.BaseDefine.ClientType(rawValue:valueIntclientType){
                            clientType = enumsclientType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntclientType))
                        }

                    case 42:
                        clientVersion = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImloginReq.Builder {
                let resultDecodedBuilder = Im.Login.ImloginReq.Builder()
                if let jsonValueUserName = jsonMap["userName"] as? String {
                    resultDecodedBuilder.userName = jsonValueUserName
                }
                if let jsonValuePassword = jsonMap["password"] as? String {
                    resultDecodedBuilder.password = jsonValuePassword
                }
                if let jsonValueOnlineStatus = jsonMap["onlineStatus"] as? String {
                    resultDecodedBuilder.onlineStatus = try Im.BaseDefine.UserStatType.fromString(jsonValueOnlineStatus)
                }
                if let jsonValueClientType = jsonMap["clientType"] as? String {
                    resultDecodedBuilder.clientType = try Im.BaseDefine.ClientType.fromString(jsonValueClientType)
                }
                if let jsonValueClientVersion = jsonMap["clientVersion"] as? String {
                    resultDecodedBuilder.clientVersion = jsonValueClientVersion
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImloginReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImloginReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImloginRes : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImloginRes.Builder

        public static func == (lhs: Im.Login.ImloginRes, rhs: Im.Login.ImloginRes) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasServerTime == rhs.hasServerTime) && (!lhs.hasServerTime || lhs.serverTime == rhs.serverTime)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasResultString == rhs.hasResultString) && (!lhs.hasResultString || lhs.resultString == rhs.resultString)
            fieldCheck = fieldCheck && (lhs.hasOnlineStatus == rhs.hasOnlineStatus) && (!lhs.hasOnlineStatus || lhs.onlineStatus == rhs.onlineStatus)
            fieldCheck = fieldCheck && (lhs.hasUserInfo == rhs.hasUserInfo) && (!lhs.hasUserInfo || lhs.userInfo == rhs.userInfo)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x0104
        public fileprivate(set) var serverTime:UInt32! = nil
        public fileprivate(set) var hasServerTime:Bool = false

        public fileprivate(set) var resultCode:Im.BaseDefine.ResultType = Im.BaseDefine.ResultType.refuseReasonNone
        public fileprivate(set) var hasResultCode:Bool = false
        public fileprivate(set) var resultString:String! = nil
        public fileprivate(set) var hasResultString:Bool = false

        public fileprivate(set) var onlineStatus:Im.BaseDefine.UserStatType = Im.BaseDefine.UserStatType.userStatusOnline
        public fileprivate(set) var hasOnlineStatus:Bool = false
        public fileprivate(set) var userInfo:Im.BaseDefine.UserInfo!
        public fileprivate(set) var hasUserInfo:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasServerTime {
                return false
            }
            if !hasResultCode {
                return false
            }
            if hasUserInfo {
                if !userInfo.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasServerTime {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:serverTime)
            }
            if hasResultCode {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:resultCode.rawValue)
            }
            if hasResultString {
                try codedOutputStream.writeString(fieldNumber: 3, value:resultString)
            }
            if hasOnlineStatus {
                try codedOutputStream.writeEnum(fieldNumber: 4, value:onlineStatus.rawValue)
            }
            if hasUserInfo {
                try codedOutputStream.writeMessage(fieldNumber: 5, value:userInfo)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasServerTime {
                serialize_size += serverTime.computeUInt32Size(fieldNumber: 1)
            }
            if (hasResultCode) {
                serialize_size += resultCode.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasResultString {
                serialize_size += resultString.computeStringSize(fieldNumber: 3)
            }
            if (hasOnlineStatus) {
                serialize_size += onlineStatus.rawValue.computeEnumSize(fieldNumber: 4)
            }
            if hasUserInfo {
                if let varSizeuserInfo = userInfo?.computeMessageSize(fieldNumber: 5) {
                    serialize_size += varSizeuserInfo
                }
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImloginRes.Builder {
            return Im.Login.ImloginRes.classBuilder() as! Im.Login.ImloginRes.Builder
        }
        public func getBuilder() -> Im.Login.ImloginRes.Builder {
            return classBuilder() as! Im.Login.ImloginRes.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImloginRes.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImloginRes.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImloginRes.Builder {
            return try Im.Login.ImloginRes.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImloginRes) throws -> Im.Login.ImloginRes.Builder {
            return try Im.Login.ImloginRes.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasServerTime {
                jsonMap["serverTime"] = UInt(serverTime)
            }
            if hasResultCode {
                jsonMap["resultCode"] = resultCode.toString()
            }
            if hasResultString {
                jsonMap["resultString"] = resultString
            }
            if hasOnlineStatus {
                jsonMap["onlineStatus"] = onlineStatus.toString()
            }
            if hasUserInfo {
                jsonMap["userInfo"] = try userInfo.encode()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImloginRes {
            return try Im.Login.ImloginRes.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImloginRes {
            return try Im.Login.ImloginRes.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasServerTime {
                output += "\(indent) serverTime: \(serverTime) \n"
            }
            if (hasResultCode) {
                output += "\(indent) resultCode: \(resultCode.description)\n"
            }
            if hasResultString {
                output += "\(indent) resultString: \(resultString) \n"
            }
            if (hasOnlineStatus) {
                output += "\(indent) onlineStatus: \(onlineStatus.description)\n"
            }
            if hasUserInfo {
                output += "\(indent) userInfo {\n"
                if let outDescUserInfo = userInfo {
                    output += try outDescUserInfo.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasServerTime {
                    hashCode = (hashCode &* 31) &+ serverTime.hashValue
                }
                if hasResultCode {
                     hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasResultString {
                    hashCode = (hashCode &* 31) &+ resultString.hashValue
                }
                if hasOnlineStatus {
                     hashCode = (hashCode &* 31) &+ onlineStatus.hashValue
                }
                if hasUserInfo {
                    if let hashValueuserInfo = userInfo?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuserInfo
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImloginRes"
        }
        override public func className() -> String {
            return "Im.Login.ImloginRes"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImloginRes = Im.Login.ImloginRes()
            public func getMessage() -> Im.Login.ImloginRes {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0104
            public var serverTime:UInt32 {
                get {
                    return builderResult.serverTime
                }
                set (value) {
                    builderResult.hasServerTime = true
                    builderResult.serverTime = value
                }
            }
            public var hasServerTime:Bool {
                get {
                    return builderResult.hasServerTime
                }
            }
            @discardableResult
            public func setServerTime(_ value:UInt32) -> Im.Login.ImloginRes.Builder {
                self.serverTime = value
                return self
            }
            @discardableResult
            public func clearServerTime() -> Im.Login.ImloginRes.Builder{
                builderResult.hasServerTime = false
                builderResult.serverTime = nil
                return self
            }
                public var resultCode:Im.BaseDefine.ResultType {
                    get {
                        return builderResult.resultCode
                    }
                    set (value) {
                        builderResult.hasResultCode = true
                        builderResult.resultCode = value
                    }
                }
                public var hasResultCode:Bool{
                    get {
                        return builderResult.hasResultCode
                    }
                }
            @discardableResult
                public func setResultCode(_ value:Im.BaseDefine.ResultType) -> Im.Login.ImloginRes.Builder {
                  self.resultCode = value
                  return self
                }
            @discardableResult
                public func clearResultCode() -> Im.Login.ImloginRes.Builder {
                   builderResult.hasResultCode = false
                   builderResult.resultCode = .refuseReasonNone
                   return self
                }
            public var resultString:String {
                get {
                    return builderResult.resultString
                }
                set (value) {
                    builderResult.hasResultString = true
                    builderResult.resultString = value
                }
            }
            public var hasResultString:Bool {
                get {
                    return builderResult.hasResultString
                }
            }
            @discardableResult
            public func setResultString(_ value:String) -> Im.Login.ImloginRes.Builder {
                self.resultString = value
                return self
            }
            @discardableResult
            public func clearResultString() -> Im.Login.ImloginRes.Builder{
                builderResult.hasResultString = false
                builderResult.resultString = nil
                return self
            }
                public var onlineStatus:Im.BaseDefine.UserStatType {
                    get {
                        return builderResult.onlineStatus
                    }
                    set (value) {
                        builderResult.hasOnlineStatus = true
                        builderResult.onlineStatus = value
                    }
                }
                public var hasOnlineStatus:Bool{
                    get {
                        return builderResult.hasOnlineStatus
                    }
                }
            @discardableResult
                public func setOnlineStatus(_ value:Im.BaseDefine.UserStatType) -> Im.Login.ImloginRes.Builder {
                  self.onlineStatus = value
                  return self
                }
            @discardableResult
                public func clearOnlineStatus() -> Im.Login.ImloginRes.Builder {
                   builderResult.hasOnlineStatus = false
                   builderResult.onlineStatus = .userStatusOnline
                   return self
                }
            public var userInfo:Im.BaseDefine.UserInfo! {
                get {
                    if userInfoBuilder_ != nil {
                        builderResult.userInfo = userInfoBuilder_.getMessage()
                    }
                    return builderResult.userInfo
                }
                set (value) {
                    builderResult.hasUserInfo = true
                    builderResult.userInfo = value
                }
            }
            public var hasUserInfo:Bool {
                get {
                    return builderResult.hasUserInfo
                }
            }
            fileprivate var userInfoBuilder_:Im.BaseDefine.UserInfo.Builder! {
                didSet {
                    builderResult.hasUserInfo = true
                }
            }
            public func getUserInfoBuilder() -> Im.BaseDefine.UserInfo.Builder {
                if userInfoBuilder_ == nil {
                    userInfoBuilder_ = Im.BaseDefine.UserInfo.Builder()
                    builderResult.userInfo = userInfoBuilder_.getMessage()
                    if userInfo != nil {
                        try! userInfoBuilder_.mergeFrom(other: userInfo)
                    }
                }
                return userInfoBuilder_
            }
            @discardableResult
            public func setUserInfo(_ value:Im.BaseDefine.UserInfo!) -> Im.Login.ImloginRes.Builder {
                self.userInfo = value
                return self
            }
            @discardableResult
            public func mergeUserInfo(value:Im.BaseDefine.UserInfo) throws -> Im.Login.ImloginRes.Builder {
                if builderResult.hasUserInfo {
                    builderResult.userInfo = try Im.BaseDefine.UserInfo.builderWithPrototype(prototype:builderResult.userInfo).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.userInfo = value
                }
                builderResult.hasUserInfo = true
                return self
            }
            @discardableResult
            public func clearUserInfo() -> Im.Login.ImloginRes.Builder {
                userInfoBuilder_ = nil
                builderResult.hasUserInfo = false
                builderResult.userInfo = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImloginRes.Builder {
                builderResult = Im.Login.ImloginRes()
                return self
            }
            override public func clone() throws -> Im.Login.ImloginRes.Builder {
                return try Im.Login.ImloginRes.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImloginRes {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImloginRes {
                let returnMe:Im.Login.ImloginRes = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImloginRes) throws -> Im.Login.ImloginRes.Builder {
                if other == Im.Login.ImloginRes() {
                    return self
                }
                if other.hasServerTime {
                    serverTime = other.serverTime
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasResultString {
                    resultString = other.resultString
                }
                if other.hasOnlineStatus {
                    onlineStatus = other.onlineStatus
                }
                if (other.hasUserInfo) {
                    try mergeUserInfo(value: other.userInfo)
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImloginRes.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImloginRes.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        serverTime = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntresultCode = try codedInputStream.readEnum()
                        if let enumsresultCode = Im.BaseDefine.ResultType(rawValue:valueIntresultCode){
                            resultCode = enumsresultCode
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntresultCode))
                        }

                    case 26:
                        resultString = try codedInputStream.readString()

                    case 32:
                        let valueIntonlineStatus = try codedInputStream.readEnum()
                        if let enumsonlineStatus = Im.BaseDefine.UserStatType(rawValue:valueIntonlineStatus){
                            onlineStatus = enumsonlineStatus
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntonlineStatus))
                        }

                    case 42:
                        let subBuilder:Im.BaseDefine.UserInfo.Builder = Im.BaseDefine.UserInfo.Builder()
                        if hasUserInfo {
                            try subBuilder.mergeFrom(other: userInfo)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        userInfo = subBuilder.buildPartial()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImloginRes.Builder {
                let resultDecodedBuilder = Im.Login.ImloginRes.Builder()
                if let jsonValueServerTime = jsonMap["serverTime"] as? UInt {
                    resultDecodedBuilder.serverTime = UInt32(jsonValueServerTime)
                } else if let jsonValueServerTime = jsonMap["serverTime"] as? String {
                    resultDecodedBuilder.serverTime = UInt32(jsonValueServerTime)!
                }
                if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = try Im.BaseDefine.ResultType.fromString(jsonValueResultCode)
                }
                if let jsonValueResultString = jsonMap["resultString"] as? String {
                    resultDecodedBuilder.resultString = jsonValueResultString
                }
                if let jsonValueOnlineStatus = jsonMap["onlineStatus"] as? String {
                    resultDecodedBuilder.onlineStatus = try Im.BaseDefine.UserStatType.fromString(jsonValueOnlineStatus)
                }
                if let jsonValueUserInfo = jsonMap["userInfo"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.userInfo = try Im.BaseDefine.UserInfo.Builder.decodeToBuilder(jsonMap:jsonValueUserInfo).build()

                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImloginRes.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImloginRes.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///cmd id:		0x0105
    final public class ImlogoutReq : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImlogoutReq.Builder

        public static func == (lhs: Im.Login.ImlogoutReq, rhs: Im.Login.ImlogoutReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImlogoutReq.Builder {
            return Im.Login.ImlogoutReq.classBuilder() as! Im.Login.ImlogoutReq.Builder
        }
        public func getBuilder() -> Im.Login.ImlogoutReq.Builder {
            return classBuilder() as! Im.Login.ImlogoutReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImlogoutReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImlogoutReq.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImlogoutReq.Builder {
            return try Im.Login.ImlogoutReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImlogoutReq) throws -> Im.Login.ImlogoutReq.Builder {
            return try Im.Login.ImlogoutReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImlogoutReq {
            return try Im.Login.ImlogoutReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImlogoutReq {
            return try Im.Login.ImlogoutReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImlogoutReq"
        }
        override public func className() -> String {
            return "Im.Login.ImlogoutReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImlogoutReq = Im.Login.ImlogoutReq()
            public func getMessage() -> Im.Login.ImlogoutReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImlogoutReq.Builder {
                builderResult = Im.Login.ImlogoutReq()
                return self
            }
            override public func clone() throws -> Im.Login.ImlogoutReq.Builder {
                return try Im.Login.ImlogoutReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImlogoutReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImlogoutReq {
                let returnMe:Im.Login.ImlogoutReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImlogoutReq) throws -> Im.Login.ImlogoutReq.Builder {
                if other == Im.Login.ImlogoutReq() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImlogoutReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImlogoutReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImlogoutReq.Builder {
                let resultDecodedBuilder = Im.Login.ImlogoutReq.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImlogoutReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImlogoutReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImlogoutRsp : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImlogoutRsp.Builder

        public static func == (lhs: Im.Login.ImlogoutRsp, rhs: Im.Login.ImlogoutRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x0106
        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasResultCode {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:resultCode)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImlogoutRsp.Builder {
            return Im.Login.ImlogoutRsp.classBuilder() as! Im.Login.ImlogoutRsp.Builder
        }
        public func getBuilder() -> Im.Login.ImlogoutRsp.Builder {
            return classBuilder() as! Im.Login.ImlogoutRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImlogoutRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImlogoutRsp.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImlogoutRsp.Builder {
            return try Im.Login.ImlogoutRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImlogoutRsp) throws -> Im.Login.ImlogoutRsp.Builder {
            return try Im.Login.ImlogoutRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImlogoutRsp {
            return try Im.Login.ImlogoutRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImlogoutRsp {
            return try Im.Login.ImlogoutRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImlogoutRsp"
        }
        override public func className() -> String {
            return "Im.Login.ImlogoutRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImlogoutRsp = Im.Login.ImlogoutRsp()
            public func getMessage() -> Im.Login.ImlogoutRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0106
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.Login.ImlogoutRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.Login.ImlogoutRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImlogoutRsp.Builder {
                builderResult = Im.Login.ImlogoutRsp()
                return self
            }
            override public func clone() throws -> Im.Login.ImlogoutRsp.Builder {
                return try Im.Login.ImlogoutRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImlogoutRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImlogoutRsp {
                let returnMe:Im.Login.ImlogoutRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImlogoutRsp) throws -> Im.Login.ImlogoutRsp.Builder {
                if other == Im.Login.ImlogoutRsp() {
                    return self
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImlogoutRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImlogoutRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        resultCode = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImlogoutRsp.Builder {
                let resultDecodedBuilder = Im.Login.ImlogoutRsp.Builder()
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImlogoutRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImlogoutRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImkickUser : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImkickUser.Builder

        public static func == (lhs: Im.Login.ImkickUser, rhs: Im.Login.ImkickUser) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasKickReason == rhs.hasKickReason) && (!lhs.hasKickReason || lhs.kickReason == rhs.kickReason)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x0107
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var kickReason:Im.BaseDefine.KickReasonType = Im.BaseDefine.KickReasonType.kickReasonDuplicateUser
        public fileprivate(set) var hasKickReason:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasKickReason {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasKickReason {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:kickReason.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasKickReason) {
                serialize_size += kickReason.rawValue.computeEnumSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImkickUser.Builder {
            return Im.Login.ImkickUser.classBuilder() as! Im.Login.ImkickUser.Builder
        }
        public func getBuilder() -> Im.Login.ImkickUser.Builder {
            return classBuilder() as! Im.Login.ImkickUser.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImkickUser.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImkickUser.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImkickUser.Builder {
            return try Im.Login.ImkickUser.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImkickUser) throws -> Im.Login.ImkickUser.Builder {
            return try Im.Login.ImkickUser.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasKickReason {
                jsonMap["kickReason"] = kickReason.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImkickUser {
            return try Im.Login.ImkickUser.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImkickUser {
            return try Im.Login.ImkickUser.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasKickReason) {
                output += "\(indent) kickReason: \(kickReason.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasKickReason {
                     hashCode = (hashCode &* 31) &+ kickReason.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImkickUser"
        }
        override public func className() -> String {
            return "Im.Login.ImkickUser"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImkickUser = Im.Login.ImkickUser()
            public func getMessage() -> Im.Login.ImkickUser {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0107
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Login.ImkickUser.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Login.ImkickUser.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var kickReason:Im.BaseDefine.KickReasonType {
                    get {
                        return builderResult.kickReason
                    }
                    set (value) {
                        builderResult.hasKickReason = true
                        builderResult.kickReason = value
                    }
                }
                public var hasKickReason:Bool{
                    get {
                        return builderResult.hasKickReason
                    }
                }
            @discardableResult
                public func setKickReason(_ value:Im.BaseDefine.KickReasonType) -> Im.Login.ImkickUser.Builder {
                  self.kickReason = value
                  return self
                }
            @discardableResult
                public func clearKickReason() -> Im.Login.ImkickUser.Builder {
                   builderResult.hasKickReason = false
                   builderResult.kickReason = .kickReasonDuplicateUser
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImkickUser.Builder {
                builderResult = Im.Login.ImkickUser()
                return self
            }
            override public func clone() throws -> Im.Login.ImkickUser.Builder {
                return try Im.Login.ImkickUser.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImkickUser {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImkickUser {
                let returnMe:Im.Login.ImkickUser = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImkickUser) throws -> Im.Login.ImkickUser.Builder {
                if other == Im.Login.ImkickUser() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasKickReason {
                    kickReason = other.kickReason
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImkickUser.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImkickUser.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntkickReason = try codedInputStream.readEnum()
                        if let enumskickReason = Im.BaseDefine.KickReasonType(rawValue:valueIntkickReason){
                            kickReason = enumskickReason
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntkickReason))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImkickUser.Builder {
                let resultDecodedBuilder = Im.Login.ImkickUser.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueKickReason = jsonMap["kickReason"] as? String {
                    resultDecodedBuilder.kickReason = try Im.BaseDefine.KickReasonType.fromString(jsonValueKickReason)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImkickUser.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImkickUser.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImdeviceTokenReq : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImdeviceTokenReq.Builder

        public static func == (lhs: Im.Login.ImdeviceTokenReq, rhs: Im.Login.ImdeviceTokenReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasDeviceToken == rhs.hasDeviceToken) && (!lhs.hasDeviceToken || lhs.deviceToken == rhs.deviceToken)
            fieldCheck = fieldCheck && (lhs.hasClientType == rhs.hasClientType) && (!lhs.hasClientType || lhs.clientType == rhs.clientType)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x0108
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var deviceToken:String! = nil
        public fileprivate(set) var hasDeviceToken:Bool = false

        public fileprivate(set) var clientType:Im.BaseDefine.ClientType = Im.BaseDefine.ClientType.clientTypeWindows
        public fileprivate(set) var hasClientType:Bool = false
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasDeviceToken {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasDeviceToken {
                try codedOutputStream.writeString(fieldNumber: 2, value:deviceToken)
            }
            if hasClientType {
                try codedOutputStream.writeEnum(fieldNumber: 3, value:clientType.rawValue)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasDeviceToken {
                serialize_size += deviceToken.computeStringSize(fieldNumber: 2)
            }
            if (hasClientType) {
                serialize_size += clientType.rawValue.computeEnumSize(fieldNumber: 3)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImdeviceTokenReq.Builder {
            return Im.Login.ImdeviceTokenReq.classBuilder() as! Im.Login.ImdeviceTokenReq.Builder
        }
        public func getBuilder() -> Im.Login.ImdeviceTokenReq.Builder {
            return classBuilder() as! Im.Login.ImdeviceTokenReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImdeviceTokenReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImdeviceTokenReq.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImdeviceTokenReq.Builder {
            return try Im.Login.ImdeviceTokenReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImdeviceTokenReq) throws -> Im.Login.ImdeviceTokenReq.Builder {
            return try Im.Login.ImdeviceTokenReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasDeviceToken {
                jsonMap["deviceToken"] = deviceToken
            }
            if hasClientType {
                jsonMap["clientType"] = clientType.toString()
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImdeviceTokenReq {
            return try Im.Login.ImdeviceTokenReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImdeviceTokenReq {
            return try Im.Login.ImdeviceTokenReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasDeviceToken {
                output += "\(indent) deviceToken: \(deviceToken) \n"
            }
            if (hasClientType) {
                output += "\(indent) clientType: \(clientType.description)\n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasDeviceToken {
                    hashCode = (hashCode &* 31) &+ deviceToken.hashValue
                }
                if hasClientType {
                     hashCode = (hashCode &* 31) &+ clientType.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImdeviceTokenReq"
        }
        override public func className() -> String {
            return "Im.Login.ImdeviceTokenReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImdeviceTokenReq = Im.Login.ImdeviceTokenReq()
            public func getMessage() -> Im.Login.ImdeviceTokenReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0108
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Login.ImdeviceTokenReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Login.ImdeviceTokenReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var deviceToken:String {
                get {
                    return builderResult.deviceToken
                }
                set (value) {
                    builderResult.hasDeviceToken = true
                    builderResult.deviceToken = value
                }
            }
            public var hasDeviceToken:Bool {
                get {
                    return builderResult.hasDeviceToken
                }
            }
            @discardableResult
            public func setDeviceToken(_ value:String) -> Im.Login.ImdeviceTokenReq.Builder {
                self.deviceToken = value
                return self
            }
            @discardableResult
            public func clearDeviceToken() -> Im.Login.ImdeviceTokenReq.Builder{
                builderResult.hasDeviceToken = false
                builderResult.deviceToken = nil
                return self
            }
                public var clientType:Im.BaseDefine.ClientType {
                    get {
                        return builderResult.clientType
                    }
                    set (value) {
                        builderResult.hasClientType = true
                        builderResult.clientType = value
                    }
                }
                public var hasClientType:Bool{
                    get {
                        return builderResult.hasClientType
                    }
                }
            @discardableResult
                public func setClientType(_ value:Im.BaseDefine.ClientType) -> Im.Login.ImdeviceTokenReq.Builder {
                  self.clientType = value
                  return self
                }
            @discardableResult
                public func clearClientType() -> Im.Login.ImdeviceTokenReq.Builder {
                   builderResult.hasClientType = false
                   builderResult.clientType = .clientTypeWindows
                   return self
                }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Login.ImdeviceTokenReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Login.ImdeviceTokenReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImdeviceTokenReq.Builder {
                builderResult = Im.Login.ImdeviceTokenReq()
                return self
            }
            override public func clone() throws -> Im.Login.ImdeviceTokenReq.Builder {
                return try Im.Login.ImdeviceTokenReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImdeviceTokenReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImdeviceTokenReq {
                let returnMe:Im.Login.ImdeviceTokenReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImdeviceTokenReq) throws -> Im.Login.ImdeviceTokenReq.Builder {
                if other == Im.Login.ImdeviceTokenReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasDeviceToken {
                    deviceToken = other.deviceToken
                }
                if other.hasClientType {
                    clientType = other.clientType
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImdeviceTokenReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImdeviceTokenReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 18:
                        deviceToken = try codedInputStream.readString()

                    case 24:
                        let valueIntclientType = try codedInputStream.readEnum()
                        if let enumsclientType = Im.BaseDefine.ClientType(rawValue:valueIntclientType){
                            clientType = enumsclientType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntclientType))
                        }

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImdeviceTokenReq.Builder {
                let resultDecodedBuilder = Im.Login.ImdeviceTokenReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueDeviceToken = jsonMap["deviceToken"] as? String {
                    resultDecodedBuilder.deviceToken = jsonValueDeviceToken
                }
                if let jsonValueClientType = jsonMap["clientType"] as? String {
                    resultDecodedBuilder.clientType = try Im.BaseDefine.ClientType.fromString(jsonValueClientType)
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImdeviceTokenReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImdeviceTokenReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImdeviceTokenRsp : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImdeviceTokenRsp.Builder

        public static func == (lhs: Im.Login.ImdeviceTokenRsp, rhs: Im.Login.ImdeviceTokenRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id: 		0x0109
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImdeviceTokenRsp.Builder {
            return Im.Login.ImdeviceTokenRsp.classBuilder() as! Im.Login.ImdeviceTokenRsp.Builder
        }
        public func getBuilder() -> Im.Login.ImdeviceTokenRsp.Builder {
            return classBuilder() as! Im.Login.ImdeviceTokenRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImdeviceTokenRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImdeviceTokenRsp.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImdeviceTokenRsp.Builder {
            return try Im.Login.ImdeviceTokenRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImdeviceTokenRsp) throws -> Im.Login.ImdeviceTokenRsp.Builder {
            return try Im.Login.ImdeviceTokenRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImdeviceTokenRsp {
            return try Im.Login.ImdeviceTokenRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImdeviceTokenRsp {
            return try Im.Login.ImdeviceTokenRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImdeviceTokenRsp"
        }
        override public func className() -> String {
            return "Im.Login.ImdeviceTokenRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImdeviceTokenRsp = Im.Login.ImdeviceTokenRsp()
            public func getMessage() -> Im.Login.ImdeviceTokenRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 		0x0109
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Login.ImdeviceTokenRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Login.ImdeviceTokenRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Login.ImdeviceTokenRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Login.ImdeviceTokenRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImdeviceTokenRsp.Builder {
                builderResult = Im.Login.ImdeviceTokenRsp()
                return self
            }
            override public func clone() throws -> Im.Login.ImdeviceTokenRsp.Builder {
                return try Im.Login.ImdeviceTokenRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImdeviceTokenRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImdeviceTokenRsp {
                let returnMe:Im.Login.ImdeviceTokenRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImdeviceTokenRsp) throws -> Im.Login.ImdeviceTokenRsp.Builder {
                if other == Im.Login.ImdeviceTokenRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImdeviceTokenRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImdeviceTokenRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImdeviceTokenRsp.Builder {
                let resultDecodedBuilder = Im.Login.ImdeviceTokenRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImdeviceTokenRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImdeviceTokenRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///只给移动端请求
    final public class ImkickPcclientReq : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImkickPcclientReq.Builder

        public static func == (lhs: Im.Login.ImkickPcclientReq, rhs: Im.Login.ImkickPcclientReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x010a
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImkickPcclientReq.Builder {
            return Im.Login.ImkickPcclientReq.classBuilder() as! Im.Login.ImkickPcclientReq.Builder
        }
        public func getBuilder() -> Im.Login.ImkickPcclientReq.Builder {
            return classBuilder() as! Im.Login.ImkickPcclientReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImkickPcclientReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImkickPcclientReq.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImkickPcclientReq.Builder {
            return try Im.Login.ImkickPcclientReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImkickPcclientReq) throws -> Im.Login.ImkickPcclientReq.Builder {
            return try Im.Login.ImkickPcclientReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImkickPcclientReq {
            return try Im.Login.ImkickPcclientReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImkickPcclientReq {
            return try Im.Login.ImkickPcclientReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImkickPcclientReq"
        }
        override public func className() -> String {
            return "Im.Login.ImkickPcclientReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImkickPcclientReq = Im.Login.ImkickPcclientReq()
            public func getMessage() -> Im.Login.ImkickPcclientReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x010a
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Login.ImkickPcclientReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Login.ImkickPcclientReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImkickPcclientReq.Builder {
                builderResult = Im.Login.ImkickPcclientReq()
                return self
            }
            override public func clone() throws -> Im.Login.ImkickPcclientReq.Builder {
                return try Im.Login.ImkickPcclientReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImkickPcclientReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImkickPcclientReq {
                let returnMe:Im.Login.ImkickPcclientReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImkickPcclientReq) throws -> Im.Login.ImkickPcclientReq.Builder {
                if other == Im.Login.ImkickPcclientReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImkickPcclientReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImkickPcclientReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImkickPcclientReq.Builder {
                let resultDecodedBuilder = Im.Login.ImkickPcclientReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImkickPcclientReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImkickPcclientReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImkickPcclientRsp : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImkickPcclientRsp.Builder

        public static func == (lhs: Im.Login.ImkickPcclientRsp, rhs: Im.Login.ImkickPcclientRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id: 		0x010b
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasResultCode {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:resultCode)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImkickPcclientRsp.Builder {
            return Im.Login.ImkickPcclientRsp.classBuilder() as! Im.Login.ImkickPcclientRsp.Builder
        }
        public func getBuilder() -> Im.Login.ImkickPcclientRsp.Builder {
            return classBuilder() as! Im.Login.ImkickPcclientRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImkickPcclientRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImkickPcclientRsp.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImkickPcclientRsp.Builder {
            return try Im.Login.ImkickPcclientRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImkickPcclientRsp) throws -> Im.Login.ImkickPcclientRsp.Builder {
            return try Im.Login.ImkickPcclientRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImkickPcclientRsp {
            return try Im.Login.ImkickPcclientRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImkickPcclientRsp {
            return try Im.Login.ImkickPcclientRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImkickPcclientRsp"
        }
        override public func className() -> String {
            return "Im.Login.ImkickPcclientRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImkickPcclientRsp = Im.Login.ImkickPcclientRsp()
            public func getMessage() -> Im.Login.ImkickPcclientRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 		0x010b
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Login.ImkickPcclientRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Login.ImkickPcclientRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.Login.ImkickPcclientRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.Login.ImkickPcclientRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImkickPcclientRsp.Builder {
                builderResult = Im.Login.ImkickPcclientRsp()
                return self
            }
            override public func clone() throws -> Im.Login.ImkickPcclientRsp.Builder {
                return try Im.Login.ImkickPcclientRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImkickPcclientRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImkickPcclientRsp {
                let returnMe:Im.Login.ImkickPcclientRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImkickPcclientRsp) throws -> Im.Login.ImkickPcclientRsp.Builder {
                if other == Im.Login.ImkickPcclientRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImkickPcclientRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImkickPcclientRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        resultCode = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImkickPcclientRsp.Builder {
                let resultDecodedBuilder = Im.Login.ImkickPcclientRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImkickPcclientRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImkickPcclientRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// 一旦设置以后，22:00 -- 07:00不发送
    final public class ImpushShieldReq : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImpushShieldReq.Builder

        public static func == (lhs: Im.Login.ImpushShieldReq, rhs: Im.Login.ImpushShieldReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasShieldStatus == rhs.hasShieldStatus) && (!lhs.hasShieldStatus || lhs.shieldStatus == rhs.shieldStatus)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x010c
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        /// 1:开启，0：关闭
        public fileprivate(set) var shieldStatus:UInt32! = nil
        public fileprivate(set) var hasShieldStatus:Bool = false

        /// 服务端用，客户端不用设置
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasShieldStatus {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasShieldStatus {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:shieldStatus)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasShieldStatus {
                serialize_size += shieldStatus.computeUInt32Size(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImpushShieldReq.Builder {
            return Im.Login.ImpushShieldReq.classBuilder() as! Im.Login.ImpushShieldReq.Builder
        }
        public func getBuilder() -> Im.Login.ImpushShieldReq.Builder {
            return classBuilder() as! Im.Login.ImpushShieldReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImpushShieldReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImpushShieldReq.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImpushShieldReq.Builder {
            return try Im.Login.ImpushShieldReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImpushShieldReq) throws -> Im.Login.ImpushShieldReq.Builder {
            return try Im.Login.ImpushShieldReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasShieldStatus {
                jsonMap["shieldStatus"] = UInt(shieldStatus)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImpushShieldReq {
            return try Im.Login.ImpushShieldReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImpushShieldReq {
            return try Im.Login.ImpushShieldReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasShieldStatus {
                output += "\(indent) shieldStatus: \(shieldStatus) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasShieldStatus {
                    hashCode = (hashCode &* 31) &+ shieldStatus.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImpushShieldReq"
        }
        override public func className() -> String {
            return "Im.Login.ImpushShieldReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImpushShieldReq = Im.Login.ImpushShieldReq()
            public func getMessage() -> Im.Login.ImpushShieldReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x010c
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Login.ImpushShieldReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Login.ImpushShieldReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            /// 1:开启，0：关闭
            public var shieldStatus:UInt32 {
                get {
                    return builderResult.shieldStatus
                }
                set (value) {
                    builderResult.hasShieldStatus = true
                    builderResult.shieldStatus = value
                }
            }
            public var hasShieldStatus:Bool {
                get {
                    return builderResult.hasShieldStatus
                }
            }
            @discardableResult
            public func setShieldStatus(_ value:UInt32) -> Im.Login.ImpushShieldReq.Builder {
                self.shieldStatus = value
                return self
            }
            @discardableResult
            public func clearShieldStatus() -> Im.Login.ImpushShieldReq.Builder{
                builderResult.hasShieldStatus = false
                builderResult.shieldStatus = nil
                return self
            }
            /// 服务端用，客户端不用设置
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Login.ImpushShieldReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Login.ImpushShieldReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImpushShieldReq.Builder {
                builderResult = Im.Login.ImpushShieldReq()
                return self
            }
            override public func clone() throws -> Im.Login.ImpushShieldReq.Builder {
                return try Im.Login.ImpushShieldReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImpushShieldReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImpushShieldReq {
                let returnMe:Im.Login.ImpushShieldReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImpushShieldReq) throws -> Im.Login.ImpushShieldReq.Builder {
                if other == Im.Login.ImpushShieldReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasShieldStatus {
                    shieldStatus = other.shieldStatus
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImpushShieldReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImpushShieldReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        shieldStatus = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImpushShieldReq.Builder {
                let resultDecodedBuilder = Im.Login.ImpushShieldReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? UInt {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)
                } else if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? String {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImpushShieldReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImpushShieldReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImpushShieldRsp : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImpushShieldRsp.Builder

        public static func == (lhs: Im.Login.ImpushShieldRsp, rhs: Im.Login.ImpushShieldRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasShieldStatus == rhs.hasShieldStatus) && (!lhs.hasShieldStatus || lhs.shieldStatus == rhs.shieldStatus)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x010d
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        /// 值： 0:successed 1:failed
        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        /// 值： 如果result_code值为0(successed)，则shield_status值设置， 1:开启， 0:关闭
        public fileprivate(set) var shieldStatus:UInt32! = nil
        public fileprivate(set) var hasShieldStatus:Bool = false

        /// 服务端用，客户端不用设置
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasResultCode {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:resultCode)
            }
            if hasShieldStatus {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:shieldStatus)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 2)
            }
            if hasShieldStatus {
                serialize_size += shieldStatus.computeUInt32Size(fieldNumber: 3)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImpushShieldRsp.Builder {
            return Im.Login.ImpushShieldRsp.classBuilder() as! Im.Login.ImpushShieldRsp.Builder
        }
        public func getBuilder() -> Im.Login.ImpushShieldRsp.Builder {
            return classBuilder() as! Im.Login.ImpushShieldRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImpushShieldRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImpushShieldRsp.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImpushShieldRsp.Builder {
            return try Im.Login.ImpushShieldRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImpushShieldRsp) throws -> Im.Login.ImpushShieldRsp.Builder {
            return try Im.Login.ImpushShieldRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            if hasShieldStatus {
                jsonMap["shieldStatus"] = UInt(shieldStatus)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImpushShieldRsp {
            return try Im.Login.ImpushShieldRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImpushShieldRsp {
            return try Im.Login.ImpushShieldRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            if hasShieldStatus {
                output += "\(indent) shieldStatus: \(shieldStatus) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasShieldStatus {
                    hashCode = (hashCode &* 31) &+ shieldStatus.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImpushShieldRsp"
        }
        override public func className() -> String {
            return "Im.Login.ImpushShieldRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImpushShieldRsp = Im.Login.ImpushShieldRsp()
            public func getMessage() -> Im.Login.ImpushShieldRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x010d
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Login.ImpushShieldRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Login.ImpushShieldRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            /// 值： 0:successed 1:failed
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.Login.ImpushShieldRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.Login.ImpushShieldRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            /// 值： 如果result_code值为0(successed)，则shield_status值设置， 1:开启， 0:关闭
            public var shieldStatus:UInt32 {
                get {
                    return builderResult.shieldStatus
                }
                set (value) {
                    builderResult.hasShieldStatus = true
                    builderResult.shieldStatus = value
                }
            }
            public var hasShieldStatus:Bool {
                get {
                    return builderResult.hasShieldStatus
                }
            }
            @discardableResult
            public func setShieldStatus(_ value:UInt32) -> Im.Login.ImpushShieldRsp.Builder {
                self.shieldStatus = value
                return self
            }
            @discardableResult
            public func clearShieldStatus() -> Im.Login.ImpushShieldRsp.Builder{
                builderResult.hasShieldStatus = false
                builderResult.shieldStatus = nil
                return self
            }
            /// 服务端用，客户端不用设置
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Login.ImpushShieldRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Login.ImpushShieldRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImpushShieldRsp.Builder {
                builderResult = Im.Login.ImpushShieldRsp()
                return self
            }
            override public func clone() throws -> Im.Login.ImpushShieldRsp.Builder {
                return try Im.Login.ImpushShieldRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImpushShieldRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImpushShieldRsp {
                let returnMe:Im.Login.ImpushShieldRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImpushShieldRsp) throws -> Im.Login.ImpushShieldRsp.Builder {
                if other == Im.Login.ImpushShieldRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasShieldStatus {
                    shieldStatus = other.shieldStatus
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImpushShieldRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImpushShieldRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        resultCode = try codedInputStream.readUInt32()

                    case 24:
                        shieldStatus = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImpushShieldRsp.Builder {
                let resultDecodedBuilder = Im.Login.ImpushShieldRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? UInt {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)
                } else if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? String {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImpushShieldRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImpushShieldRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// 如果用户重新安装app，第一次启动登录成功后，app主动查询
    /// 服务端返回IMQueryPushShieldRsp
    final public class ImqueryPushShieldReq : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImqueryPushShieldReq.Builder

        public static func == (lhs: Im.Login.ImqueryPushShieldReq, rhs: Im.Login.ImqueryPushShieldReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x010e
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        /// 服务端用，客户端不用设置
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImqueryPushShieldReq.Builder {
            return Im.Login.ImqueryPushShieldReq.classBuilder() as! Im.Login.ImqueryPushShieldReq.Builder
        }
        public func getBuilder() -> Im.Login.ImqueryPushShieldReq.Builder {
            return classBuilder() as! Im.Login.ImqueryPushShieldReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImqueryPushShieldReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImqueryPushShieldReq.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImqueryPushShieldReq.Builder {
            return try Im.Login.ImqueryPushShieldReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImqueryPushShieldReq) throws -> Im.Login.ImqueryPushShieldReq.Builder {
            return try Im.Login.ImqueryPushShieldReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImqueryPushShieldReq {
            return try Im.Login.ImqueryPushShieldReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImqueryPushShieldReq {
            return try Im.Login.ImqueryPushShieldReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImqueryPushShieldReq"
        }
        override public func className() -> String {
            return "Im.Login.ImqueryPushShieldReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImqueryPushShieldReq = Im.Login.ImqueryPushShieldReq()
            public func getMessage() -> Im.Login.ImqueryPushShieldReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x010e
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Login.ImqueryPushShieldReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Login.ImqueryPushShieldReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            /// 服务端用，客户端不用设置
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Login.ImqueryPushShieldReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Login.ImqueryPushShieldReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImqueryPushShieldReq.Builder {
                builderResult = Im.Login.ImqueryPushShieldReq()
                return self
            }
            override public func clone() throws -> Im.Login.ImqueryPushShieldReq.Builder {
                return try Im.Login.ImqueryPushShieldReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImqueryPushShieldReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImqueryPushShieldReq {
                let returnMe:Im.Login.ImqueryPushShieldReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImqueryPushShieldReq) throws -> Im.Login.ImqueryPushShieldReq.Builder {
                if other == Im.Login.ImqueryPushShieldReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImqueryPushShieldReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImqueryPushShieldReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImqueryPushShieldReq.Builder {
                let resultDecodedBuilder = Im.Login.ImqueryPushShieldReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImqueryPushShieldReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImqueryPushShieldReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImqueryPushShieldRsp : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImqueryPushShieldRsp.Builder

        public static func == (lhs: Im.Login.ImqueryPushShieldRsp, rhs: Im.Login.ImqueryPushShieldRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasShieldStatus == rhs.hasShieldStatus) && (!lhs.hasShieldStatus || lhs.shieldStatus == rhs.shieldStatus)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x010f
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        /// 值： 0:successed 1:failed
        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        /// 值： 如果result_code值为0(successed)，则shield_status值设置， 1:开启， 0:关闭
        public fileprivate(set) var shieldStatus:UInt32! = nil
        public fileprivate(set) var hasShieldStatus:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasResultCode {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:resultCode)
            }
            if hasShieldStatus {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:shieldStatus)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 2)
            }
            if hasShieldStatus {
                serialize_size += shieldStatus.computeUInt32Size(fieldNumber: 3)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImqueryPushShieldRsp.Builder {
            return Im.Login.ImqueryPushShieldRsp.classBuilder() as! Im.Login.ImqueryPushShieldRsp.Builder
        }
        public func getBuilder() -> Im.Login.ImqueryPushShieldRsp.Builder {
            return classBuilder() as! Im.Login.ImqueryPushShieldRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImqueryPushShieldRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImqueryPushShieldRsp.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImqueryPushShieldRsp.Builder {
            return try Im.Login.ImqueryPushShieldRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImqueryPushShieldRsp) throws -> Im.Login.ImqueryPushShieldRsp.Builder {
            return try Im.Login.ImqueryPushShieldRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            if hasShieldStatus {
                jsonMap["shieldStatus"] = UInt(shieldStatus)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImqueryPushShieldRsp {
            return try Im.Login.ImqueryPushShieldRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImqueryPushShieldRsp {
            return try Im.Login.ImqueryPushShieldRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            if hasShieldStatus {
                output += "\(indent) shieldStatus: \(shieldStatus) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasShieldStatus {
                    hashCode = (hashCode &* 31) &+ shieldStatus.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImqueryPushShieldRsp"
        }
        override public func className() -> String {
            return "Im.Login.ImqueryPushShieldRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImqueryPushShieldRsp = Im.Login.ImqueryPushShieldRsp()
            public func getMessage() -> Im.Login.ImqueryPushShieldRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x010f
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Login.ImqueryPushShieldRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Login.ImqueryPushShieldRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            /// 值： 0:successed 1:failed
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.Login.ImqueryPushShieldRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.Login.ImqueryPushShieldRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            /// 值： 如果result_code值为0(successed)，则shield_status值设置， 1:开启， 0:关闭
            public var shieldStatus:UInt32 {
                get {
                    return builderResult.shieldStatus
                }
                set (value) {
                    builderResult.hasShieldStatus = true
                    builderResult.shieldStatus = value
                }
            }
            public var hasShieldStatus:Bool {
                get {
                    return builderResult.hasShieldStatus
                }
            }
            @discardableResult
            public func setShieldStatus(_ value:UInt32) -> Im.Login.ImqueryPushShieldRsp.Builder {
                self.shieldStatus = value
                return self
            }
            @discardableResult
            public func clearShieldStatus() -> Im.Login.ImqueryPushShieldRsp.Builder{
                builderResult.hasShieldStatus = false
                builderResult.shieldStatus = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Login.ImqueryPushShieldRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Login.ImqueryPushShieldRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImqueryPushShieldRsp.Builder {
                builderResult = Im.Login.ImqueryPushShieldRsp()
                return self
            }
            override public func clone() throws -> Im.Login.ImqueryPushShieldRsp.Builder {
                return try Im.Login.ImqueryPushShieldRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImqueryPushShieldRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImqueryPushShieldRsp {
                let returnMe:Im.Login.ImqueryPushShieldRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImqueryPushShieldRsp) throws -> Im.Login.ImqueryPushShieldRsp.Builder {
                if other == Im.Login.ImqueryPushShieldRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasShieldStatus {
                    shieldStatus = other.shieldStatus
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImqueryPushShieldRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImqueryPushShieldRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        resultCode = try codedInputStream.readUInt32()

                    case 24:
                        shieldStatus = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImqueryPushShieldRsp.Builder {
                let resultDecodedBuilder = Im.Login.ImqueryPushShieldRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? UInt {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)
                } else if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? String {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImqueryPushShieldRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImqueryPushShieldRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    /// 修改密碼
    final public class ImmodifyPassReq : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImmodifyPassReq.Builder

        public static func == (lhs: Im.Login.ImmodifyPassReq, rhs: Im.Login.ImmodifyPassReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasOldPass == rhs.hasOldPass) && (!lhs.hasOldPass || lhs.oldPass == rhs.oldPass)
            fieldCheck = fieldCheck && (lhs.hasNewPass == rhs.hasNewPass) && (!lhs.hasNewPass || lhs.newPass == rhs.newPass)
            fieldCheck = fieldCheck && (lhs.hasCfmPass == rhs.hasCfmPass) && (!lhs.hasCfmPass || lhs.cfmPass == rhs.cfmPass)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id: 0x0110
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var oldPass:String! = nil
        public fileprivate(set) var hasOldPass:Bool = false

        public fileprivate(set) var newPass:String! = nil
        public fileprivate(set) var hasNewPass:Bool = false

        public fileprivate(set) var cfmPass:String! = nil
        public fileprivate(set) var hasCfmPass:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasOldPass {
                return false
            }
            if !hasNewPass {
                return false
            }
            if !hasCfmPass {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasOldPass {
                try codedOutputStream.writeString(fieldNumber: 2, value:oldPass)
            }
            if hasNewPass {
                try codedOutputStream.writeString(fieldNumber: 3, value:newPass)
            }
            if hasCfmPass {
                try codedOutputStream.writeString(fieldNumber: 4, value:cfmPass)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasOldPass {
                serialize_size += oldPass.computeStringSize(fieldNumber: 2)
            }
            if hasNewPass {
                serialize_size += newPass.computeStringSize(fieldNumber: 3)
            }
            if hasCfmPass {
                serialize_size += cfmPass.computeStringSize(fieldNumber: 4)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImmodifyPassReq.Builder {
            return Im.Login.ImmodifyPassReq.classBuilder() as! Im.Login.ImmodifyPassReq.Builder
        }
        public func getBuilder() -> Im.Login.ImmodifyPassReq.Builder {
            return classBuilder() as! Im.Login.ImmodifyPassReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImmodifyPassReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImmodifyPassReq.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImmodifyPassReq.Builder {
            return try Im.Login.ImmodifyPassReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImmodifyPassReq) throws -> Im.Login.ImmodifyPassReq.Builder {
            return try Im.Login.ImmodifyPassReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasOldPass {
                jsonMap["oldPass"] = oldPass
            }
            if hasNewPass {
                jsonMap["newPass"] = newPass
            }
            if hasCfmPass {
                jsonMap["cfmPass"] = cfmPass
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImmodifyPassReq {
            return try Im.Login.ImmodifyPassReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImmodifyPassReq {
            return try Im.Login.ImmodifyPassReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasOldPass {
                output += "\(indent) oldPass: \(oldPass) \n"
            }
            if hasNewPass {
                output += "\(indent) newPass: \(newPass) \n"
            }
            if hasCfmPass {
                output += "\(indent) cfmPass: \(cfmPass) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasOldPass {
                    hashCode = (hashCode &* 31) &+ oldPass.hashValue
                }
                if hasNewPass {
                    hashCode = (hashCode &* 31) &+ newPass.hashValue
                }
                if hasCfmPass {
                    hashCode = (hashCode &* 31) &+ cfmPass.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImmodifyPassReq"
        }
        override public func className() -> String {
            return "Im.Login.ImmodifyPassReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImmodifyPassReq = Im.Login.ImmodifyPassReq()
            public func getMessage() -> Im.Login.ImmodifyPassReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 0x0110
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Login.ImmodifyPassReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Login.ImmodifyPassReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var oldPass:String {
                get {
                    return builderResult.oldPass
                }
                set (value) {
                    builderResult.hasOldPass = true
                    builderResult.oldPass = value
                }
            }
            public var hasOldPass:Bool {
                get {
                    return builderResult.hasOldPass
                }
            }
            @discardableResult
            public func setOldPass(_ value:String) -> Im.Login.ImmodifyPassReq.Builder {
                self.oldPass = value
                return self
            }
            @discardableResult
            public func clearOldPass() -> Im.Login.ImmodifyPassReq.Builder{
                builderResult.hasOldPass = false
                builderResult.oldPass = nil
                return self
            }
            public var newPass:String {
                get {
                    return builderResult.newPass
                }
                set (value) {
                    builderResult.hasNewPass = true
                    builderResult.newPass = value
                }
            }
            public var hasNewPass:Bool {
                get {
                    return builderResult.hasNewPass
                }
            }
            @discardableResult
            public func setNewPass(_ value:String) -> Im.Login.ImmodifyPassReq.Builder {
                self.newPass = value
                return self
            }
            @discardableResult
            public func clearNewPass() -> Im.Login.ImmodifyPassReq.Builder{
                builderResult.hasNewPass = false
                builderResult.newPass = nil
                return self
            }
            public var cfmPass:String {
                get {
                    return builderResult.cfmPass
                }
                set (value) {
                    builderResult.hasCfmPass = true
                    builderResult.cfmPass = value
                }
            }
            public var hasCfmPass:Bool {
                get {
                    return builderResult.hasCfmPass
                }
            }
            @discardableResult
            public func setCfmPass(_ value:String) -> Im.Login.ImmodifyPassReq.Builder {
                self.cfmPass = value
                return self
            }
            @discardableResult
            public func clearCfmPass() -> Im.Login.ImmodifyPassReq.Builder{
                builderResult.hasCfmPass = false
                builderResult.cfmPass = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Login.ImmodifyPassReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Login.ImmodifyPassReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImmodifyPassReq.Builder {
                builderResult = Im.Login.ImmodifyPassReq()
                return self
            }
            override public func clone() throws -> Im.Login.ImmodifyPassReq.Builder {
                return try Im.Login.ImmodifyPassReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImmodifyPassReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImmodifyPassReq {
                let returnMe:Im.Login.ImmodifyPassReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImmodifyPassReq) throws -> Im.Login.ImmodifyPassReq.Builder {
                if other == Im.Login.ImmodifyPassReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasOldPass {
                    oldPass = other.oldPass
                }
                if other.hasNewPass {
                    newPass = other.newPass
                }
                if other.hasCfmPass {
                    cfmPass = other.cfmPass
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImmodifyPassReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmodifyPassReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 18:
                        oldPass = try codedInputStream.readString()

                    case 26:
                        newPass = try codedInputStream.readString()

                    case 34:
                        cfmPass = try codedInputStream.readString()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImmodifyPassReq.Builder {
                let resultDecodedBuilder = Im.Login.ImmodifyPassReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueOldPass = jsonMap["oldPass"] as? String {
                    resultDecodedBuilder.oldPass = jsonValueOldPass
                }
                if let jsonValueNewPass = jsonMap["newPass"] as? String {
                    resultDecodedBuilder.newPass = jsonValueNewPass
                }
                if let jsonValueCfmPass = jsonMap["cfmPass"] as? String {
                    resultDecodedBuilder.cfmPass = jsonValueCfmPass
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImmodifyPassReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImmodifyPassReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImmodifyPassRsp : GeneratedMessage {
        public typealias BuilderType = Im.Login.ImmodifyPassRsp.Builder

        public static func == (lhs: Im.Login.ImmodifyPassRsp, rhs: Im.Login.ImmodifyPassRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id: 0x0111
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var status:UInt32! = nil
        public fileprivate(set) var hasStatus:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasStatus {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasStatus {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:status)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasStatus {
                serialize_size += status.computeUInt32Size(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Login.ImmodifyPassRsp.Builder {
            return Im.Login.ImmodifyPassRsp.classBuilder() as! Im.Login.ImmodifyPassRsp.Builder
        }
        public func getBuilder() -> Im.Login.ImmodifyPassRsp.Builder {
            return classBuilder() as! Im.Login.ImmodifyPassRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImmodifyPassRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Login.ImmodifyPassRsp.Builder()
        }
        public func toBuilder() throws -> Im.Login.ImmodifyPassRsp.Builder {
            return try Im.Login.ImmodifyPassRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Login.ImmodifyPassRsp) throws -> Im.Login.ImmodifyPassRsp.Builder {
            return try Im.Login.ImmodifyPassRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasStatus {
                jsonMap["status"] = UInt(status)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImmodifyPassRsp {
            return try Im.Login.ImmodifyPassRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Login.ImmodifyPassRsp {
            return try Im.Login.ImmodifyPassRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasStatus {
                output += "\(indent) status: \(status) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasStatus {
                    hashCode = (hashCode &* 31) &+ status.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Login.ImmodifyPassRsp"
        }
        override public func className() -> String {
            return "Im.Login.ImmodifyPassRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Login.ImmodifyPassRsp = Im.Login.ImmodifyPassRsp()
            public func getMessage() -> Im.Login.ImmodifyPassRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 0x0111
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Login.ImmodifyPassRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Login.ImmodifyPassRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var status:UInt32 {
                get {
                    return builderResult.status
                }
                set (value) {
                    builderResult.hasStatus = true
                    builderResult.status = value
                }
            }
            public var hasStatus:Bool {
                get {
                    return builderResult.hasStatus
                }
            }
            @discardableResult
            public func setStatus(_ value:UInt32) -> Im.Login.ImmodifyPassRsp.Builder {
                self.status = value
                return self
            }
            @discardableResult
            public func clearStatus() -> Im.Login.ImmodifyPassRsp.Builder{
                builderResult.hasStatus = false
                builderResult.status = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Login.ImmodifyPassRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Login.ImmodifyPassRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Login.ImmodifyPassRsp.Builder {
                builderResult = Im.Login.ImmodifyPassRsp()
                return self
            }
            override public func clone() throws -> Im.Login.ImmodifyPassRsp.Builder {
                return try Im.Login.ImmodifyPassRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Login.ImmodifyPassRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Login.ImmodifyPassRsp {
                let returnMe:Im.Login.ImmodifyPassRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Login.ImmodifyPassRsp) throws -> Im.Login.ImmodifyPassRsp.Builder {
                if other == Im.Login.ImmodifyPassRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasStatus {
                    status = other.status
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImmodifyPassRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmodifyPassRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        status = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Login.ImmodifyPassRsp.Builder {
                let resultDecodedBuilder = Im.Login.ImmodifyPassRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueStatus = jsonMap["status"] as? UInt {
                    resultDecodedBuilder.status = UInt32(jsonValueStatus)
                } else if let jsonValueStatus = jsonMap["status"] as? String {
                    resultDecodedBuilder.status = UInt32(jsonValueStatus)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Login.ImmodifyPassRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Login.ImmodifyPassRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Im.Login.ImmsgServReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImmsgServReq> {
        var mergedArray = Array<Im.Login.ImmsgServReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImmsgServReq? {
        return try Im.Login.ImmsgServReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImmsgServReq {
        return try Im.Login.ImmsgServReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmsgServReq {
        return try Im.Login.ImmsgServReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImmsgServReq {
        return try Im.Login.ImmsgServReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmsgServReq {
        return try Im.Login.ImmsgServReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImmsgServReq {
        return try Im.Login.ImmsgServReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmsgServReq {
        return try Im.Login.ImmsgServReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Im.Login.ImmsgServReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImmsgServReq
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Im.Login.ImmsgServRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImmsgServRsp> {
        var mergedArray = Array<Im.Login.ImmsgServRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImmsgServRsp? {
        return try Im.Login.ImmsgServRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImmsgServRsp {
        return try Im.Login.ImmsgServRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmsgServRsp {
        return try Im.Login.ImmsgServRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImmsgServRsp {
        return try Im.Login.ImmsgServRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmsgServRsp {
        return try Im.Login.ImmsgServRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImmsgServRsp {
        return try Im.Login.ImmsgServRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmsgServRsp {
        return try Im.Login.ImmsgServRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "resultCode": return self.resultCode
        case "priorIp": return self.priorIp
        case "backipIp": return self.backipIp
        case "port": return self.port
        default: return nil
        }
    }
}
extension Im.Login.ImmsgServRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImmsgServRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "resultCode": return self.resultCode
            case "priorIp": return self.priorIp
            case "backipIp": return self.backipIp
            case "port": return self.port
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.ResultType else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "priorIp":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.priorIp = newSubscriptValue
            case "backipIp":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.backipIp = newSubscriptValue
            case "port":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.port = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImloginReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImloginReq> {
        var mergedArray = Array<Im.Login.ImloginReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImloginReq? {
        return try Im.Login.ImloginReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImloginReq {
        return try Im.Login.ImloginReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImloginReq {
        return try Im.Login.ImloginReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImloginReq {
        return try Im.Login.ImloginReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImloginReq {
        return try Im.Login.ImloginReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImloginReq {
        return try Im.Login.ImloginReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImloginReq {
        return try Im.Login.ImloginReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userName": return self.userName
        case "password": return self.password
        case "onlineStatus": return self.onlineStatus
        case "clientType": return self.clientType
        case "clientVersion": return self.clientVersion
        default: return nil
        }
    }
}
extension Im.Login.ImloginReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImloginReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userName": return self.userName
            case "password": return self.password
            case "onlineStatus": return self.onlineStatus
            case "clientType": return self.clientType
            case "clientVersion": return self.clientVersion
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userName = newSubscriptValue
            case "password":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.password = newSubscriptValue
            case "onlineStatus":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.UserStatType else {
                    return
                }
                self.onlineStatus = newSubscriptValue
            case "clientType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.ClientType else {
                    return
                }
                self.clientType = newSubscriptValue
            case "clientVersion":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.clientVersion = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImloginRes: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImloginRes> {
        var mergedArray = Array<Im.Login.ImloginRes>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImloginRes? {
        return try Im.Login.ImloginRes.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImloginRes {
        return try Im.Login.ImloginRes.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImloginRes {
        return try Im.Login.ImloginRes.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImloginRes {
        return try Im.Login.ImloginRes.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImloginRes {
        return try Im.Login.ImloginRes.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImloginRes {
        return try Im.Login.ImloginRes.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImloginRes {
        return try Im.Login.ImloginRes.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "serverTime": return self.serverTime
        case "resultCode": return self.resultCode
        case "resultString": return self.resultString
        case "onlineStatus": return self.onlineStatus
        case "userInfo": return self.userInfo
        default: return nil
        }
    }
}
extension Im.Login.ImloginRes.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImloginRes
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "serverTime": return self.serverTime
            case "resultCode": return self.resultCode
            case "resultString": return self.resultString
            case "onlineStatus": return self.onlineStatus
            case "userInfo": return self.userInfo
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "serverTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.serverTime = newSubscriptValue
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.ResultType else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "resultString":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.resultString = newSubscriptValue
            case "onlineStatus":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.UserStatType else {
                    return
                }
                self.onlineStatus = newSubscriptValue
            case "userInfo":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.UserInfo else {
                    return
                }
                self.userInfo = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImlogoutReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImlogoutReq> {
        var mergedArray = Array<Im.Login.ImlogoutReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImlogoutReq? {
        return try Im.Login.ImlogoutReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImlogoutReq {
        return try Im.Login.ImlogoutReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImlogoutReq {
        return try Im.Login.ImlogoutReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImlogoutReq {
        return try Im.Login.ImlogoutReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImlogoutReq {
        return try Im.Login.ImlogoutReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImlogoutReq {
        return try Im.Login.ImlogoutReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImlogoutReq {
        return try Im.Login.ImlogoutReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Im.Login.ImlogoutReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImlogoutReq
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Im.Login.ImlogoutRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImlogoutRsp> {
        var mergedArray = Array<Im.Login.ImlogoutRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImlogoutRsp? {
        return try Im.Login.ImlogoutRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImlogoutRsp {
        return try Im.Login.ImlogoutRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImlogoutRsp {
        return try Im.Login.ImlogoutRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImlogoutRsp {
        return try Im.Login.ImlogoutRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImlogoutRsp {
        return try Im.Login.ImlogoutRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImlogoutRsp {
        return try Im.Login.ImlogoutRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImlogoutRsp {
        return try Im.Login.ImlogoutRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "resultCode": return self.resultCode
        default: return nil
        }
    }
}
extension Im.Login.ImlogoutRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImlogoutRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "resultCode": return self.resultCode
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImkickUser: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImkickUser> {
        var mergedArray = Array<Im.Login.ImkickUser>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImkickUser? {
        return try Im.Login.ImkickUser.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImkickUser {
        return try Im.Login.ImkickUser.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImkickUser {
        return try Im.Login.ImkickUser.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImkickUser {
        return try Im.Login.ImkickUser.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImkickUser {
        return try Im.Login.ImkickUser.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImkickUser {
        return try Im.Login.ImkickUser.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImkickUser {
        return try Im.Login.ImkickUser.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "kickReason": return self.kickReason
        default: return nil
        }
    }
}
extension Im.Login.ImkickUser.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImkickUser
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "kickReason": return self.kickReason
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "kickReason":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.KickReasonType else {
                    return
                }
                self.kickReason = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImdeviceTokenReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImdeviceTokenReq> {
        var mergedArray = Array<Im.Login.ImdeviceTokenReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImdeviceTokenReq? {
        return try Im.Login.ImdeviceTokenReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImdeviceTokenReq {
        return try Im.Login.ImdeviceTokenReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImdeviceTokenReq {
        return try Im.Login.ImdeviceTokenReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImdeviceTokenReq {
        return try Im.Login.ImdeviceTokenReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImdeviceTokenReq {
        return try Im.Login.ImdeviceTokenReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImdeviceTokenReq {
        return try Im.Login.ImdeviceTokenReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImdeviceTokenReq {
        return try Im.Login.ImdeviceTokenReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "deviceToken": return self.deviceToken
        case "clientType": return self.clientType
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Login.ImdeviceTokenReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImdeviceTokenReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "deviceToken": return self.deviceToken
            case "clientType": return self.clientType
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "deviceToken":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.deviceToken = newSubscriptValue
            case "clientType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.ClientType else {
                    return
                }
                self.clientType = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImdeviceTokenRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImdeviceTokenRsp> {
        var mergedArray = Array<Im.Login.ImdeviceTokenRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImdeviceTokenRsp? {
        return try Im.Login.ImdeviceTokenRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImdeviceTokenRsp {
        return try Im.Login.ImdeviceTokenRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImdeviceTokenRsp {
        return try Im.Login.ImdeviceTokenRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImdeviceTokenRsp {
        return try Im.Login.ImdeviceTokenRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImdeviceTokenRsp {
        return try Im.Login.ImdeviceTokenRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImdeviceTokenRsp {
        return try Im.Login.ImdeviceTokenRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImdeviceTokenRsp {
        return try Im.Login.ImdeviceTokenRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Login.ImdeviceTokenRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImdeviceTokenRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImkickPcclientReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImkickPcclientReq> {
        var mergedArray = Array<Im.Login.ImkickPcclientReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImkickPcclientReq? {
        return try Im.Login.ImkickPcclientReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImkickPcclientReq {
        return try Im.Login.ImkickPcclientReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImkickPcclientReq {
        return try Im.Login.ImkickPcclientReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImkickPcclientReq {
        return try Im.Login.ImkickPcclientReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImkickPcclientReq {
        return try Im.Login.ImkickPcclientReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImkickPcclientReq {
        return try Im.Login.ImkickPcclientReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImkickPcclientReq {
        return try Im.Login.ImkickPcclientReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        default: return nil
        }
    }
}
extension Im.Login.ImkickPcclientReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImkickPcclientReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImkickPcclientRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImkickPcclientRsp> {
        var mergedArray = Array<Im.Login.ImkickPcclientRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImkickPcclientRsp? {
        return try Im.Login.ImkickPcclientRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImkickPcclientRsp {
        return try Im.Login.ImkickPcclientRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImkickPcclientRsp {
        return try Im.Login.ImkickPcclientRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImkickPcclientRsp {
        return try Im.Login.ImkickPcclientRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImkickPcclientRsp {
        return try Im.Login.ImkickPcclientRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImkickPcclientRsp {
        return try Im.Login.ImkickPcclientRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImkickPcclientRsp {
        return try Im.Login.ImkickPcclientRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "resultCode": return self.resultCode
        default: return nil
        }
    }
}
extension Im.Login.ImkickPcclientRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImkickPcclientRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "resultCode": return self.resultCode
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImpushShieldReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImpushShieldReq> {
        var mergedArray = Array<Im.Login.ImpushShieldReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImpushShieldReq? {
        return try Im.Login.ImpushShieldReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImpushShieldReq {
        return try Im.Login.ImpushShieldReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImpushShieldReq {
        return try Im.Login.ImpushShieldReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImpushShieldReq {
        return try Im.Login.ImpushShieldReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImpushShieldReq {
        return try Im.Login.ImpushShieldReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImpushShieldReq {
        return try Im.Login.ImpushShieldReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImpushShieldReq {
        return try Im.Login.ImpushShieldReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "shieldStatus": return self.shieldStatus
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Login.ImpushShieldReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImpushShieldReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "shieldStatus": return self.shieldStatus
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "shieldStatus":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.shieldStatus = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImpushShieldRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImpushShieldRsp> {
        var mergedArray = Array<Im.Login.ImpushShieldRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImpushShieldRsp? {
        return try Im.Login.ImpushShieldRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImpushShieldRsp {
        return try Im.Login.ImpushShieldRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImpushShieldRsp {
        return try Im.Login.ImpushShieldRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImpushShieldRsp {
        return try Im.Login.ImpushShieldRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImpushShieldRsp {
        return try Im.Login.ImpushShieldRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImpushShieldRsp {
        return try Im.Login.ImpushShieldRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImpushShieldRsp {
        return try Im.Login.ImpushShieldRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "resultCode": return self.resultCode
        case "shieldStatus": return self.shieldStatus
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Login.ImpushShieldRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImpushShieldRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "resultCode": return self.resultCode
            case "shieldStatus": return self.shieldStatus
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "shieldStatus":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.shieldStatus = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImqueryPushShieldReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImqueryPushShieldReq> {
        var mergedArray = Array<Im.Login.ImqueryPushShieldReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImqueryPushShieldReq? {
        return try Im.Login.ImqueryPushShieldReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImqueryPushShieldReq {
        return try Im.Login.ImqueryPushShieldReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImqueryPushShieldReq {
        return try Im.Login.ImqueryPushShieldReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImqueryPushShieldReq {
        return try Im.Login.ImqueryPushShieldReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImqueryPushShieldReq {
        return try Im.Login.ImqueryPushShieldReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImqueryPushShieldReq {
        return try Im.Login.ImqueryPushShieldReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImqueryPushShieldReq {
        return try Im.Login.ImqueryPushShieldReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Login.ImqueryPushShieldReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImqueryPushShieldReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImqueryPushShieldRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImqueryPushShieldRsp> {
        var mergedArray = Array<Im.Login.ImqueryPushShieldRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImqueryPushShieldRsp? {
        return try Im.Login.ImqueryPushShieldRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImqueryPushShieldRsp {
        return try Im.Login.ImqueryPushShieldRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImqueryPushShieldRsp {
        return try Im.Login.ImqueryPushShieldRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImqueryPushShieldRsp {
        return try Im.Login.ImqueryPushShieldRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImqueryPushShieldRsp {
        return try Im.Login.ImqueryPushShieldRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImqueryPushShieldRsp {
        return try Im.Login.ImqueryPushShieldRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImqueryPushShieldRsp {
        return try Im.Login.ImqueryPushShieldRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "resultCode": return self.resultCode
        case "shieldStatus": return self.shieldStatus
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Login.ImqueryPushShieldRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImqueryPushShieldRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "resultCode": return self.resultCode
            case "shieldStatus": return self.shieldStatus
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "shieldStatus":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.shieldStatus = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImmodifyPassReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImmodifyPassReq> {
        var mergedArray = Array<Im.Login.ImmodifyPassReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImmodifyPassReq? {
        return try Im.Login.ImmodifyPassReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImmodifyPassReq {
        return try Im.Login.ImmodifyPassReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmodifyPassReq {
        return try Im.Login.ImmodifyPassReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImmodifyPassReq {
        return try Im.Login.ImmodifyPassReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmodifyPassReq {
        return try Im.Login.ImmodifyPassReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImmodifyPassReq {
        return try Im.Login.ImmodifyPassReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmodifyPassReq {
        return try Im.Login.ImmodifyPassReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "oldPass": return self.oldPass
        case "newPass": return self.newPass
        case "cfmPass": return self.cfmPass
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Login.ImmodifyPassReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImmodifyPassReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "oldPass": return self.oldPass
            case "newPass": return self.newPass
            case "cfmPass": return self.cfmPass
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "oldPass":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.oldPass = newSubscriptValue
            case "newPass":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.newPass = newSubscriptValue
            case "cfmPass":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.cfmPass = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Login.ImmodifyPassRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Login.ImmodifyPassRsp> {
        var mergedArray = Array<Im.Login.ImmodifyPassRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Login.ImmodifyPassRsp? {
        return try Im.Login.ImmodifyPassRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Login.ImmodifyPassRsp {
        return try Im.Login.ImmodifyPassRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Login.ImloginRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmodifyPassRsp {
        return try Im.Login.ImmodifyPassRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Login.ImmodifyPassRsp {
        return try Im.Login.ImmodifyPassRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmodifyPassRsp {
        return try Im.Login.ImmodifyPassRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Login.ImmodifyPassRsp {
        return try Im.Login.ImmodifyPassRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Login.ImmodifyPassRsp {
        return try Im.Login.ImmodifyPassRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "status": return self.status
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Login.ImmodifyPassRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Login.ImmodifyPassRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "status": return self.status
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "status":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.status = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
