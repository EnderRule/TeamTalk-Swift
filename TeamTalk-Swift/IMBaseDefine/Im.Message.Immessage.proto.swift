/// Generated by the Protocol Buffers 3.3.2 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "IM.Message.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers

public extension Im {
    public struct Message {}
}

public extension Im.Message {
    public struct ImmessageRoot {
        public static let `default` = ImmessageRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Im.BaseDefine.ImbaseDefineRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    ///service id  0x0003
    final public class ImmsgData : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImmsgData.Builder

        public static func == (lhs: Im.Message.ImmsgData, rhs: Im.Message.ImmsgData) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFromUserId == rhs.hasFromUserId) && (!lhs.hasFromUserId || lhs.fromUserId == rhs.fromUserId)
            fieldCheck = fieldCheck && (lhs.hasToSessionId == rhs.hasToSessionId) && (!lhs.hasToSessionId || lhs.toSessionId == rhs.toSessionId)
            fieldCheck = fieldCheck && (lhs.hasMsgId == rhs.hasMsgId) && (!lhs.hasMsgId || lhs.msgId == rhs.msgId)
            fieldCheck = fieldCheck && (lhs.hasCreateTime == rhs.hasCreateTime) && (!lhs.hasCreateTime || lhs.createTime == rhs.createTime)
            fieldCheck = fieldCheck && (lhs.hasMsgType == rhs.hasMsgType) && (!lhs.hasMsgType || lhs.msgType == rhs.msgType)
            fieldCheck = fieldCheck && (lhs.hasMsgData == rhs.hasMsgData) && (!lhs.hasMsgData || lhs.msgData == rhs.msgData)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x0301
        public fileprivate(set) var fromUserId:UInt32! = nil
        public fileprivate(set) var hasFromUserId:Bool = false

        ///消息接受方
        public fileprivate(set) var toSessionId:UInt32! = nil
        public fileprivate(set) var hasToSessionId:Bool = false

        public fileprivate(set) var msgId:UInt32! = nil
        public fileprivate(set) var hasMsgId:Bool = false

        public fileprivate(set) var createTime:UInt32! = nil
        public fileprivate(set) var hasCreateTime:Bool = false

        public fileprivate(set) var msgType:Im.BaseDefine.MsgType = Im.BaseDefine.MsgType.msgTypeSingleText
        public fileprivate(set) var hasMsgType:Bool = false
        public fileprivate(set) var msgData:Data! = nil
        public fileprivate(set) var hasMsgData:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasFromUserId {
                return false
            }
            if !hasToSessionId {
                return false
            }
            if !hasMsgId {
                return false
            }
            if !hasCreateTime {
                return false
            }
            if !hasMsgType {
                return false
            }
            if !hasMsgData {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFromUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:fromUserId)
            }
            if hasToSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:toSessionId)
            }
            if hasMsgId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:msgId)
            }
            if hasCreateTime {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:createTime)
            }
            if hasMsgType {
                try codedOutputStream.writeEnum(fieldNumber: 5, value:msgType.rawValue)
            }
            if hasMsgData {
                try codedOutputStream.writeData(fieldNumber: 6, value:msgData)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFromUserId {
                serialize_size += fromUserId.computeUInt32Size(fieldNumber: 1)
            }
            if hasToSessionId {
                serialize_size += toSessionId.computeUInt32Size(fieldNumber: 2)
            }
            if hasMsgId {
                serialize_size += msgId.computeUInt32Size(fieldNumber: 3)
            }
            if hasCreateTime {
                serialize_size += createTime.computeUInt32Size(fieldNumber: 4)
            }
            if (hasMsgType) {
                serialize_size += msgType.rawValue.computeEnumSize(fieldNumber: 5)
            }
            if hasMsgData {
                serialize_size += msgData.computeDataSize(fieldNumber: 6)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImmsgData.Builder {
            return Im.Message.ImmsgData.classBuilder() as! Im.Message.ImmsgData.Builder
        }
        public func getBuilder() -> Im.Message.ImmsgData.Builder {
            return classBuilder() as! Im.Message.ImmsgData.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImmsgData.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImmsgData.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImmsgData.Builder {
            return try Im.Message.ImmsgData.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImmsgData) throws -> Im.Message.ImmsgData.Builder {
            return try Im.Message.ImmsgData.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFromUserId {
                jsonMap["fromUserId"] = UInt(fromUserId)
            }
            if hasToSessionId {
                jsonMap["toSessionId"] = UInt(toSessionId)
            }
            if hasMsgId {
                jsonMap["msgId"] = UInt(msgId)
            }
            if hasCreateTime {
                jsonMap["createTime"] = UInt(createTime)
            }
            if hasMsgType {
                jsonMap["msgType"] = msgType.toString()
            }
            if hasMsgData {
                jsonMap["msgData"] = msgData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImmsgData {
            return try Im.Message.ImmsgData.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImmsgData {
            return try Im.Message.ImmsgData.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFromUserId {
                output += "\(indent) fromUserId: \(fromUserId) \n"
            }
            if hasToSessionId {
                output += "\(indent) toSessionId: \(toSessionId) \n"
            }
            if hasMsgId {
                output += "\(indent) msgId: \(msgId) \n"
            }
            if hasCreateTime {
                output += "\(indent) createTime: \(createTime) \n"
            }
            if (hasMsgType) {
                output += "\(indent) msgType: \(msgType.description)\n"
            }
            if hasMsgData {
                output += "\(indent) msgData: \(msgData) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFromUserId {
                    hashCode = (hashCode &* 31) &+ fromUserId.hashValue
                }
                if hasToSessionId {
                    hashCode = (hashCode &* 31) &+ toSessionId.hashValue
                }
                if hasMsgId {
                    hashCode = (hashCode &* 31) &+ msgId.hashValue
                }
                if hasCreateTime {
                    hashCode = (hashCode &* 31) &+ createTime.hashValue
                }
                if hasMsgType {
                     hashCode = (hashCode &* 31) &+ msgType.hashValue
                }
                if hasMsgData {
                    hashCode = (hashCode &* 31) &+ msgData.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImmsgData"
        }
        override public func className() -> String {
            return "Im.Message.ImmsgData"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImmsgData = Im.Message.ImmsgData()
            public func getMessage() -> Im.Message.ImmsgData {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0301
            public var fromUserId:UInt32 {
                get {
                    return builderResult.fromUserId
                }
                set (value) {
                    builderResult.hasFromUserId = true
                    builderResult.fromUserId = value
                }
            }
            public var hasFromUserId:Bool {
                get {
                    return builderResult.hasFromUserId
                }
            }
            @discardableResult
            public func setFromUserId(_ value:UInt32) -> Im.Message.ImmsgData.Builder {
                self.fromUserId = value
                return self
            }
            @discardableResult
            public func clearFromUserId() -> Im.Message.ImmsgData.Builder{
                builderResult.hasFromUserId = false
                builderResult.fromUserId = nil
                return self
            }
            ///消息接受方
            public var toSessionId:UInt32 {
                get {
                    return builderResult.toSessionId
                }
                set (value) {
                    builderResult.hasToSessionId = true
                    builderResult.toSessionId = value
                }
            }
            public var hasToSessionId:Bool {
                get {
                    return builderResult.hasToSessionId
                }
            }
            @discardableResult
            public func setToSessionId(_ value:UInt32) -> Im.Message.ImmsgData.Builder {
                self.toSessionId = value
                return self
            }
            @discardableResult
            public func clearToSessionId() -> Im.Message.ImmsgData.Builder{
                builderResult.hasToSessionId = false
                builderResult.toSessionId = nil
                return self
            }
            public var msgId:UInt32 {
                get {
                    return builderResult.msgId
                }
                set (value) {
                    builderResult.hasMsgId = true
                    builderResult.msgId = value
                }
            }
            public var hasMsgId:Bool {
                get {
                    return builderResult.hasMsgId
                }
            }
            @discardableResult
            public func setMsgId(_ value:UInt32) -> Im.Message.ImmsgData.Builder {
                self.msgId = value
                return self
            }
            @discardableResult
            public func clearMsgId() -> Im.Message.ImmsgData.Builder{
                builderResult.hasMsgId = false
                builderResult.msgId = nil
                return self
            }
            public var createTime:UInt32 {
                get {
                    return builderResult.createTime
                }
                set (value) {
                    builderResult.hasCreateTime = true
                    builderResult.createTime = value
                }
            }
            public var hasCreateTime:Bool {
                get {
                    return builderResult.hasCreateTime
                }
            }
            @discardableResult
            public func setCreateTime(_ value:UInt32) -> Im.Message.ImmsgData.Builder {
                self.createTime = value
                return self
            }
            @discardableResult
            public func clearCreateTime() -> Im.Message.ImmsgData.Builder{
                builderResult.hasCreateTime = false
                builderResult.createTime = nil
                return self
            }
                public var msgType:Im.BaseDefine.MsgType {
                    get {
                        return builderResult.msgType
                    }
                    set (value) {
                        builderResult.hasMsgType = true
                        builderResult.msgType = value
                    }
                }
                public var hasMsgType:Bool{
                    get {
                        return builderResult.hasMsgType
                    }
                }
            @discardableResult
                public func setMsgType(_ value:Im.BaseDefine.MsgType) -> Im.Message.ImmsgData.Builder {
                  self.msgType = value
                  return self
                }
            @discardableResult
                public func clearMsgType() -> Im.Message.ImmsgData.Builder {
                   builderResult.hasMsgType = false
                   builderResult.msgType = .msgTypeSingleText
                   return self
                }
            public var msgData:Data {
                get {
                    return builderResult.msgData
                }
                set (value) {
                    builderResult.hasMsgData = true
                    builderResult.msgData = value
                }
            }
            public var hasMsgData:Bool {
                get {
                    return builderResult.hasMsgData
                }
            }
            @discardableResult
            public func setMsgData(_ value:Data) -> Im.Message.ImmsgData.Builder {
                self.msgData = value
                return self
            }
            @discardableResult
            public func clearMsgData() -> Im.Message.ImmsgData.Builder{
                builderResult.hasMsgData = false
                builderResult.msgData = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Message.ImmsgData.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Message.ImmsgData.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImmsgData.Builder {
                builderResult = Im.Message.ImmsgData()
                return self
            }
            override public func clone() throws -> Im.Message.ImmsgData.Builder {
                return try Im.Message.ImmsgData.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImmsgData {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImmsgData {
                let returnMe:Im.Message.ImmsgData = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImmsgData) throws -> Im.Message.ImmsgData.Builder {
                if other == Im.Message.ImmsgData() {
                    return self
                }
                if other.hasFromUserId {
                    fromUserId = other.fromUserId
                }
                if other.hasToSessionId {
                    toSessionId = other.toSessionId
                }
                if other.hasMsgId {
                    msgId = other.msgId
                }
                if other.hasCreateTime {
                    createTime = other.createTime
                }
                if other.hasMsgType {
                    msgType = other.msgType
                }
                if other.hasMsgData {
                    msgData = other.msgData
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImmsgData.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgData.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        fromUserId = try codedInputStream.readUInt32()

                    case 16:
                        toSessionId = try codedInputStream.readUInt32()

                    case 24:
                        msgId = try codedInputStream.readUInt32()

                    case 32:
                        createTime = try codedInputStream.readUInt32()

                    case 40:
                        let valueIntmsgType = try codedInputStream.readEnum()
                        if let enumsmsgType = Im.BaseDefine.MsgType(rawValue:valueIntmsgType){
                            msgType = enumsmsgType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueIntmsgType))
                        }

                    case 50:
                        msgData = try codedInputStream.readData()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImmsgData.Builder {
                let resultDecodedBuilder = Im.Message.ImmsgData.Builder()
                if let jsonValueFromUserId = jsonMap["fromUserId"] as? UInt {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)
                } else if let jsonValueFromUserId = jsonMap["fromUserId"] as? String {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)!
                }
                if let jsonValueToSessionId = jsonMap["toSessionId"] as? UInt {
                    resultDecodedBuilder.toSessionId = UInt32(jsonValueToSessionId)
                } else if let jsonValueToSessionId = jsonMap["toSessionId"] as? String {
                    resultDecodedBuilder.toSessionId = UInt32(jsonValueToSessionId)!
                }
                if let jsonValueMsgId = jsonMap["msgId"] as? UInt {
                    resultDecodedBuilder.msgId = UInt32(jsonValueMsgId)
                } else if let jsonValueMsgId = jsonMap["msgId"] as? String {
                    resultDecodedBuilder.msgId = UInt32(jsonValueMsgId)!
                }
                if let jsonValueCreateTime = jsonMap["createTime"] as? UInt {
                    resultDecodedBuilder.createTime = UInt32(jsonValueCreateTime)
                } else if let jsonValueCreateTime = jsonMap["createTime"] as? String {
                    resultDecodedBuilder.createTime = UInt32(jsonValueCreateTime)!
                }
                if let jsonValueMsgType = jsonMap["msgType"] as? String {
                    resultDecodedBuilder.msgType = try Im.BaseDefine.MsgType.fromString(jsonValueMsgType)
                }
                if let jsonValueMsgData = jsonMap["msgData"] as? String {
                    resultDecodedBuilder.msgData = Data(base64Encoded:jsonValueMsgData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImmsgData.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImmsgData.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImmsgDataAck : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImmsgDataAck.Builder

        public static func == (lhs: Im.Message.ImmsgDataAck, rhs: Im.Message.ImmsgDataAck) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = fieldCheck && (lhs.hasMsgId == rhs.hasMsgId) && (!lhs.hasMsgId || lhs.msgId == rhs.msgId)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x0302
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        public fileprivate(set) var msgId:UInt32! = nil
        public fileprivate(set) var hasMsgId:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasSessionId {
                return false
            }
            if !hasMsgId {
                return false
            }
            if !hasSessionType {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:sessionId)
            }
            if hasMsgId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:msgId)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 4, value:sessionType.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 2)
            }
            if hasMsgId {
                serialize_size += msgId.computeUInt32Size(fieldNumber: 3)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImmsgDataAck.Builder {
            return Im.Message.ImmsgDataAck.classBuilder() as! Im.Message.ImmsgDataAck.Builder
        }
        public func getBuilder() -> Im.Message.ImmsgDataAck.Builder {
            return classBuilder() as! Im.Message.ImmsgDataAck.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImmsgDataAck.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImmsgDataAck.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImmsgDataAck.Builder {
            return try Im.Message.ImmsgDataAck.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImmsgDataAck) throws -> Im.Message.ImmsgDataAck.Builder {
            return try Im.Message.ImmsgDataAck.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            if hasMsgId {
                jsonMap["msgId"] = UInt(msgId)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImmsgDataAck {
            return try Im.Message.ImmsgDataAck.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImmsgDataAck {
            return try Im.Message.ImmsgDataAck.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            if hasMsgId {
                output += "\(indent) msgId: \(msgId) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                if hasMsgId {
                    hashCode = (hashCode &* 31) &+ msgId.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImmsgDataAck"
        }
        override public func className() -> String {
            return "Im.Message.ImmsgDataAck"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImmsgDataAck = Im.Message.ImmsgDataAck()
            public func getMessage() -> Im.Message.ImmsgDataAck {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0302
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Message.ImmsgDataAck.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Message.ImmsgDataAck.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.Message.ImmsgDataAck.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.Message.ImmsgDataAck.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
            public var msgId:UInt32 {
                get {
                    return builderResult.msgId
                }
                set (value) {
                    builderResult.hasMsgId = true
                    builderResult.msgId = value
                }
            }
            public var hasMsgId:Bool {
                get {
                    return builderResult.hasMsgId
                }
            }
            @discardableResult
            public func setMsgId(_ value:UInt32) -> Im.Message.ImmsgDataAck.Builder {
                self.msgId = value
                return self
            }
            @discardableResult
            public func clearMsgId() -> Im.Message.ImmsgDataAck.Builder{
                builderResult.hasMsgId = false
                builderResult.msgId = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.Message.ImmsgDataAck.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.Message.ImmsgDataAck.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImmsgDataAck.Builder {
                builderResult = Im.Message.ImmsgDataAck()
                return self
            }
            override public func clone() throws -> Im.Message.ImmsgDataAck.Builder {
                return try Im.Message.ImmsgDataAck.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImmsgDataAck {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImmsgDataAck {
                let returnMe:Im.Message.ImmsgDataAck = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImmsgDataAck) throws -> Im.Message.ImmsgDataAck.Builder {
                if other == Im.Message.ImmsgDataAck() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                if other.hasMsgId {
                    msgId = other.msgId
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImmsgDataAck.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgDataAck.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        sessionId = try codedInputStream.readUInt32()

                    case 24:
                        msgId = try codedInputStream.readUInt32()

                    case 32:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntsessionType))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImmsgDataAck.Builder {
                let resultDecodedBuilder = Im.Message.ImmsgDataAck.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                if let jsonValueMsgId = jsonMap["msgId"] as? UInt {
                    resultDecodedBuilder.msgId = UInt32(jsonValueMsgId)
                } else if let jsonValueMsgId = jsonMap["msgId"] as? String {
                    resultDecodedBuilder.msgId = UInt32(jsonValueMsgId)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImmsgDataAck.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImmsgDataAck.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImmsgDataReadAck : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImmsgDataReadAck.Builder

        public static func == (lhs: Im.Message.ImmsgDataReadAck, rhs: Im.Message.ImmsgDataReadAck) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = fieldCheck && (lhs.hasMsgId == rhs.hasMsgId) && (!lhs.hasMsgId || lhs.msgId == rhs.msgId)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x0303
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        public fileprivate(set) var msgId:UInt32! = nil
        public fileprivate(set) var hasMsgId:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasSessionId {
                return false
            }
            if !hasMsgId {
                return false
            }
            if !hasSessionType {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:sessionId)
            }
            if hasMsgId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:msgId)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 4, value:sessionType.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 2)
            }
            if hasMsgId {
                serialize_size += msgId.computeUInt32Size(fieldNumber: 3)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImmsgDataReadAck.Builder {
            return Im.Message.ImmsgDataReadAck.classBuilder() as! Im.Message.ImmsgDataReadAck.Builder
        }
        public func getBuilder() -> Im.Message.ImmsgDataReadAck.Builder {
            return classBuilder() as! Im.Message.ImmsgDataReadAck.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImmsgDataReadAck.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImmsgDataReadAck.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImmsgDataReadAck.Builder {
            return try Im.Message.ImmsgDataReadAck.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImmsgDataReadAck) throws -> Im.Message.ImmsgDataReadAck.Builder {
            return try Im.Message.ImmsgDataReadAck.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            if hasMsgId {
                jsonMap["msgId"] = UInt(msgId)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImmsgDataReadAck {
            return try Im.Message.ImmsgDataReadAck.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImmsgDataReadAck {
            return try Im.Message.ImmsgDataReadAck.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            if hasMsgId {
                output += "\(indent) msgId: \(msgId) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                if hasMsgId {
                    hashCode = (hashCode &* 31) &+ msgId.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImmsgDataReadAck"
        }
        override public func className() -> String {
            return "Im.Message.ImmsgDataReadAck"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImmsgDataReadAck = Im.Message.ImmsgDataReadAck()
            public func getMessage() -> Im.Message.ImmsgDataReadAck {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0303
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Message.ImmsgDataReadAck.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Message.ImmsgDataReadAck.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.Message.ImmsgDataReadAck.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.Message.ImmsgDataReadAck.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
            public var msgId:UInt32 {
                get {
                    return builderResult.msgId
                }
                set (value) {
                    builderResult.hasMsgId = true
                    builderResult.msgId = value
                }
            }
            public var hasMsgId:Bool {
                get {
                    return builderResult.hasMsgId
                }
            }
            @discardableResult
            public func setMsgId(_ value:UInt32) -> Im.Message.ImmsgDataReadAck.Builder {
                self.msgId = value
                return self
            }
            @discardableResult
            public func clearMsgId() -> Im.Message.ImmsgDataReadAck.Builder{
                builderResult.hasMsgId = false
                builderResult.msgId = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.Message.ImmsgDataReadAck.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.Message.ImmsgDataReadAck.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImmsgDataReadAck.Builder {
                builderResult = Im.Message.ImmsgDataReadAck()
                return self
            }
            override public func clone() throws -> Im.Message.ImmsgDataReadAck.Builder {
                return try Im.Message.ImmsgDataReadAck.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImmsgDataReadAck {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImmsgDataReadAck {
                let returnMe:Im.Message.ImmsgDataReadAck = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImmsgDataReadAck) throws -> Im.Message.ImmsgDataReadAck.Builder {
                if other == Im.Message.ImmsgDataReadAck() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                if other.hasMsgId {
                    msgId = other.msgId
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImmsgDataReadAck.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgDataReadAck.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        sessionId = try codedInputStream.readUInt32()

                    case 24:
                        msgId = try codedInputStream.readUInt32()

                    case 32:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntsessionType))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImmsgDataReadAck.Builder {
                let resultDecodedBuilder = Im.Message.ImmsgDataReadAck.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                if let jsonValueMsgId = jsonMap["msgId"] as? UInt {
                    resultDecodedBuilder.msgId = UInt32(jsonValueMsgId)
                } else if let jsonValueMsgId = jsonMap["msgId"] as? String {
                    resultDecodedBuilder.msgId = UInt32(jsonValueMsgId)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImmsgDataReadAck.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImmsgDataReadAck.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImmsgDataReadNotify : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImmsgDataReadNotify.Builder

        public static func == (lhs: Im.Message.ImmsgDataReadNotify, rhs: Im.Message.ImmsgDataReadNotify) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = fieldCheck && (lhs.hasMsgId == rhs.hasMsgId) && (!lhs.hasMsgId || lhs.msgId == rhs.msgId)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x0304
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        public fileprivate(set) var msgId:UInt32! = nil
        public fileprivate(set) var hasMsgId:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasSessionId {
                return false
            }
            if !hasMsgId {
                return false
            }
            if !hasSessionType {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:sessionId)
            }
            if hasMsgId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:msgId)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 4, value:sessionType.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 2)
            }
            if hasMsgId {
                serialize_size += msgId.computeUInt32Size(fieldNumber: 3)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImmsgDataReadNotify.Builder {
            return Im.Message.ImmsgDataReadNotify.classBuilder() as! Im.Message.ImmsgDataReadNotify.Builder
        }
        public func getBuilder() -> Im.Message.ImmsgDataReadNotify.Builder {
            return classBuilder() as! Im.Message.ImmsgDataReadNotify.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImmsgDataReadNotify.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImmsgDataReadNotify.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImmsgDataReadNotify.Builder {
            return try Im.Message.ImmsgDataReadNotify.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImmsgDataReadNotify) throws -> Im.Message.ImmsgDataReadNotify.Builder {
            return try Im.Message.ImmsgDataReadNotify.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            if hasMsgId {
                jsonMap["msgId"] = UInt(msgId)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImmsgDataReadNotify {
            return try Im.Message.ImmsgDataReadNotify.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImmsgDataReadNotify {
            return try Im.Message.ImmsgDataReadNotify.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            if hasMsgId {
                output += "\(indent) msgId: \(msgId) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                if hasMsgId {
                    hashCode = (hashCode &* 31) &+ msgId.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImmsgDataReadNotify"
        }
        override public func className() -> String {
            return "Im.Message.ImmsgDataReadNotify"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImmsgDataReadNotify = Im.Message.ImmsgDataReadNotify()
            public func getMessage() -> Im.Message.ImmsgDataReadNotify {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0304
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Message.ImmsgDataReadNotify.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Message.ImmsgDataReadNotify.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.Message.ImmsgDataReadNotify.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.Message.ImmsgDataReadNotify.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
            public var msgId:UInt32 {
                get {
                    return builderResult.msgId
                }
                set (value) {
                    builderResult.hasMsgId = true
                    builderResult.msgId = value
                }
            }
            public var hasMsgId:Bool {
                get {
                    return builderResult.hasMsgId
                }
            }
            @discardableResult
            public func setMsgId(_ value:UInt32) -> Im.Message.ImmsgDataReadNotify.Builder {
                self.msgId = value
                return self
            }
            @discardableResult
            public func clearMsgId() -> Im.Message.ImmsgDataReadNotify.Builder{
                builderResult.hasMsgId = false
                builderResult.msgId = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.Message.ImmsgDataReadNotify.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.Message.ImmsgDataReadNotify.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImmsgDataReadNotify.Builder {
                builderResult = Im.Message.ImmsgDataReadNotify()
                return self
            }
            override public func clone() throws -> Im.Message.ImmsgDataReadNotify.Builder {
                return try Im.Message.ImmsgDataReadNotify.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImmsgDataReadNotify {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImmsgDataReadNotify {
                let returnMe:Im.Message.ImmsgDataReadNotify = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImmsgDataReadNotify) throws -> Im.Message.ImmsgDataReadNotify.Builder {
                if other == Im.Message.ImmsgDataReadNotify() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                if other.hasMsgId {
                    msgId = other.msgId
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImmsgDataReadNotify.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgDataReadNotify.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        sessionId = try codedInputStream.readUInt32()

                    case 24:
                        msgId = try codedInputStream.readUInt32()

                    case 32:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntsessionType))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImmsgDataReadNotify.Builder {
                let resultDecodedBuilder = Im.Message.ImmsgDataReadNotify.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                if let jsonValueMsgId = jsonMap["msgId"] as? UInt {
                    resultDecodedBuilder.msgId = UInt32(jsonValueMsgId)
                } else if let jsonValueMsgId = jsonMap["msgId"] as? String {
                    resultDecodedBuilder.msgId = UInt32(jsonValueMsgId)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImmsgDataReadNotify.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImmsgDataReadNotify.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///cmd id:		0x0305
    final public class ImclientTimeReq : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImclientTimeReq.Builder

        public static func == (lhs: Im.Message.ImclientTimeReq, rhs: Im.Message.ImclientTimeReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImclientTimeReq.Builder {
            return Im.Message.ImclientTimeReq.classBuilder() as! Im.Message.ImclientTimeReq.Builder
        }
        public func getBuilder() -> Im.Message.ImclientTimeReq.Builder {
            return classBuilder() as! Im.Message.ImclientTimeReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImclientTimeReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImclientTimeReq.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImclientTimeReq.Builder {
            return try Im.Message.ImclientTimeReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImclientTimeReq) throws -> Im.Message.ImclientTimeReq.Builder {
            return try Im.Message.ImclientTimeReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImclientTimeReq {
            return try Im.Message.ImclientTimeReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImclientTimeReq {
            return try Im.Message.ImclientTimeReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImclientTimeReq"
        }
        override public func className() -> String {
            return "Im.Message.ImclientTimeReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImclientTimeReq = Im.Message.ImclientTimeReq()
            public func getMessage() -> Im.Message.ImclientTimeReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImclientTimeReq.Builder {
                builderResult = Im.Message.ImclientTimeReq()
                return self
            }
            override public func clone() throws -> Im.Message.ImclientTimeReq.Builder {
                return try Im.Message.ImclientTimeReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImclientTimeReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImclientTimeReq {
                let returnMe:Im.Message.ImclientTimeReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImclientTimeReq) throws -> Im.Message.ImclientTimeReq.Builder {
                if other == Im.Message.ImclientTimeReq() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImclientTimeReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImclientTimeReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImclientTimeReq.Builder {
                let resultDecodedBuilder = Im.Message.ImclientTimeReq.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImclientTimeReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImclientTimeReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImclientTimeRsp : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImclientTimeRsp.Builder

        public static func == (lhs: Im.Message.ImclientTimeRsp, rhs: Im.Message.ImclientTimeRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasServerTime == rhs.hasServerTime) && (!lhs.hasServerTime || lhs.serverTime == rhs.serverTime)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x0306
        public fileprivate(set) var serverTime:UInt32! = nil
        public fileprivate(set) var hasServerTime:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasServerTime {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasServerTime {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:serverTime)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasServerTime {
                serialize_size += serverTime.computeUInt32Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImclientTimeRsp.Builder {
            return Im.Message.ImclientTimeRsp.classBuilder() as! Im.Message.ImclientTimeRsp.Builder
        }
        public func getBuilder() -> Im.Message.ImclientTimeRsp.Builder {
            return classBuilder() as! Im.Message.ImclientTimeRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImclientTimeRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImclientTimeRsp.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImclientTimeRsp.Builder {
            return try Im.Message.ImclientTimeRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImclientTimeRsp) throws -> Im.Message.ImclientTimeRsp.Builder {
            return try Im.Message.ImclientTimeRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasServerTime {
                jsonMap["serverTime"] = UInt(serverTime)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImclientTimeRsp {
            return try Im.Message.ImclientTimeRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImclientTimeRsp {
            return try Im.Message.ImclientTimeRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasServerTime {
                output += "\(indent) serverTime: \(serverTime) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasServerTime {
                    hashCode = (hashCode &* 31) &+ serverTime.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImclientTimeRsp"
        }
        override public func className() -> String {
            return "Im.Message.ImclientTimeRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImclientTimeRsp = Im.Message.ImclientTimeRsp()
            public func getMessage() -> Im.Message.ImclientTimeRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0306
            public var serverTime:UInt32 {
                get {
                    return builderResult.serverTime
                }
                set (value) {
                    builderResult.hasServerTime = true
                    builderResult.serverTime = value
                }
            }
            public var hasServerTime:Bool {
                get {
                    return builderResult.hasServerTime
                }
            }
            @discardableResult
            public func setServerTime(_ value:UInt32) -> Im.Message.ImclientTimeRsp.Builder {
                self.serverTime = value
                return self
            }
            @discardableResult
            public func clearServerTime() -> Im.Message.ImclientTimeRsp.Builder{
                builderResult.hasServerTime = false
                builderResult.serverTime = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImclientTimeRsp.Builder {
                builderResult = Im.Message.ImclientTimeRsp()
                return self
            }
            override public func clone() throws -> Im.Message.ImclientTimeRsp.Builder {
                return try Im.Message.ImclientTimeRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImclientTimeRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImclientTimeRsp {
                let returnMe:Im.Message.ImclientTimeRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImclientTimeRsp) throws -> Im.Message.ImclientTimeRsp.Builder {
                if other == Im.Message.ImclientTimeRsp() {
                    return self
                }
                if other.hasServerTime {
                    serverTime = other.serverTime
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImclientTimeRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImclientTimeRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        serverTime = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImclientTimeRsp.Builder {
                let resultDecodedBuilder = Im.Message.ImclientTimeRsp.Builder()
                if let jsonValueServerTime = jsonMap["serverTime"] as? UInt {
                    resultDecodedBuilder.serverTime = UInt32(jsonValueServerTime)
                } else if let jsonValueServerTime = jsonMap["serverTime"] as? String {
                    resultDecodedBuilder.serverTime = UInt32(jsonValueServerTime)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImclientTimeRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImclientTimeRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImunreadMsgCntReq : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImunreadMsgCntReq.Builder

        public static func == (lhs: Im.Message.ImunreadMsgCntReq, rhs: Im.Message.ImunreadMsgCntReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x0307
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImunreadMsgCntReq.Builder {
            return Im.Message.ImunreadMsgCntReq.classBuilder() as! Im.Message.ImunreadMsgCntReq.Builder
        }
        public func getBuilder() -> Im.Message.ImunreadMsgCntReq.Builder {
            return classBuilder() as! Im.Message.ImunreadMsgCntReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImunreadMsgCntReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImunreadMsgCntReq.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImunreadMsgCntReq.Builder {
            return try Im.Message.ImunreadMsgCntReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImunreadMsgCntReq) throws -> Im.Message.ImunreadMsgCntReq.Builder {
            return try Im.Message.ImunreadMsgCntReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImunreadMsgCntReq {
            return try Im.Message.ImunreadMsgCntReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImunreadMsgCntReq {
            return try Im.Message.ImunreadMsgCntReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImunreadMsgCntReq"
        }
        override public func className() -> String {
            return "Im.Message.ImunreadMsgCntReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImunreadMsgCntReq = Im.Message.ImunreadMsgCntReq()
            public func getMessage() -> Im.Message.ImunreadMsgCntReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0307
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Message.ImunreadMsgCntReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Message.ImunreadMsgCntReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Message.ImunreadMsgCntReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Message.ImunreadMsgCntReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImunreadMsgCntReq.Builder {
                builderResult = Im.Message.ImunreadMsgCntReq()
                return self
            }
            override public func clone() throws -> Im.Message.ImunreadMsgCntReq.Builder {
                return try Im.Message.ImunreadMsgCntReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImunreadMsgCntReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImunreadMsgCntReq {
                let returnMe:Im.Message.ImunreadMsgCntReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImunreadMsgCntReq) throws -> Im.Message.ImunreadMsgCntReq.Builder {
                if other == Im.Message.ImunreadMsgCntReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImunreadMsgCntReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImunreadMsgCntReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImunreadMsgCntReq.Builder {
                let resultDecodedBuilder = Im.Message.ImunreadMsgCntReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImunreadMsgCntReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImunreadMsgCntReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImunreadMsgCntRsp : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImunreadMsgCntRsp.Builder

        public static func == (lhs: Im.Message.ImunreadMsgCntRsp, rhs: Im.Message.ImunreadMsgCntRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasTotalCnt == rhs.hasTotalCnt) && (!lhs.hasTotalCnt || lhs.totalCnt == rhs.totalCnt)
            fieldCheck = fieldCheck && (lhs.unreadinfoList == rhs.unreadinfoList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x0308
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var totalCnt:UInt32! = nil
        public fileprivate(set) var hasTotalCnt:Bool = false

        public fileprivate(set) var unreadinfoList:Array<Im.BaseDefine.UnreadInfo>  = Array<Im.BaseDefine.UnreadInfo>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasTotalCnt {
                return false
            }
            var isInitUnreadinfoList:Bool = true
            for oneElementUnreadinfoList in unreadinfoList {
                if !oneElementUnreadinfoList.isInitialized() {
                    isInitUnreadinfoList = false
                    break 
                }
            }
            if !isInitUnreadinfoList {
                return isInitUnreadinfoList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasTotalCnt {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:totalCnt)
            }
            for oneElementUnreadinfoList in unreadinfoList {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementUnreadinfoList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasTotalCnt {
                serialize_size += totalCnt.computeUInt32Size(fieldNumber: 2)
            }
            for oneElementUnreadinfoList in unreadinfoList {
                serialize_size += oneElementUnreadinfoList.computeMessageSize(fieldNumber: 3)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImunreadMsgCntRsp.Builder {
            return Im.Message.ImunreadMsgCntRsp.classBuilder() as! Im.Message.ImunreadMsgCntRsp.Builder
        }
        public func getBuilder() -> Im.Message.ImunreadMsgCntRsp.Builder {
            return classBuilder() as! Im.Message.ImunreadMsgCntRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImunreadMsgCntRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImunreadMsgCntRsp.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImunreadMsgCntRsp.Builder {
            return try Im.Message.ImunreadMsgCntRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImunreadMsgCntRsp) throws -> Im.Message.ImunreadMsgCntRsp.Builder {
            return try Im.Message.ImunreadMsgCntRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasTotalCnt {
                jsonMap["totalCnt"] = UInt(totalCnt)
            }
            if !unreadinfoList.isEmpty {
                var jsonArrayUnreadinfoList:Array<Dictionary<String,Any>> = []
                for oneValueUnreadinfoList in unreadinfoList {
                    let ecodedMessageUnreadinfoList = try oneValueUnreadinfoList.encode()
                    jsonArrayUnreadinfoList.append(ecodedMessageUnreadinfoList)
                }
                jsonMap["unreadinfoList"] = jsonArrayUnreadinfoList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImunreadMsgCntRsp {
            return try Im.Message.ImunreadMsgCntRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImunreadMsgCntRsp {
            return try Im.Message.ImunreadMsgCntRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasTotalCnt {
                output += "\(indent) totalCnt: \(totalCnt) \n"
            }
            var unreadinfoListElementIndex:Int = 0
            for oneElementUnreadinfoList in unreadinfoList {
                output += "\(indent) unreadinfoList[\(unreadinfoListElementIndex)] {\n"
                output += try oneElementUnreadinfoList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                unreadinfoListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasTotalCnt {
                    hashCode = (hashCode &* 31) &+ totalCnt.hashValue
                }
                for oneElementUnreadinfoList in unreadinfoList {
                    hashCode = (hashCode &* 31) &+ oneElementUnreadinfoList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImunreadMsgCntRsp"
        }
        override public func className() -> String {
            return "Im.Message.ImunreadMsgCntRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImunreadMsgCntRsp = Im.Message.ImunreadMsgCntRsp()
            public func getMessage() -> Im.Message.ImunreadMsgCntRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0308
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Message.ImunreadMsgCntRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Message.ImunreadMsgCntRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var totalCnt:UInt32 {
                get {
                    return builderResult.totalCnt
                }
                set (value) {
                    builderResult.hasTotalCnt = true
                    builderResult.totalCnt = value
                }
            }
            public var hasTotalCnt:Bool {
                get {
                    return builderResult.hasTotalCnt
                }
            }
            @discardableResult
            public func setTotalCnt(_ value:UInt32) -> Im.Message.ImunreadMsgCntRsp.Builder {
                self.totalCnt = value
                return self
            }
            @discardableResult
            public func clearTotalCnt() -> Im.Message.ImunreadMsgCntRsp.Builder{
                builderResult.hasTotalCnt = false
                builderResult.totalCnt = nil
                return self
            }
            public var unreadinfoList:Array<Im.BaseDefine.UnreadInfo> {
                get {
                    return builderResult.unreadinfoList
                }
                set (value) {
                    builderResult.unreadinfoList = value
                }
            }
            @discardableResult
            public func setUnreadinfoList(_ value:Array<Im.BaseDefine.UnreadInfo>) -> Im.Message.ImunreadMsgCntRsp.Builder {
                self.unreadinfoList = value
                return self
            }
            @discardableResult
            public func clearUnreadinfoList() -> Im.Message.ImunreadMsgCntRsp.Builder {
                builderResult.unreadinfoList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Message.ImunreadMsgCntRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Message.ImunreadMsgCntRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImunreadMsgCntRsp.Builder {
                builderResult = Im.Message.ImunreadMsgCntRsp()
                return self
            }
            override public func clone() throws -> Im.Message.ImunreadMsgCntRsp.Builder {
                return try Im.Message.ImunreadMsgCntRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImunreadMsgCntRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImunreadMsgCntRsp {
                let returnMe:Im.Message.ImunreadMsgCntRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImunreadMsgCntRsp) throws -> Im.Message.ImunreadMsgCntRsp.Builder {
                if other == Im.Message.ImunreadMsgCntRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasTotalCnt {
                    totalCnt = other.totalCnt
                }
                if !other.unreadinfoList.isEmpty  {
                     builderResult.unreadinfoList += other.unreadinfoList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImunreadMsgCntRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImunreadMsgCntRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        totalCnt = try codedInputStream.readUInt32()

                    case 26:
                        let subBuilder = Im.BaseDefine.UnreadInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        unreadinfoList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImunreadMsgCntRsp.Builder {
                let resultDecodedBuilder = Im.Message.ImunreadMsgCntRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueTotalCnt = jsonMap["totalCnt"] as? UInt {
                    resultDecodedBuilder.totalCnt = UInt32(jsonValueTotalCnt)
                } else if let jsonValueTotalCnt = jsonMap["totalCnt"] as? String {
                    resultDecodedBuilder.totalCnt = UInt32(jsonValueTotalCnt)!
                }
                if let jsonValueUnreadinfoList = jsonMap["unreadinfoList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayUnreadinfoList:Array<Im.BaseDefine.UnreadInfo> = []
                    for oneValueUnreadinfoList in jsonValueUnreadinfoList {
                        let messageFromStringUnreadinfoList = try Im.BaseDefine.UnreadInfo.Builder.decodeToBuilder(jsonMap:oneValueUnreadinfoList).build()

                        jsonArrayUnreadinfoList.append(messageFromStringUnreadinfoList)
                    }
                    resultDecodedBuilder.unreadinfoList = jsonArrayUnreadinfoList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImunreadMsgCntRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImunreadMsgCntRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgetMsgListReq : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImgetMsgListReq.Builder

        public static func == (lhs: Im.Message.ImgetMsgListReq, rhs: Im.Message.ImgetMsgListReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = fieldCheck && (lhs.hasMsgIdBegin == rhs.hasMsgIdBegin) && (!lhs.hasMsgIdBegin || lhs.msgIdBegin == rhs.msgIdBegin)
            fieldCheck = fieldCheck && (lhs.hasMsgCnt == rhs.hasMsgCnt) && (!lhs.hasMsgCnt || lhs.msgCnt == rhs.msgCnt)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x0309
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        public fileprivate(set) var msgIdBegin:UInt32! = nil
        public fileprivate(set) var hasMsgIdBegin:Bool = false

        public fileprivate(set) var msgCnt:UInt32! = nil
        public fileprivate(set) var hasMsgCnt:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasSessionType {
                return false
            }
            if !hasSessionId {
                return false
            }
            if !hasMsgIdBegin {
                return false
            }
            if !hasMsgCnt {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:sessionType.rawValue)
            }
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:sessionId)
            }
            if hasMsgIdBegin {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:msgIdBegin)
            }
            if hasMsgCnt {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:msgCnt)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 3)
            }
            if hasMsgIdBegin {
                serialize_size += msgIdBegin.computeUInt32Size(fieldNumber: 4)
            }
            if hasMsgCnt {
                serialize_size += msgCnt.computeUInt32Size(fieldNumber: 5)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImgetMsgListReq.Builder {
            return Im.Message.ImgetMsgListReq.classBuilder() as! Im.Message.ImgetMsgListReq.Builder
        }
        public func getBuilder() -> Im.Message.ImgetMsgListReq.Builder {
            return classBuilder() as! Im.Message.ImgetMsgListReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImgetMsgListReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImgetMsgListReq.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImgetMsgListReq.Builder {
            return try Im.Message.ImgetMsgListReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImgetMsgListReq) throws -> Im.Message.ImgetMsgListReq.Builder {
            return try Im.Message.ImgetMsgListReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            if hasMsgIdBegin {
                jsonMap["msgIdBegin"] = UInt(msgIdBegin)
            }
            if hasMsgCnt {
                jsonMap["msgCnt"] = UInt(msgCnt)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImgetMsgListReq {
            return try Im.Message.ImgetMsgListReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImgetMsgListReq {
            return try Im.Message.ImgetMsgListReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            if hasMsgIdBegin {
                output += "\(indent) msgIdBegin: \(msgIdBegin) \n"
            }
            if hasMsgCnt {
                output += "\(indent) msgCnt: \(msgCnt) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                if hasMsgIdBegin {
                    hashCode = (hashCode &* 31) &+ msgIdBegin.hashValue
                }
                if hasMsgCnt {
                    hashCode = (hashCode &* 31) &+ msgCnt.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImgetMsgListReq"
        }
        override public func className() -> String {
            return "Im.Message.ImgetMsgListReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImgetMsgListReq = Im.Message.ImgetMsgListReq()
            public func getMessage() -> Im.Message.ImgetMsgListReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x0309
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Message.ImgetMsgListReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Message.ImgetMsgListReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.Message.ImgetMsgListReq.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.Message.ImgetMsgListReq.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.Message.ImgetMsgListReq.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.Message.ImgetMsgListReq.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
            public var msgIdBegin:UInt32 {
                get {
                    return builderResult.msgIdBegin
                }
                set (value) {
                    builderResult.hasMsgIdBegin = true
                    builderResult.msgIdBegin = value
                }
            }
            public var hasMsgIdBegin:Bool {
                get {
                    return builderResult.hasMsgIdBegin
                }
            }
            @discardableResult
            public func setMsgIdBegin(_ value:UInt32) -> Im.Message.ImgetMsgListReq.Builder {
                self.msgIdBegin = value
                return self
            }
            @discardableResult
            public func clearMsgIdBegin() -> Im.Message.ImgetMsgListReq.Builder{
                builderResult.hasMsgIdBegin = false
                builderResult.msgIdBegin = nil
                return self
            }
            public var msgCnt:UInt32 {
                get {
                    return builderResult.msgCnt
                }
                set (value) {
                    builderResult.hasMsgCnt = true
                    builderResult.msgCnt = value
                }
            }
            public var hasMsgCnt:Bool {
                get {
                    return builderResult.hasMsgCnt
                }
            }
            @discardableResult
            public func setMsgCnt(_ value:UInt32) -> Im.Message.ImgetMsgListReq.Builder {
                self.msgCnt = value
                return self
            }
            @discardableResult
            public func clearMsgCnt() -> Im.Message.ImgetMsgListReq.Builder{
                builderResult.hasMsgCnt = false
                builderResult.msgCnt = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Message.ImgetMsgListReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Message.ImgetMsgListReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImgetMsgListReq.Builder {
                builderResult = Im.Message.ImgetMsgListReq()
                return self
            }
            override public func clone() throws -> Im.Message.ImgetMsgListReq.Builder {
                return try Im.Message.ImgetMsgListReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImgetMsgListReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImgetMsgListReq {
                let returnMe:Im.Message.ImgetMsgListReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImgetMsgListReq) throws -> Im.Message.ImgetMsgListReq.Builder {
                if other == Im.Message.ImgetMsgListReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                if other.hasMsgIdBegin {
                    msgIdBegin = other.msgIdBegin
                }
                if other.hasMsgCnt {
                    msgCnt = other.msgCnt
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImgetMsgListReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgListReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntsessionType))
                        }

                    case 24:
                        sessionId = try codedInputStream.readUInt32()

                    case 32:
                        msgIdBegin = try codedInputStream.readUInt32()

                    case 40:
                        msgCnt = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImgetMsgListReq.Builder {
                let resultDecodedBuilder = Im.Message.ImgetMsgListReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                if let jsonValueMsgIdBegin = jsonMap["msgIdBegin"] as? UInt {
                    resultDecodedBuilder.msgIdBegin = UInt32(jsonValueMsgIdBegin)
                } else if let jsonValueMsgIdBegin = jsonMap["msgIdBegin"] as? String {
                    resultDecodedBuilder.msgIdBegin = UInt32(jsonValueMsgIdBegin)!
                }
                if let jsonValueMsgCnt = jsonMap["msgCnt"] as? UInt {
                    resultDecodedBuilder.msgCnt = UInt32(jsonValueMsgCnt)
                } else if let jsonValueMsgCnt = jsonMap["msgCnt"] as? String {
                    resultDecodedBuilder.msgCnt = UInt32(jsonValueMsgCnt)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImgetMsgListReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImgetMsgListReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///对于群而言，如果消息数目返回的数值小于请求的cnt,则表示群的消息能拉取的到头了，更早的消息没有权限拉取。
    ///如果msg_cnt 和 msg_id_begin计算得到的最早消息id与实际返回的最早消息id不一致，说明服务器消息有缺失，需要
    ///客户端做一个缺失标记，避免下次再次拉取。
    final public class ImgetMsgListRsp : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImgetMsgListRsp.Builder

        public static func == (lhs: Im.Message.ImgetMsgListRsp, rhs: Im.Message.ImgetMsgListRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = fieldCheck && (lhs.hasMsgIdBegin == rhs.hasMsgIdBegin) && (!lhs.hasMsgIdBegin || lhs.msgIdBegin == rhs.msgIdBegin)
            fieldCheck = fieldCheck && (lhs.msgList == rhs.msgList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x030a
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        public fileprivate(set) var msgIdBegin:UInt32! = nil
        public fileprivate(set) var hasMsgIdBegin:Bool = false

        public fileprivate(set) var msgList:Array<Im.BaseDefine.MsgInfo>  = Array<Im.BaseDefine.MsgInfo>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasSessionType {
                return false
            }
            if !hasSessionId {
                return false
            }
            if !hasMsgIdBegin {
                return false
            }
            var isInitMsgList:Bool = true
            for oneElementMsgList in msgList {
                if !oneElementMsgList.isInitialized() {
                    isInitMsgList = false
                    break 
                }
            }
            if !isInitMsgList {
                return isInitMsgList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:sessionType.rawValue)
            }
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:sessionId)
            }
            if hasMsgIdBegin {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:msgIdBegin)
            }
            for oneElementMsgList in msgList {
                  try codedOutputStream.writeMessage(fieldNumber: 5, value:oneElementMsgList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 3)
            }
            if hasMsgIdBegin {
                serialize_size += msgIdBegin.computeUInt32Size(fieldNumber: 4)
            }
            for oneElementMsgList in msgList {
                serialize_size += oneElementMsgList.computeMessageSize(fieldNumber: 5)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImgetMsgListRsp.Builder {
            return Im.Message.ImgetMsgListRsp.classBuilder() as! Im.Message.ImgetMsgListRsp.Builder
        }
        public func getBuilder() -> Im.Message.ImgetMsgListRsp.Builder {
            return classBuilder() as! Im.Message.ImgetMsgListRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImgetMsgListRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImgetMsgListRsp.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImgetMsgListRsp.Builder {
            return try Im.Message.ImgetMsgListRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImgetMsgListRsp) throws -> Im.Message.ImgetMsgListRsp.Builder {
            return try Im.Message.ImgetMsgListRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            if hasMsgIdBegin {
                jsonMap["msgIdBegin"] = UInt(msgIdBegin)
            }
            if !msgList.isEmpty {
                var jsonArrayMsgList:Array<Dictionary<String,Any>> = []
                for oneValueMsgList in msgList {
                    let ecodedMessageMsgList = try oneValueMsgList.encode()
                    jsonArrayMsgList.append(ecodedMessageMsgList)
                }
                jsonMap["msgList"] = jsonArrayMsgList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImgetMsgListRsp {
            return try Im.Message.ImgetMsgListRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImgetMsgListRsp {
            return try Im.Message.ImgetMsgListRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            if hasMsgIdBegin {
                output += "\(indent) msgIdBegin: \(msgIdBegin) \n"
            }
            var msgListElementIndex:Int = 0
            for oneElementMsgList in msgList {
                output += "\(indent) msgList[\(msgListElementIndex)] {\n"
                output += try oneElementMsgList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                msgListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                if hasMsgIdBegin {
                    hashCode = (hashCode &* 31) &+ msgIdBegin.hashValue
                }
                for oneElementMsgList in msgList {
                    hashCode = (hashCode &* 31) &+ oneElementMsgList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImgetMsgListRsp"
        }
        override public func className() -> String {
            return "Im.Message.ImgetMsgListRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImgetMsgListRsp = Im.Message.ImgetMsgListRsp()
            public func getMessage() -> Im.Message.ImgetMsgListRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x030a
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Message.ImgetMsgListRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Message.ImgetMsgListRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.Message.ImgetMsgListRsp.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.Message.ImgetMsgListRsp.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.Message.ImgetMsgListRsp.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.Message.ImgetMsgListRsp.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
            public var msgIdBegin:UInt32 {
                get {
                    return builderResult.msgIdBegin
                }
                set (value) {
                    builderResult.hasMsgIdBegin = true
                    builderResult.msgIdBegin = value
                }
            }
            public var hasMsgIdBegin:Bool {
                get {
                    return builderResult.hasMsgIdBegin
                }
            }
            @discardableResult
            public func setMsgIdBegin(_ value:UInt32) -> Im.Message.ImgetMsgListRsp.Builder {
                self.msgIdBegin = value
                return self
            }
            @discardableResult
            public func clearMsgIdBegin() -> Im.Message.ImgetMsgListRsp.Builder{
                builderResult.hasMsgIdBegin = false
                builderResult.msgIdBegin = nil
                return self
            }
            public var msgList:Array<Im.BaseDefine.MsgInfo> {
                get {
                    return builderResult.msgList
                }
                set (value) {
                    builderResult.msgList = value
                }
            }
            @discardableResult
            public func setMsgList(_ value:Array<Im.BaseDefine.MsgInfo>) -> Im.Message.ImgetMsgListRsp.Builder {
                self.msgList = value
                return self
            }
            @discardableResult
            public func clearMsgList() -> Im.Message.ImgetMsgListRsp.Builder {
                builderResult.msgList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Message.ImgetMsgListRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Message.ImgetMsgListRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImgetMsgListRsp.Builder {
                builderResult = Im.Message.ImgetMsgListRsp()
                return self
            }
            override public func clone() throws -> Im.Message.ImgetMsgListRsp.Builder {
                return try Im.Message.ImgetMsgListRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImgetMsgListRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImgetMsgListRsp {
                let returnMe:Im.Message.ImgetMsgListRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImgetMsgListRsp) throws -> Im.Message.ImgetMsgListRsp.Builder {
                if other == Im.Message.ImgetMsgListRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                if other.hasMsgIdBegin {
                    msgIdBegin = other.msgIdBegin
                }
                if !other.msgList.isEmpty  {
                     builderResult.msgList += other.msgList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImgetMsgListRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgListRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntsessionType))
                        }

                    case 24:
                        sessionId = try codedInputStream.readUInt32()

                    case 32:
                        msgIdBegin = try codedInputStream.readUInt32()

                    case 42:
                        let subBuilder = Im.BaseDefine.MsgInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        msgList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImgetMsgListRsp.Builder {
                let resultDecodedBuilder = Im.Message.ImgetMsgListRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                if let jsonValueMsgIdBegin = jsonMap["msgIdBegin"] as? UInt {
                    resultDecodedBuilder.msgIdBegin = UInt32(jsonValueMsgIdBegin)
                } else if let jsonValueMsgIdBegin = jsonMap["msgIdBegin"] as? String {
                    resultDecodedBuilder.msgIdBegin = UInt32(jsonValueMsgIdBegin)!
                }
                if let jsonValueMsgList = jsonMap["msgList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayMsgList:Array<Im.BaseDefine.MsgInfo> = []
                    for oneValueMsgList in jsonValueMsgList {
                        let messageFromStringMsgList = try Im.BaseDefine.MsgInfo.Builder.decodeToBuilder(jsonMap:oneValueMsgList).build()

                        jsonArrayMsgList.append(messageFromStringMsgList)
                    }
                    resultDecodedBuilder.msgList = jsonArrayMsgList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImgetMsgListRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImgetMsgListRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgetLatestMsgIdReq : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImgetLatestMsgIdReq.Builder

        public static func == (lhs: Im.Message.ImgetLatestMsgIdReq, rhs: Im.Message.ImgetLatestMsgIdReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id: 		0x030b
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasSessionType {
                return false
            }
            if !hasSessionId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:sessionType.rawValue)
            }
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:sessionId)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 3)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImgetLatestMsgIdReq.Builder {
            return Im.Message.ImgetLatestMsgIdReq.classBuilder() as! Im.Message.ImgetLatestMsgIdReq.Builder
        }
        public func getBuilder() -> Im.Message.ImgetLatestMsgIdReq.Builder {
            return classBuilder() as! Im.Message.ImgetLatestMsgIdReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImgetLatestMsgIdReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImgetLatestMsgIdReq.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImgetLatestMsgIdReq.Builder {
            return try Im.Message.ImgetLatestMsgIdReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImgetLatestMsgIdReq) throws -> Im.Message.ImgetLatestMsgIdReq.Builder {
            return try Im.Message.ImgetLatestMsgIdReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImgetLatestMsgIdReq {
            return try Im.Message.ImgetLatestMsgIdReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImgetLatestMsgIdReq {
            return try Im.Message.ImgetLatestMsgIdReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImgetLatestMsgIdReq"
        }
        override public func className() -> String {
            return "Im.Message.ImgetLatestMsgIdReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImgetLatestMsgIdReq = Im.Message.ImgetLatestMsgIdReq()
            public func getMessage() -> Im.Message.ImgetLatestMsgIdReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 		0x030b
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Message.ImgetLatestMsgIdReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Message.ImgetLatestMsgIdReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.Message.ImgetLatestMsgIdReq.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.Message.ImgetLatestMsgIdReq.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.Message.ImgetLatestMsgIdReq.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.Message.ImgetLatestMsgIdReq.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Message.ImgetLatestMsgIdReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Message.ImgetLatestMsgIdReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImgetLatestMsgIdReq.Builder {
                builderResult = Im.Message.ImgetLatestMsgIdReq()
                return self
            }
            override public func clone() throws -> Im.Message.ImgetLatestMsgIdReq.Builder {
                return try Im.Message.ImgetLatestMsgIdReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImgetLatestMsgIdReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImgetLatestMsgIdReq {
                let returnMe:Im.Message.ImgetLatestMsgIdReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImgetLatestMsgIdReq) throws -> Im.Message.ImgetLatestMsgIdReq.Builder {
                if other == Im.Message.ImgetLatestMsgIdReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImgetLatestMsgIdReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetLatestMsgIdReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntsessionType))
                        }

                    case 24:
                        sessionId = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImgetLatestMsgIdReq.Builder {
                let resultDecodedBuilder = Im.Message.ImgetLatestMsgIdReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImgetLatestMsgIdReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImgetLatestMsgIdReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgetLatestMsgIdRsp : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImgetLatestMsgIdRsp.Builder

        public static func == (lhs: Im.Message.ImgetLatestMsgIdRsp, rhs: Im.Message.ImgetLatestMsgIdRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = fieldCheck && (lhs.hasLatestMsgId == rhs.hasLatestMsgId) && (!lhs.hasLatestMsgId || lhs.latestMsgId == rhs.latestMsgId)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x030c
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        public fileprivate(set) var latestMsgId:UInt32! = nil
        public fileprivate(set) var hasLatestMsgId:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasSessionType {
                return false
            }
            if !hasSessionId {
                return false
            }
            if !hasLatestMsgId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:sessionType.rawValue)
            }
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:sessionId)
            }
            if hasLatestMsgId {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:latestMsgId)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 3)
            }
            if hasLatestMsgId {
                serialize_size += latestMsgId.computeUInt32Size(fieldNumber: 4)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImgetLatestMsgIdRsp.Builder {
            return Im.Message.ImgetLatestMsgIdRsp.classBuilder() as! Im.Message.ImgetLatestMsgIdRsp.Builder
        }
        public func getBuilder() -> Im.Message.ImgetLatestMsgIdRsp.Builder {
            return classBuilder() as! Im.Message.ImgetLatestMsgIdRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImgetLatestMsgIdRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImgetLatestMsgIdRsp.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImgetLatestMsgIdRsp.Builder {
            return try Im.Message.ImgetLatestMsgIdRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImgetLatestMsgIdRsp) throws -> Im.Message.ImgetLatestMsgIdRsp.Builder {
            return try Im.Message.ImgetLatestMsgIdRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            if hasLatestMsgId {
                jsonMap["latestMsgId"] = UInt(latestMsgId)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImgetLatestMsgIdRsp {
            return try Im.Message.ImgetLatestMsgIdRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImgetLatestMsgIdRsp {
            return try Im.Message.ImgetLatestMsgIdRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            if hasLatestMsgId {
                output += "\(indent) latestMsgId: \(latestMsgId) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                if hasLatestMsgId {
                    hashCode = (hashCode &* 31) &+ latestMsgId.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImgetLatestMsgIdRsp"
        }
        override public func className() -> String {
            return "Im.Message.ImgetLatestMsgIdRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImgetLatestMsgIdRsp = Im.Message.ImgetLatestMsgIdRsp()
            public func getMessage() -> Im.Message.ImgetLatestMsgIdRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x030c
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Message.ImgetLatestMsgIdRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Message.ImgetLatestMsgIdRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.Message.ImgetLatestMsgIdRsp.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.Message.ImgetLatestMsgIdRsp.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.Message.ImgetLatestMsgIdRsp.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.Message.ImgetLatestMsgIdRsp.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
            public var latestMsgId:UInt32 {
                get {
                    return builderResult.latestMsgId
                }
                set (value) {
                    builderResult.hasLatestMsgId = true
                    builderResult.latestMsgId = value
                }
            }
            public var hasLatestMsgId:Bool {
                get {
                    return builderResult.hasLatestMsgId
                }
            }
            @discardableResult
            public func setLatestMsgId(_ value:UInt32) -> Im.Message.ImgetLatestMsgIdRsp.Builder {
                self.latestMsgId = value
                return self
            }
            @discardableResult
            public func clearLatestMsgId() -> Im.Message.ImgetLatestMsgIdRsp.Builder{
                builderResult.hasLatestMsgId = false
                builderResult.latestMsgId = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Message.ImgetLatestMsgIdRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Message.ImgetLatestMsgIdRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImgetLatestMsgIdRsp.Builder {
                builderResult = Im.Message.ImgetLatestMsgIdRsp()
                return self
            }
            override public func clone() throws -> Im.Message.ImgetLatestMsgIdRsp.Builder {
                return try Im.Message.ImgetLatestMsgIdRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImgetLatestMsgIdRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImgetLatestMsgIdRsp {
                let returnMe:Im.Message.ImgetLatestMsgIdRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImgetLatestMsgIdRsp) throws -> Im.Message.ImgetLatestMsgIdRsp.Builder {
                if other == Im.Message.ImgetLatestMsgIdRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                if other.hasLatestMsgId {
                    latestMsgId = other.latestMsgId
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImgetLatestMsgIdRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetLatestMsgIdRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntsessionType))
                        }

                    case 24:
                        sessionId = try codedInputStream.readUInt32()

                    case 32:
                        latestMsgId = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImgetLatestMsgIdRsp.Builder {
                let resultDecodedBuilder = Im.Message.ImgetLatestMsgIdRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                if let jsonValueLatestMsgId = jsonMap["latestMsgId"] as? UInt {
                    resultDecodedBuilder.latestMsgId = UInt32(jsonValueLatestMsgId)
                } else if let jsonValueLatestMsgId = jsonMap["latestMsgId"] as? String {
                    resultDecodedBuilder.latestMsgId = UInt32(jsonValueLatestMsgId)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImgetLatestMsgIdRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImgetLatestMsgIdRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgetMsgByIdReq : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImgetMsgByIdReq.Builder

        public static func == (lhs: Im.Message.ImgetMsgByIdReq, rhs: Im.Message.ImgetMsgByIdReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = fieldCheck && (lhs.msgIdList == rhs.msgIdList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id: 		0x030d
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        public fileprivate(set) var msgIdList:Array<UInt32> = Array<UInt32>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasSessionType {
                return false
            }
            if !hasSessionId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:sessionType.rawValue)
            }
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:sessionId)
            }
            if !msgIdList.isEmpty {
                for oneValuemsgIdList in msgIdList {
                    try codedOutputStream.writeUInt32(fieldNumber: 4, value:oneValuemsgIdList)
                }
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 3)
            }
            var dataSizeMsgIdList:Int32 = 0
            for oneValuemsgIdList in msgIdList {
                dataSizeMsgIdList += oneValuemsgIdList.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeMsgIdList
            serialize_size += 1 * Int32(msgIdList.count)
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImgetMsgByIdReq.Builder {
            return Im.Message.ImgetMsgByIdReq.classBuilder() as! Im.Message.ImgetMsgByIdReq.Builder
        }
        public func getBuilder() -> Im.Message.ImgetMsgByIdReq.Builder {
            return classBuilder() as! Im.Message.ImgetMsgByIdReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImgetMsgByIdReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImgetMsgByIdReq.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImgetMsgByIdReq.Builder {
            return try Im.Message.ImgetMsgByIdReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImgetMsgByIdReq) throws -> Im.Message.ImgetMsgByIdReq.Builder {
            return try Im.Message.ImgetMsgByIdReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            if !msgIdList.isEmpty {
                var jsonArrayMsgIdList:Array<UInt> = []
                for oneValueMsgIdList in msgIdList {
                    jsonArrayMsgIdList.append(UInt(oneValueMsgIdList))
                }
                jsonMap["msgIdList"] = jsonArrayMsgIdList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImgetMsgByIdReq {
            return try Im.Message.ImgetMsgByIdReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImgetMsgByIdReq {
            return try Im.Message.ImgetMsgByIdReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            var msgIdListElementIndex:Int = 0
            for oneValueMsgIdList in msgIdList  {
                output += "\(indent) msgIdList[\(msgIdListElementIndex)]: \(oneValueMsgIdList)\n"
                msgIdListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                for oneValueMsgIdList in msgIdList {
                    hashCode = (hashCode &* 31) &+ oneValueMsgIdList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImgetMsgByIdReq"
        }
        override public func className() -> String {
            return "Im.Message.ImgetMsgByIdReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImgetMsgByIdReq = Im.Message.ImgetMsgByIdReq()
            public func getMessage() -> Im.Message.ImgetMsgByIdReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 		0x030d
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Message.ImgetMsgByIdReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Message.ImgetMsgByIdReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.Message.ImgetMsgByIdReq.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.Message.ImgetMsgByIdReq.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.Message.ImgetMsgByIdReq.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.Message.ImgetMsgByIdReq.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
            public var msgIdList:Array<UInt32> {
                get {
                    return builderResult.msgIdList
                }
                set (array) {
                    builderResult.msgIdList = array
                }
            }
            @discardableResult
            public func setMsgIdList(_ value:Array<UInt32>) -> Im.Message.ImgetMsgByIdReq.Builder {
                self.msgIdList = value
                return self
            }
            @discardableResult
            public func clearMsgIdList() -> Im.Message.ImgetMsgByIdReq.Builder {
                builderResult.msgIdList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Message.ImgetMsgByIdReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Message.ImgetMsgByIdReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImgetMsgByIdReq.Builder {
                builderResult = Im.Message.ImgetMsgByIdReq()
                return self
            }
            override public func clone() throws -> Im.Message.ImgetMsgByIdReq.Builder {
                return try Im.Message.ImgetMsgByIdReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImgetMsgByIdReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImgetMsgByIdReq {
                let returnMe:Im.Message.ImgetMsgByIdReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImgetMsgByIdReq) throws -> Im.Message.ImgetMsgByIdReq.Builder {
                if other == Im.Message.ImgetMsgByIdReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                if !other.msgIdList.isEmpty {
                    builderResult.msgIdList += other.msgIdList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImgetMsgByIdReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgByIdReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntsessionType))
                        }

                    case 24:
                        sessionId = try codedInputStream.readUInt32()

                    case 32:
                        msgIdList += [try codedInputStream.readUInt32()]

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImgetMsgByIdReq.Builder {
                let resultDecodedBuilder = Im.Message.ImgetMsgByIdReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                if let jsonValueMsgIdList = jsonMap["msgIdList"] as? Array<UInt> {
                    var jsonArrayMsgIdList:Array<UInt32> = []
                    for oneValueMsgIdList in jsonValueMsgIdList {
                        jsonArrayMsgIdList.append(UInt32(oneValueMsgIdList))
                    }
                    resultDecodedBuilder.msgIdList = jsonArrayMsgIdList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImgetMsgByIdReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImgetMsgByIdReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgetMsgByIdRsp : GeneratedMessage {
        public typealias BuilderType = Im.Message.ImgetMsgByIdRsp.Builder

        public static func == (lhs: Im.Message.ImgetMsgByIdRsp, rhs: Im.Message.ImgetMsgByIdRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = fieldCheck && (lhs.msgList == rhs.msgList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:		0x030e
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        public fileprivate(set) var msgList:Array<Im.BaseDefine.MsgInfo>  = Array<Im.BaseDefine.MsgInfo>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasSessionType {
                return false
            }
            if !hasSessionId {
                return false
            }
            var isInitMsgList:Bool = true
            for oneElementMsgList in msgList {
                if !oneElementMsgList.isInitialized() {
                    isInitMsgList = false
                    break 
                }
            }
            if !isInitMsgList {
                return isInitMsgList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:sessionType.rawValue)
            }
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:sessionId)
            }
            for oneElementMsgList in msgList {
                  try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementMsgList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 3)
            }
            for oneElementMsgList in msgList {
                serialize_size += oneElementMsgList.computeMessageSize(fieldNumber: 4)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Message.ImgetMsgByIdRsp.Builder {
            return Im.Message.ImgetMsgByIdRsp.classBuilder() as! Im.Message.ImgetMsgByIdRsp.Builder
        }
        public func getBuilder() -> Im.Message.ImgetMsgByIdRsp.Builder {
            return classBuilder() as! Im.Message.ImgetMsgByIdRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImgetMsgByIdRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Message.ImgetMsgByIdRsp.Builder()
        }
        public func toBuilder() throws -> Im.Message.ImgetMsgByIdRsp.Builder {
            return try Im.Message.ImgetMsgByIdRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Message.ImgetMsgByIdRsp) throws -> Im.Message.ImgetMsgByIdRsp.Builder {
            return try Im.Message.ImgetMsgByIdRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            if !msgList.isEmpty {
                var jsonArrayMsgList:Array<Dictionary<String,Any>> = []
                for oneValueMsgList in msgList {
                    let ecodedMessageMsgList = try oneValueMsgList.encode()
                    jsonArrayMsgList.append(ecodedMessageMsgList)
                }
                jsonMap["msgList"] = jsonArrayMsgList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImgetMsgByIdRsp {
            return try Im.Message.ImgetMsgByIdRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Message.ImgetMsgByIdRsp {
            return try Im.Message.ImgetMsgByIdRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            var msgListElementIndex:Int = 0
            for oneElementMsgList in msgList {
                output += "\(indent) msgList[\(msgListElementIndex)] {\n"
                output += try oneElementMsgList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                msgListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                for oneElementMsgList in msgList {
                    hashCode = (hashCode &* 31) &+ oneElementMsgList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Message.ImgetMsgByIdRsp"
        }
        override public func className() -> String {
            return "Im.Message.ImgetMsgByIdRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Message.ImgetMsgByIdRsp = Im.Message.ImgetMsgByIdRsp()
            public func getMessage() -> Im.Message.ImgetMsgByIdRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:		0x030e
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Message.ImgetMsgByIdRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Message.ImgetMsgByIdRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.Message.ImgetMsgByIdRsp.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.Message.ImgetMsgByIdRsp.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.Message.ImgetMsgByIdRsp.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.Message.ImgetMsgByIdRsp.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
            public var msgList:Array<Im.BaseDefine.MsgInfo> {
                get {
                    return builderResult.msgList
                }
                set (value) {
                    builderResult.msgList = value
                }
            }
            @discardableResult
            public func setMsgList(_ value:Array<Im.BaseDefine.MsgInfo>) -> Im.Message.ImgetMsgByIdRsp.Builder {
                self.msgList = value
                return self
            }
            @discardableResult
            public func clearMsgList() -> Im.Message.ImgetMsgByIdRsp.Builder {
                builderResult.msgList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Message.ImgetMsgByIdRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Message.ImgetMsgByIdRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Message.ImgetMsgByIdRsp.Builder {
                builderResult = Im.Message.ImgetMsgByIdRsp()
                return self
            }
            override public func clone() throws -> Im.Message.ImgetMsgByIdRsp.Builder {
                return try Im.Message.ImgetMsgByIdRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Message.ImgetMsgByIdRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Message.ImgetMsgByIdRsp {
                let returnMe:Im.Message.ImgetMsgByIdRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Message.ImgetMsgByIdRsp) throws -> Im.Message.ImgetMsgByIdRsp.Builder {
                if other == Im.Message.ImgetMsgByIdRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                if !other.msgList.isEmpty  {
                     builderResult.msgList += other.msgList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImgetMsgByIdRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgByIdRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntsessionType))
                        }

                    case 24:
                        sessionId = try codedInputStream.readUInt32()

                    case 34:
                        let subBuilder = Im.BaseDefine.MsgInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        msgList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Message.ImgetMsgByIdRsp.Builder {
                let resultDecodedBuilder = Im.Message.ImgetMsgByIdRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                if let jsonValueMsgList = jsonMap["msgList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayMsgList:Array<Im.BaseDefine.MsgInfo> = []
                    for oneValueMsgList in jsonValueMsgList {
                        let messageFromStringMsgList = try Im.BaseDefine.MsgInfo.Builder.decodeToBuilder(jsonMap:oneValueMsgList).build()

                        jsonArrayMsgList.append(messageFromStringMsgList)
                    }
                    resultDecodedBuilder.msgList = jsonArrayMsgList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Message.ImgetMsgByIdRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Message.ImgetMsgByIdRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Im.Message.ImmsgData: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImmsgData> {
        var mergedArray = Array<Im.Message.ImmsgData>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImmsgData? {
        return try Im.Message.ImmsgData.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImmsgData {
        return try Im.Message.ImmsgData.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgData {
        return try Im.Message.ImmsgData.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImmsgData {
        return try Im.Message.ImmsgData.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgData {
        return try Im.Message.ImmsgData.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImmsgData {
        return try Im.Message.ImmsgData.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgData {
        return try Im.Message.ImmsgData.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "fromUserId": return self.fromUserId
        case "toSessionId": return self.toSessionId
        case "msgId": return self.msgId
        case "createTime": return self.createTime
        case "msgType": return self.msgType
        case "msgData": return self.msgData
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Message.ImmsgData.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImmsgData
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "fromUserId": return self.fromUserId
            case "toSessionId": return self.toSessionId
            case "msgId": return self.msgId
            case "createTime": return self.createTime
            case "msgType": return self.msgType
            case "msgData": return self.msgData
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "fromUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fromUserId = newSubscriptValue
            case "toSessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.toSessionId = newSubscriptValue
            case "msgId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.msgId = newSubscriptValue
            case "createTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.createTime = newSubscriptValue
            case "msgType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.MsgType else {
                    return
                }
                self.msgType = newSubscriptValue
            case "msgData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.msgData = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Message.ImmsgDataAck: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImmsgDataAck> {
        var mergedArray = Array<Im.Message.ImmsgDataAck>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImmsgDataAck? {
        return try Im.Message.ImmsgDataAck.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImmsgDataAck {
        return try Im.Message.ImmsgDataAck.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgDataAck {
        return try Im.Message.ImmsgDataAck.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImmsgDataAck {
        return try Im.Message.ImmsgDataAck.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgDataAck {
        return try Im.Message.ImmsgDataAck.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImmsgDataAck {
        return try Im.Message.ImmsgDataAck.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgDataAck {
        return try Im.Message.ImmsgDataAck.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "sessionId": return self.sessionId
        case "msgId": return self.msgId
        case "sessionType": return self.sessionType
        default: return nil
        }
    }
}
extension Im.Message.ImmsgDataAck.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImmsgDataAck
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "sessionId": return self.sessionId
            case "msgId": return self.msgId
            case "sessionType": return self.sessionType
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "msgId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.msgId = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Message.ImmsgDataReadAck: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImmsgDataReadAck> {
        var mergedArray = Array<Im.Message.ImmsgDataReadAck>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImmsgDataReadAck? {
        return try Im.Message.ImmsgDataReadAck.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImmsgDataReadAck {
        return try Im.Message.ImmsgDataReadAck.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgDataReadAck {
        return try Im.Message.ImmsgDataReadAck.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImmsgDataReadAck {
        return try Im.Message.ImmsgDataReadAck.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgDataReadAck {
        return try Im.Message.ImmsgDataReadAck.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImmsgDataReadAck {
        return try Im.Message.ImmsgDataReadAck.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgDataReadAck {
        return try Im.Message.ImmsgDataReadAck.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "sessionId": return self.sessionId
        case "msgId": return self.msgId
        case "sessionType": return self.sessionType
        default: return nil
        }
    }
}
extension Im.Message.ImmsgDataReadAck.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImmsgDataReadAck
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "sessionId": return self.sessionId
            case "msgId": return self.msgId
            case "sessionType": return self.sessionType
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "msgId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.msgId = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Message.ImmsgDataReadNotify: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImmsgDataReadNotify> {
        var mergedArray = Array<Im.Message.ImmsgDataReadNotify>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImmsgDataReadNotify? {
        return try Im.Message.ImmsgDataReadNotify.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImmsgDataReadNotify {
        return try Im.Message.ImmsgDataReadNotify.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgDataReadNotify {
        return try Im.Message.ImmsgDataReadNotify.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImmsgDataReadNotify {
        return try Im.Message.ImmsgDataReadNotify.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgDataReadNotify {
        return try Im.Message.ImmsgDataReadNotify.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImmsgDataReadNotify {
        return try Im.Message.ImmsgDataReadNotify.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImmsgDataReadNotify {
        return try Im.Message.ImmsgDataReadNotify.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "sessionId": return self.sessionId
        case "msgId": return self.msgId
        case "sessionType": return self.sessionType
        default: return nil
        }
    }
}
extension Im.Message.ImmsgDataReadNotify.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImmsgDataReadNotify
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "sessionId": return self.sessionId
            case "msgId": return self.msgId
            case "sessionType": return self.sessionType
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "msgId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.msgId = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Message.ImclientTimeReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImclientTimeReq> {
        var mergedArray = Array<Im.Message.ImclientTimeReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImclientTimeReq? {
        return try Im.Message.ImclientTimeReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImclientTimeReq {
        return try Im.Message.ImclientTimeReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImclientTimeReq {
        return try Im.Message.ImclientTimeReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImclientTimeReq {
        return try Im.Message.ImclientTimeReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImclientTimeReq {
        return try Im.Message.ImclientTimeReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImclientTimeReq {
        return try Im.Message.ImclientTimeReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImclientTimeReq {
        return try Im.Message.ImclientTimeReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Im.Message.ImclientTimeReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImclientTimeReq
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Im.Message.ImclientTimeRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImclientTimeRsp> {
        var mergedArray = Array<Im.Message.ImclientTimeRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImclientTimeRsp? {
        return try Im.Message.ImclientTimeRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImclientTimeRsp {
        return try Im.Message.ImclientTimeRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImclientTimeRsp {
        return try Im.Message.ImclientTimeRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImclientTimeRsp {
        return try Im.Message.ImclientTimeRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImclientTimeRsp {
        return try Im.Message.ImclientTimeRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImclientTimeRsp {
        return try Im.Message.ImclientTimeRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImclientTimeRsp {
        return try Im.Message.ImclientTimeRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "serverTime": return self.serverTime
        default: return nil
        }
    }
}
extension Im.Message.ImclientTimeRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImclientTimeRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "serverTime": return self.serverTime
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "serverTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.serverTime = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Message.ImunreadMsgCntReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImunreadMsgCntReq> {
        var mergedArray = Array<Im.Message.ImunreadMsgCntReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImunreadMsgCntReq? {
        return try Im.Message.ImunreadMsgCntReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImunreadMsgCntReq {
        return try Im.Message.ImunreadMsgCntReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImunreadMsgCntReq {
        return try Im.Message.ImunreadMsgCntReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImunreadMsgCntReq {
        return try Im.Message.ImunreadMsgCntReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImunreadMsgCntReq {
        return try Im.Message.ImunreadMsgCntReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImunreadMsgCntReq {
        return try Im.Message.ImunreadMsgCntReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImunreadMsgCntReq {
        return try Im.Message.ImunreadMsgCntReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Message.ImunreadMsgCntReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImunreadMsgCntReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Message.ImunreadMsgCntRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImunreadMsgCntRsp> {
        var mergedArray = Array<Im.Message.ImunreadMsgCntRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImunreadMsgCntRsp? {
        return try Im.Message.ImunreadMsgCntRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImunreadMsgCntRsp {
        return try Im.Message.ImunreadMsgCntRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImunreadMsgCntRsp {
        return try Im.Message.ImunreadMsgCntRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImunreadMsgCntRsp {
        return try Im.Message.ImunreadMsgCntRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImunreadMsgCntRsp {
        return try Im.Message.ImunreadMsgCntRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImunreadMsgCntRsp {
        return try Im.Message.ImunreadMsgCntRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImunreadMsgCntRsp {
        return try Im.Message.ImunreadMsgCntRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "totalCnt": return self.totalCnt
        case "unreadinfoList": return self.unreadinfoList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Message.ImunreadMsgCntRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImunreadMsgCntRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "totalCnt": return self.totalCnt
            case "unreadinfoList": return self.unreadinfoList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "totalCnt":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.totalCnt = newSubscriptValue
            case "unreadinfoList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.UnreadInfo> else {
                    return
                }
                self.unreadinfoList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Message.ImgetMsgListReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImgetMsgListReq> {
        var mergedArray = Array<Im.Message.ImgetMsgListReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImgetMsgListReq? {
        return try Im.Message.ImgetMsgListReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImgetMsgListReq {
        return try Im.Message.ImgetMsgListReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgListReq {
        return try Im.Message.ImgetMsgListReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImgetMsgListReq {
        return try Im.Message.ImgetMsgListReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgListReq {
        return try Im.Message.ImgetMsgListReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImgetMsgListReq {
        return try Im.Message.ImgetMsgListReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgListReq {
        return try Im.Message.ImgetMsgListReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "sessionType": return self.sessionType
        case "sessionId": return self.sessionId
        case "msgIdBegin": return self.msgIdBegin
        case "msgCnt": return self.msgCnt
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Message.ImgetMsgListReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImgetMsgListReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "sessionType": return self.sessionType
            case "sessionId": return self.sessionId
            case "msgIdBegin": return self.msgIdBegin
            case "msgCnt": return self.msgCnt
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "msgIdBegin":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.msgIdBegin = newSubscriptValue
            case "msgCnt":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.msgCnt = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Message.ImgetMsgListRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImgetMsgListRsp> {
        var mergedArray = Array<Im.Message.ImgetMsgListRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImgetMsgListRsp? {
        return try Im.Message.ImgetMsgListRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImgetMsgListRsp {
        return try Im.Message.ImgetMsgListRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgListRsp {
        return try Im.Message.ImgetMsgListRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImgetMsgListRsp {
        return try Im.Message.ImgetMsgListRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgListRsp {
        return try Im.Message.ImgetMsgListRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImgetMsgListRsp {
        return try Im.Message.ImgetMsgListRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgListRsp {
        return try Im.Message.ImgetMsgListRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "sessionType": return self.sessionType
        case "sessionId": return self.sessionId
        case "msgIdBegin": return self.msgIdBegin
        case "msgList": return self.msgList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Message.ImgetMsgListRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImgetMsgListRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "sessionType": return self.sessionType
            case "sessionId": return self.sessionId
            case "msgIdBegin": return self.msgIdBegin
            case "msgList": return self.msgList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "msgIdBegin":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.msgIdBegin = newSubscriptValue
            case "msgList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.MsgInfo> else {
                    return
                }
                self.msgList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Message.ImgetLatestMsgIdReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImgetLatestMsgIdReq> {
        var mergedArray = Array<Im.Message.ImgetLatestMsgIdReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImgetLatestMsgIdReq? {
        return try Im.Message.ImgetLatestMsgIdReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImgetLatestMsgIdReq {
        return try Im.Message.ImgetLatestMsgIdReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetLatestMsgIdReq {
        return try Im.Message.ImgetLatestMsgIdReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImgetLatestMsgIdReq {
        return try Im.Message.ImgetLatestMsgIdReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetLatestMsgIdReq {
        return try Im.Message.ImgetLatestMsgIdReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImgetLatestMsgIdReq {
        return try Im.Message.ImgetLatestMsgIdReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetLatestMsgIdReq {
        return try Im.Message.ImgetLatestMsgIdReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "sessionType": return self.sessionType
        case "sessionId": return self.sessionId
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Message.ImgetLatestMsgIdReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImgetLatestMsgIdReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "sessionType": return self.sessionType
            case "sessionId": return self.sessionId
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Message.ImgetLatestMsgIdRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImgetLatestMsgIdRsp> {
        var mergedArray = Array<Im.Message.ImgetLatestMsgIdRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImgetLatestMsgIdRsp? {
        return try Im.Message.ImgetLatestMsgIdRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImgetLatestMsgIdRsp {
        return try Im.Message.ImgetLatestMsgIdRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetLatestMsgIdRsp {
        return try Im.Message.ImgetLatestMsgIdRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImgetLatestMsgIdRsp {
        return try Im.Message.ImgetLatestMsgIdRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetLatestMsgIdRsp {
        return try Im.Message.ImgetLatestMsgIdRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImgetLatestMsgIdRsp {
        return try Im.Message.ImgetLatestMsgIdRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetLatestMsgIdRsp {
        return try Im.Message.ImgetLatestMsgIdRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "sessionType": return self.sessionType
        case "sessionId": return self.sessionId
        case "latestMsgId": return self.latestMsgId
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Message.ImgetLatestMsgIdRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImgetLatestMsgIdRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "sessionType": return self.sessionType
            case "sessionId": return self.sessionId
            case "latestMsgId": return self.latestMsgId
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "latestMsgId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.latestMsgId = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Message.ImgetMsgByIdReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImgetMsgByIdReq> {
        var mergedArray = Array<Im.Message.ImgetMsgByIdReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImgetMsgByIdReq? {
        return try Im.Message.ImgetMsgByIdReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImgetMsgByIdReq {
        return try Im.Message.ImgetMsgByIdReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgByIdReq {
        return try Im.Message.ImgetMsgByIdReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImgetMsgByIdReq {
        return try Im.Message.ImgetMsgByIdReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgByIdReq {
        return try Im.Message.ImgetMsgByIdReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImgetMsgByIdReq {
        return try Im.Message.ImgetMsgByIdReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgByIdReq {
        return try Im.Message.ImgetMsgByIdReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "sessionType": return self.sessionType
        case "sessionId": return self.sessionId
        case "msgIdList": return self.msgIdList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Message.ImgetMsgByIdReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImgetMsgByIdReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "sessionType": return self.sessionType
            case "sessionId": return self.sessionId
            case "msgIdList": return self.msgIdList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "msgIdList":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.msgIdList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Message.ImgetMsgByIdRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Message.ImgetMsgByIdRsp> {
        var mergedArray = Array<Im.Message.ImgetMsgByIdRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Message.ImgetMsgByIdRsp? {
        return try Im.Message.ImgetMsgByIdRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Message.ImgetMsgByIdRsp {
        return try Im.Message.ImgetMsgByIdRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Message.ImmessageRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgByIdRsp {
        return try Im.Message.ImgetMsgByIdRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Message.ImgetMsgByIdRsp {
        return try Im.Message.ImgetMsgByIdRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgByIdRsp {
        return try Im.Message.ImgetMsgByIdRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Message.ImgetMsgByIdRsp {
        return try Im.Message.ImgetMsgByIdRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Message.ImgetMsgByIdRsp {
        return try Im.Message.ImgetMsgByIdRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "sessionType": return self.sessionType
        case "sessionId": return self.sessionId
        case "msgList": return self.msgList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Message.ImgetMsgByIdRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Message.ImgetMsgByIdRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "sessionType": return self.sessionType
            case "sessionId": return self.sessionId
            case "msgList": return self.msgList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "msgList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.MsgInfo> else {
                    return
                }
                self.msgList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
