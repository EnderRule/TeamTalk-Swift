/// Generated by the Protocol Buffers 3.3.2 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "IM.Server.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers

public extension Im {
    public struct Server {}
}

public extension Im.Server {
    public struct ImserverRoot {
        public static let `default` = ImserverRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Im.BaseDefine.ImbaseDefineRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    ///db_proxy
    final public class ImstopReceivePacket : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImstopReceivePacket.Builder

        public static func == (lhs: Im.Server.ImstopReceivePacket, rhs: Im.Server.ImstopReceivePacket) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:   0x0702
        public fileprivate(set) var result:UInt32! = nil
        public fileprivate(set) var hasResult:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasResult {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasResult {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:result)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasResult {
                serialize_size += result.computeUInt32Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImstopReceivePacket.Builder {
            return Im.Server.ImstopReceivePacket.classBuilder() as! Im.Server.ImstopReceivePacket.Builder
        }
        public func getBuilder() -> Im.Server.ImstopReceivePacket.Builder {
            return classBuilder() as! Im.Server.ImstopReceivePacket.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImstopReceivePacket.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImstopReceivePacket.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImstopReceivePacket.Builder {
            return try Im.Server.ImstopReceivePacket.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImstopReceivePacket) throws -> Im.Server.ImstopReceivePacket.Builder {
            return try Im.Server.ImstopReceivePacket.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasResult {
                jsonMap["result"] = UInt(result)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImstopReceivePacket {
            return try Im.Server.ImstopReceivePacket.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImstopReceivePacket {
            return try Im.Server.ImstopReceivePacket.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasResult {
                output += "\(indent) result: \(result) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasResult {
                    hashCode = (hashCode &* 31) &+ result.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImstopReceivePacket"
        }
        override public func className() -> String {
            return "Im.Server.ImstopReceivePacket"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImstopReceivePacket = Im.Server.ImstopReceivePacket()
            public func getMessage() -> Im.Server.ImstopReceivePacket {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:   0x0702
            public var result:UInt32 {
                get {
                    return builderResult.result
                }
                set (value) {
                    builderResult.hasResult = true
                    builderResult.result = value
                }
            }
            public var hasResult:Bool {
                get {
                    return builderResult.hasResult
                }
            }
            @discardableResult
            public func setResult(_ value:UInt32) -> Im.Server.ImstopReceivePacket.Builder {
                self.result = value
                return self
            }
            @discardableResult
            public func clearResult() -> Im.Server.ImstopReceivePacket.Builder{
                builderResult.hasResult = false
                builderResult.result = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImstopReceivePacket.Builder {
                builderResult = Im.Server.ImstopReceivePacket()
                return self
            }
            override public func clone() throws -> Im.Server.ImstopReceivePacket.Builder {
                return try Im.Server.ImstopReceivePacket.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImstopReceivePacket {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImstopReceivePacket {
                let returnMe:Im.Server.ImstopReceivePacket = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImstopReceivePacket) throws -> Im.Server.ImstopReceivePacket.Builder {
                if other == Im.Server.ImstopReceivePacket() {
                    return self
                }
                if other.hasResult {
                    result = other.result
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImstopReceivePacket.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImstopReceivePacket.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        result = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImstopReceivePacket.Builder {
                let resultDecodedBuilder = Im.Server.ImstopReceivePacket.Builder()
                if let jsonValueResult = jsonMap["result"] as? UInt {
                    resultDecodedBuilder.result = UInt32(jsonValueResult)
                } else if let jsonValueResult = jsonMap["result"] as? String {
                    resultDecodedBuilder.result = UInt32(jsonValueResult)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImstopReceivePacket.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImstopReceivePacket.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///db_proxy
    final public class ImvalidateReq : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImvalidateReq.Builder

        public static func == (lhs: Im.Server.ImvalidateReq, rhs: Im.Server.ImvalidateReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserName == rhs.hasUserName) && (!lhs.hasUserName || lhs.userName == rhs.userName)
            fieldCheck = fieldCheck && (lhs.hasPassword == rhs.hasPassword) && (!lhs.hasPassword || lhs.password == rhs.password)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x0703
        public fileprivate(set) var userName:String! = nil
        public fileprivate(set) var hasUserName:Bool = false

        public fileprivate(set) var password:String! = nil
        public fileprivate(set) var hasPassword:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserName {
                return false
            }
            if !hasPassword {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserName {
                try codedOutputStream.writeString(fieldNumber: 1, value:userName)
            }
            if hasPassword {
                try codedOutputStream.writeString(fieldNumber: 2, value:password)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserName {
                serialize_size += userName.computeStringSize(fieldNumber: 1)
            }
            if hasPassword {
                serialize_size += password.computeStringSize(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImvalidateReq.Builder {
            return Im.Server.ImvalidateReq.classBuilder() as! Im.Server.ImvalidateReq.Builder
        }
        public func getBuilder() -> Im.Server.ImvalidateReq.Builder {
            return classBuilder() as! Im.Server.ImvalidateReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImvalidateReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImvalidateReq.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImvalidateReq.Builder {
            return try Im.Server.ImvalidateReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImvalidateReq) throws -> Im.Server.ImvalidateReq.Builder {
            return try Im.Server.ImvalidateReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserName {
                jsonMap["userName"] = userName
            }
            if hasPassword {
                jsonMap["password"] = password
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImvalidateReq {
            return try Im.Server.ImvalidateReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImvalidateReq {
            return try Im.Server.ImvalidateReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserName {
                output += "\(indent) userName: \(userName) \n"
            }
            if hasPassword {
                output += "\(indent) password: \(password) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserName {
                    hashCode = (hashCode &* 31) &+ userName.hashValue
                }
                if hasPassword {
                    hashCode = (hashCode &* 31) &+ password.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImvalidateReq"
        }
        override public func className() -> String {
            return "Im.Server.ImvalidateReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImvalidateReq = Im.Server.ImvalidateReq()
            public func getMessage() -> Im.Server.ImvalidateReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x0703
            public var userName:String {
                get {
                    return builderResult.userName
                }
                set (value) {
                    builderResult.hasUserName = true
                    builderResult.userName = value
                }
            }
            public var hasUserName:Bool {
                get {
                    return builderResult.hasUserName
                }
            }
            @discardableResult
            public func setUserName(_ value:String) -> Im.Server.ImvalidateReq.Builder {
                self.userName = value
                return self
            }
            @discardableResult
            public func clearUserName() -> Im.Server.ImvalidateReq.Builder{
                builderResult.hasUserName = false
                builderResult.userName = nil
                return self
            }
            public var password:String {
                get {
                    return builderResult.password
                }
                set (value) {
                    builderResult.hasPassword = true
                    builderResult.password = value
                }
            }
            public var hasPassword:Bool {
                get {
                    return builderResult.hasPassword
                }
            }
            @discardableResult
            public func setPassword(_ value:String) -> Im.Server.ImvalidateReq.Builder {
                self.password = value
                return self
            }
            @discardableResult
            public func clearPassword() -> Im.Server.ImvalidateReq.Builder{
                builderResult.hasPassword = false
                builderResult.password = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Server.ImvalidateReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Server.ImvalidateReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImvalidateReq.Builder {
                builderResult = Im.Server.ImvalidateReq()
                return self
            }
            override public func clone() throws -> Im.Server.ImvalidateReq.Builder {
                return try Im.Server.ImvalidateReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImvalidateReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImvalidateReq {
                let returnMe:Im.Server.ImvalidateReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImvalidateReq) throws -> Im.Server.ImvalidateReq.Builder {
                if other == Im.Server.ImvalidateReq() {
                    return self
                }
                if other.hasUserName {
                    userName = other.userName
                }
                if other.hasPassword {
                    password = other.password
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImvalidateReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImvalidateReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        userName = try codedInputStream.readString()

                    case 18:
                        password = try codedInputStream.readString()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImvalidateReq.Builder {
                let resultDecodedBuilder = Im.Server.ImvalidateReq.Builder()
                if let jsonValueUserName = jsonMap["userName"] as? String {
                    resultDecodedBuilder.userName = jsonValueUserName
                }
                if let jsonValuePassword = jsonMap["password"] as? String {
                    resultDecodedBuilder.password = jsonValuePassword
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImvalidateReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImvalidateReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///db_proxy
    final public class ImvalidateRsp : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImvalidateRsp.Builder

        public static func == (lhs: Im.Server.ImvalidateRsp, rhs: Im.Server.ImvalidateRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserName == rhs.hasUserName) && (!lhs.hasUserName || lhs.userName == rhs.userName)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasResultString == rhs.hasResultString) && (!lhs.hasResultString || lhs.resultString == rhs.resultString)
            fieldCheck = fieldCheck && (lhs.hasUserInfo == rhs.hasUserInfo) && (!lhs.hasUserInfo || lhs.userInfo == rhs.userInfo)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x0704
        public fileprivate(set) var userName:String! = nil
        public fileprivate(set) var hasUserName:Bool = false

        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        public fileprivate(set) var resultString:String! = nil
        public fileprivate(set) var hasResultString:Bool = false

        public fileprivate(set) var userInfo:Im.BaseDefine.UserInfo!
        public fileprivate(set) var hasUserInfo:Bool = false
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserName {
                return false
            }
            if !hasResultCode {
                return false
            }
            if hasUserInfo {
                if !userInfo.isInitialized() {
                    return false
                }
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserName {
                try codedOutputStream.writeString(fieldNumber: 1, value:userName)
            }
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:resultCode)
            }
            if hasResultString {
                try codedOutputStream.writeString(fieldNumber: 3, value:resultString)
            }
            if hasUserInfo {
                try codedOutputStream.writeMessage(fieldNumber: 4, value:userInfo)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserName {
                serialize_size += userName.computeStringSize(fieldNumber: 1)
            }
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 2)
            }
            if hasResultString {
                serialize_size += resultString.computeStringSize(fieldNumber: 3)
            }
            if hasUserInfo {
                if let varSizeuserInfo = userInfo?.computeMessageSize(fieldNumber: 4) {
                    serialize_size += varSizeuserInfo
                }
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImvalidateRsp.Builder {
            return Im.Server.ImvalidateRsp.classBuilder() as! Im.Server.ImvalidateRsp.Builder
        }
        public func getBuilder() -> Im.Server.ImvalidateRsp.Builder {
            return classBuilder() as! Im.Server.ImvalidateRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImvalidateRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImvalidateRsp.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImvalidateRsp.Builder {
            return try Im.Server.ImvalidateRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImvalidateRsp) throws -> Im.Server.ImvalidateRsp.Builder {
            return try Im.Server.ImvalidateRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserName {
                jsonMap["userName"] = userName
            }
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            if hasResultString {
                jsonMap["resultString"] = resultString
            }
            if hasUserInfo {
                jsonMap["userInfo"] = try userInfo.encode()
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImvalidateRsp {
            return try Im.Server.ImvalidateRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImvalidateRsp {
            return try Im.Server.ImvalidateRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserName {
                output += "\(indent) userName: \(userName) \n"
            }
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            if hasResultString {
                output += "\(indent) resultString: \(resultString) \n"
            }
            if hasUserInfo {
                output += "\(indent) userInfo {\n"
                if let outDescUserInfo = userInfo {
                    output += try outDescUserInfo.getDescription(indent: "\(indent)  ")
                }
                output += "\(indent) }\n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserName {
                    hashCode = (hashCode &* 31) &+ userName.hashValue
                }
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasResultString {
                    hashCode = (hashCode &* 31) &+ resultString.hashValue
                }
                if hasUserInfo {
                    if let hashValueuserInfo = userInfo?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueuserInfo
                    }
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImvalidateRsp"
        }
        override public func className() -> String {
            return "Im.Server.ImvalidateRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImvalidateRsp = Im.Server.ImvalidateRsp()
            public func getMessage() -> Im.Server.ImvalidateRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x0704
            public var userName:String {
                get {
                    return builderResult.userName
                }
                set (value) {
                    builderResult.hasUserName = true
                    builderResult.userName = value
                }
            }
            public var hasUserName:Bool {
                get {
                    return builderResult.hasUserName
                }
            }
            @discardableResult
            public func setUserName(_ value:String) -> Im.Server.ImvalidateRsp.Builder {
                self.userName = value
                return self
            }
            @discardableResult
            public func clearUserName() -> Im.Server.ImvalidateRsp.Builder{
                builderResult.hasUserName = false
                builderResult.userName = nil
                return self
            }
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.Server.ImvalidateRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.Server.ImvalidateRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            public var resultString:String {
                get {
                    return builderResult.resultString
                }
                set (value) {
                    builderResult.hasResultString = true
                    builderResult.resultString = value
                }
            }
            public var hasResultString:Bool {
                get {
                    return builderResult.hasResultString
                }
            }
            @discardableResult
            public func setResultString(_ value:String) -> Im.Server.ImvalidateRsp.Builder {
                self.resultString = value
                return self
            }
            @discardableResult
            public func clearResultString() -> Im.Server.ImvalidateRsp.Builder{
                builderResult.hasResultString = false
                builderResult.resultString = nil
                return self
            }
            public var userInfo:Im.BaseDefine.UserInfo! {
                get {
                    if userInfoBuilder_ != nil {
                        builderResult.userInfo = userInfoBuilder_.getMessage()
                    }
                    return builderResult.userInfo
                }
                set (value) {
                    builderResult.hasUserInfo = true
                    builderResult.userInfo = value
                }
            }
            public var hasUserInfo:Bool {
                get {
                    return builderResult.hasUserInfo
                }
            }
            fileprivate var userInfoBuilder_:Im.BaseDefine.UserInfo.Builder! {
                didSet {
                    builderResult.hasUserInfo = true
                }
            }
            public func getUserInfoBuilder() -> Im.BaseDefine.UserInfo.Builder {
                if userInfoBuilder_ == nil {
                    userInfoBuilder_ = Im.BaseDefine.UserInfo.Builder()
                    builderResult.userInfo = userInfoBuilder_.getMessage()
                    if userInfo != nil {
                        try! userInfoBuilder_.mergeFrom(other: userInfo)
                    }
                }
                return userInfoBuilder_
            }
            @discardableResult
            public func setUserInfo(_ value:Im.BaseDefine.UserInfo!) -> Im.Server.ImvalidateRsp.Builder {
                self.userInfo = value
                return self
            }
            @discardableResult
            public func mergeUserInfo(value:Im.BaseDefine.UserInfo) throws -> Im.Server.ImvalidateRsp.Builder {
                if builderResult.hasUserInfo {
                    builderResult.userInfo = try Im.BaseDefine.UserInfo.builderWithPrototype(prototype:builderResult.userInfo).mergeFrom(other: value).buildPartial()
                } else {
                    builderResult.userInfo = value
                }
                builderResult.hasUserInfo = true
                return self
            }
            @discardableResult
            public func clearUserInfo() -> Im.Server.ImvalidateRsp.Builder {
                userInfoBuilder_ = nil
                builderResult.hasUserInfo = false
                builderResult.userInfo = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Server.ImvalidateRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Server.ImvalidateRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImvalidateRsp.Builder {
                builderResult = Im.Server.ImvalidateRsp()
                return self
            }
            override public func clone() throws -> Im.Server.ImvalidateRsp.Builder {
                return try Im.Server.ImvalidateRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImvalidateRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImvalidateRsp {
                let returnMe:Im.Server.ImvalidateRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImvalidateRsp) throws -> Im.Server.ImvalidateRsp.Builder {
                if other == Im.Server.ImvalidateRsp() {
                    return self
                }
                if other.hasUserName {
                    userName = other.userName
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasResultString {
                    resultString = other.resultString
                }
                if (other.hasUserInfo) {
                    try mergeUserInfo(value: other.userInfo)
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImvalidateRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImvalidateRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        userName = try codedInputStream.readString()

                    case 16:
                        resultCode = try codedInputStream.readUInt32()

                    case 26:
                        resultString = try codedInputStream.readString()

                    case 34:
                        let subBuilder:Im.BaseDefine.UserInfo.Builder = Im.BaseDefine.UserInfo.Builder()
                        if hasUserInfo {
                            try subBuilder.mergeFrom(other: userInfo)
                        }
                        try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                        userInfo = subBuilder.buildPartial()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImvalidateRsp.Builder {
                let resultDecodedBuilder = Im.Server.ImvalidateRsp.Builder()
                if let jsonValueUserName = jsonMap["userName"] as? String {
                    resultDecodedBuilder.userName = jsonValueUserName
                }
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                if let jsonValueResultString = jsonMap["resultString"] as? String {
                    resultDecodedBuilder.resultString = jsonValueResultString
                }
                if let jsonValueUserInfo = jsonMap["userInfo"] as? Dictionary<String,Any> {
                    resultDecodedBuilder.userInfo = try Im.BaseDefine.UserInfo.Builder.decodeToBuilder(jsonMap:jsonValueUserInfo).build()

                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImvalidateRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImvalidateRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///db_proxy
    final public class ImgetDeviceTokenReq : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImgetDeviceTokenReq.Builder

        public static func == (lhs: Im.Server.ImgetDeviceTokenReq, rhs: Im.Server.ImgetDeviceTokenReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x0705
        public fileprivate(set) var userId:Array<UInt32> = Array<UInt32>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if !userId.isEmpty {
                for oneValueuserId in userId {
                    try codedOutputStream.writeUInt32(fieldNumber: 1, value:oneValueuserId)
                }
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            var dataSizeUserId:Int32 = 0
            for oneValueuserId in userId {
                dataSizeUserId += oneValueuserId.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeUserId
            serialize_size += 1 * Int32(userId.count)
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImgetDeviceTokenReq.Builder {
            return Im.Server.ImgetDeviceTokenReq.classBuilder() as! Im.Server.ImgetDeviceTokenReq.Builder
        }
        public func getBuilder() -> Im.Server.ImgetDeviceTokenReq.Builder {
            return classBuilder() as! Im.Server.ImgetDeviceTokenReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImgetDeviceTokenReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImgetDeviceTokenReq.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImgetDeviceTokenReq.Builder {
            return try Im.Server.ImgetDeviceTokenReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImgetDeviceTokenReq) throws -> Im.Server.ImgetDeviceTokenReq.Builder {
            return try Im.Server.ImgetDeviceTokenReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !userId.isEmpty {
                var jsonArrayUserId:Array<UInt> = []
                for oneValueUserId in userId {
                    jsonArrayUserId.append(UInt(oneValueUserId))
                }
                jsonMap["userId"] = jsonArrayUserId
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImgetDeviceTokenReq {
            return try Im.Server.ImgetDeviceTokenReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImgetDeviceTokenReq {
            return try Im.Server.ImgetDeviceTokenReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var userIdElementIndex:Int = 0
            for oneValueUserId in userId  {
                output += "\(indent) userId[\(userIdElementIndex)]: \(oneValueUserId)\n"
                userIdElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneValueUserId in userId {
                    hashCode = (hashCode &* 31) &+ oneValueUserId.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImgetDeviceTokenReq"
        }
        override public func className() -> String {
            return "Im.Server.ImgetDeviceTokenReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImgetDeviceTokenReq = Im.Server.ImgetDeviceTokenReq()
            public func getMessage() -> Im.Server.ImgetDeviceTokenReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x0705
            public var userId:Array<UInt32> {
                get {
                    return builderResult.userId
                }
                set (array) {
                    builderResult.userId = array
                }
            }
            @discardableResult
            public func setUserId(_ value:Array<UInt32>) -> Im.Server.ImgetDeviceTokenReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Server.ImgetDeviceTokenReq.Builder {
                builderResult.userId.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Server.ImgetDeviceTokenReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Server.ImgetDeviceTokenReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImgetDeviceTokenReq.Builder {
                builderResult = Im.Server.ImgetDeviceTokenReq()
                return self
            }
            override public func clone() throws -> Im.Server.ImgetDeviceTokenReq.Builder {
                return try Im.Server.ImgetDeviceTokenReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImgetDeviceTokenReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImgetDeviceTokenReq {
                let returnMe:Im.Server.ImgetDeviceTokenReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImgetDeviceTokenReq) throws -> Im.Server.ImgetDeviceTokenReq.Builder {
                if other == Im.Server.ImgetDeviceTokenReq() {
                    return self
                }
                if !other.userId.isEmpty {
                    builderResult.userId += other.userId
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImgetDeviceTokenReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgetDeviceTokenReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId += [try codedInputStream.readUInt32()]

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImgetDeviceTokenReq.Builder {
                let resultDecodedBuilder = Im.Server.ImgetDeviceTokenReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? Array<UInt> {
                    var jsonArrayUserId:Array<UInt32> = []
                    for oneValueUserId in jsonValueUserId {
                        jsonArrayUserId.append(UInt32(oneValueUserId))
                    }
                    resultDecodedBuilder.userId = jsonArrayUserId
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImgetDeviceTokenReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImgetDeviceTokenReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///db_proxy
    final public class ImgetDeviceTokenRsp : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImgetDeviceTokenRsp.Builder

        public static func == (lhs: Im.Server.ImgetDeviceTokenRsp, rhs: Im.Server.ImgetDeviceTokenRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.userTokenInfo == rhs.userTokenInfo)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userTokenInfo:Array<Im.BaseDefine.UserTokenInfo>  = Array<Im.BaseDefine.UserTokenInfo>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitUserTokenInfo:Bool = true
            for oneElementUserTokenInfo in userTokenInfo {
                if !oneElementUserTokenInfo.isInitialized() {
                    isInitUserTokenInfo = false
                    break 
                }
            }
            if !isInitUserTokenInfo {
                return isInitUserTokenInfo
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementUserTokenInfo in userTokenInfo {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementUserTokenInfo)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementUserTokenInfo in userTokenInfo {
                serialize_size += oneElementUserTokenInfo.computeMessageSize(fieldNumber: 1)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImgetDeviceTokenRsp.Builder {
            return Im.Server.ImgetDeviceTokenRsp.classBuilder() as! Im.Server.ImgetDeviceTokenRsp.Builder
        }
        public func getBuilder() -> Im.Server.ImgetDeviceTokenRsp.Builder {
            return classBuilder() as! Im.Server.ImgetDeviceTokenRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImgetDeviceTokenRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImgetDeviceTokenRsp.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImgetDeviceTokenRsp.Builder {
            return try Im.Server.ImgetDeviceTokenRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImgetDeviceTokenRsp) throws -> Im.Server.ImgetDeviceTokenRsp.Builder {
            return try Im.Server.ImgetDeviceTokenRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !userTokenInfo.isEmpty {
                var jsonArrayUserTokenInfo:Array<Dictionary<String,Any>> = []
                for oneValueUserTokenInfo in userTokenInfo {
                    let ecodedMessageUserTokenInfo = try oneValueUserTokenInfo.encode()
                    jsonArrayUserTokenInfo.append(ecodedMessageUserTokenInfo)
                }
                jsonMap["userTokenInfo"] = jsonArrayUserTokenInfo
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImgetDeviceTokenRsp {
            return try Im.Server.ImgetDeviceTokenRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImgetDeviceTokenRsp {
            return try Im.Server.ImgetDeviceTokenRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var userTokenInfoElementIndex:Int = 0
            for oneElementUserTokenInfo in userTokenInfo {
                output += "\(indent) userTokenInfo[\(userTokenInfoElementIndex)] {\n"
                output += try oneElementUserTokenInfo.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                userTokenInfoElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementUserTokenInfo in userTokenInfo {
                    hashCode = (hashCode &* 31) &+ oneElementUserTokenInfo.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImgetDeviceTokenRsp"
        }
        override public func className() -> String {
            return "Im.Server.ImgetDeviceTokenRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImgetDeviceTokenRsp = Im.Server.ImgetDeviceTokenRsp()
            public func getMessage() -> Im.Server.ImgetDeviceTokenRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x0706
            public var userTokenInfo:Array<Im.BaseDefine.UserTokenInfo> {
                get {
                    return builderResult.userTokenInfo
                }
                set (value) {
                    builderResult.userTokenInfo = value
                }
            }
            @discardableResult
            public func setUserTokenInfo(_ value:Array<Im.BaseDefine.UserTokenInfo>) -> Im.Server.ImgetDeviceTokenRsp.Builder {
                self.userTokenInfo = value
                return self
            }
            @discardableResult
            public func clearUserTokenInfo() -> Im.Server.ImgetDeviceTokenRsp.Builder {
                builderResult.userTokenInfo.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Server.ImgetDeviceTokenRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Server.ImgetDeviceTokenRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImgetDeviceTokenRsp.Builder {
                builderResult = Im.Server.ImgetDeviceTokenRsp()
                return self
            }
            override public func clone() throws -> Im.Server.ImgetDeviceTokenRsp.Builder {
                return try Im.Server.ImgetDeviceTokenRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImgetDeviceTokenRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImgetDeviceTokenRsp {
                let returnMe:Im.Server.ImgetDeviceTokenRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImgetDeviceTokenRsp) throws -> Im.Server.ImgetDeviceTokenRsp.Builder {
                if other == Im.Server.ImgetDeviceTokenRsp() {
                    return self
                }
                if !other.userTokenInfo.isEmpty  {
                     builderResult.userTokenInfo += other.userTokenInfo
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImgetDeviceTokenRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgetDeviceTokenRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Im.BaseDefine.UserTokenInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        userTokenInfo.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImgetDeviceTokenRsp.Builder {
                let resultDecodedBuilder = Im.Server.ImgetDeviceTokenRsp.Builder()
                if let jsonValueUserTokenInfo = jsonMap["userTokenInfo"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayUserTokenInfo:Array<Im.BaseDefine.UserTokenInfo> = []
                    for oneValueUserTokenInfo in jsonValueUserTokenInfo {
                        let messageFromStringUserTokenInfo = try Im.BaseDefine.UserTokenInfo.Builder.decodeToBuilder(jsonMap:oneValueUserTokenInfo).build()

                        jsonArrayUserTokenInfo.append(messageFromStringUserTokenInfo)
                    }
                    resultDecodedBuilder.userTokenInfo = jsonArrayUserTokenInfo
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImgetDeviceTokenRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImgetDeviceTokenRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImroleSet : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImroleSet.Builder

        public static func == (lhs: Im.Server.ImroleSet, rhs: Im.Server.ImroleSet) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMaster == rhs.hasMaster) && (!lhs.hasMaster || lhs.master == rhs.master)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x0707
        public fileprivate(set) var master:UInt32! = nil
        public fileprivate(set) var hasMaster:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasMaster {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMaster {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:master)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMaster {
                serialize_size += master.computeUInt32Size(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImroleSet.Builder {
            return Im.Server.ImroleSet.classBuilder() as! Im.Server.ImroleSet.Builder
        }
        public func getBuilder() -> Im.Server.ImroleSet.Builder {
            return classBuilder() as! Im.Server.ImroleSet.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImroleSet.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImroleSet.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImroleSet.Builder {
            return try Im.Server.ImroleSet.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImroleSet) throws -> Im.Server.ImroleSet.Builder {
            return try Im.Server.ImroleSet.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMaster {
                jsonMap["master"] = UInt(master)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImroleSet {
            return try Im.Server.ImroleSet.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImroleSet {
            return try Im.Server.ImroleSet.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMaster {
                output += "\(indent) master: \(master) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMaster {
                    hashCode = (hashCode &* 31) &+ master.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImroleSet"
        }
        override public func className() -> String {
            return "Im.Server.ImroleSet"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImroleSet = Im.Server.ImroleSet()
            public func getMessage() -> Im.Server.ImroleSet {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x0707
            public var master:UInt32 {
                get {
                    return builderResult.master
                }
                set (value) {
                    builderResult.hasMaster = true
                    builderResult.master = value
                }
            }
            public var hasMaster:Bool {
                get {
                    return builderResult.hasMaster
                }
            }
            @discardableResult
            public func setMaster(_ value:UInt32) -> Im.Server.ImroleSet.Builder {
                self.master = value
                return self
            }
            @discardableResult
            public func clearMaster() -> Im.Server.ImroleSet.Builder{
                builderResult.hasMaster = false
                builderResult.master = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImroleSet.Builder {
                builderResult = Im.Server.ImroleSet()
                return self
            }
            override public func clone() throws -> Im.Server.ImroleSet.Builder {
                return try Im.Server.ImroleSet.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImroleSet {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImroleSet {
                let returnMe:Im.Server.ImroleSet = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImroleSet) throws -> Im.Server.ImroleSet.Builder {
                if other == Im.Server.ImroleSet() {
                    return self
                }
                if other.hasMaster {
                    master = other.master
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImroleSet.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImroleSet.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        master = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImroleSet.Builder {
                let resultDecodedBuilder = Im.Server.ImroleSet.Builder()
                if let jsonValueMaster = jsonMap["master"] as? UInt {
                    resultDecodedBuilder.master = UInt32(jsonValueMaster)
                } else if let jsonValueMaster = jsonMap["master"] as? String {
                    resultDecodedBuilder.master = UInt32(jsonValueMaster)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImroleSet.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImroleSet.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImonlineUserInfo : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImonlineUserInfo.Builder

        public static func == (lhs: Im.Server.ImonlineUserInfo, rhs: Im.Server.ImonlineUserInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.userStatList == rhs.userStatList)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userStatList:Array<Im.BaseDefine.ServerUserStat>  = Array<Im.BaseDefine.ServerUserStat>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitUserStatList:Bool = true
            for oneElementUserStatList in userStatList {
                if !oneElementUserStatList.isInitialized() {
                    isInitUserStatList = false
                    break 
                }
            }
            if !isInitUserStatList {
                return isInitUserStatList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementUserStatList in userStatList {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementUserStatList)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementUserStatList in userStatList {
                serialize_size += oneElementUserStatList.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImonlineUserInfo.Builder {
            return Im.Server.ImonlineUserInfo.classBuilder() as! Im.Server.ImonlineUserInfo.Builder
        }
        public func getBuilder() -> Im.Server.ImonlineUserInfo.Builder {
            return classBuilder() as! Im.Server.ImonlineUserInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImonlineUserInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImonlineUserInfo.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImonlineUserInfo.Builder {
            return try Im.Server.ImonlineUserInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImonlineUserInfo) throws -> Im.Server.ImonlineUserInfo.Builder {
            return try Im.Server.ImonlineUserInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !userStatList.isEmpty {
                var jsonArrayUserStatList:Array<Dictionary<String,Any>> = []
                for oneValueUserStatList in userStatList {
                    let ecodedMessageUserStatList = try oneValueUserStatList.encode()
                    jsonArrayUserStatList.append(ecodedMessageUserStatList)
                }
                jsonMap["userStatList"] = jsonArrayUserStatList
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImonlineUserInfo {
            return try Im.Server.ImonlineUserInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImonlineUserInfo {
            return try Im.Server.ImonlineUserInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var userStatListElementIndex:Int = 0
            for oneElementUserStatList in userStatList {
                output += "\(indent) userStatList[\(userStatListElementIndex)] {\n"
                output += try oneElementUserStatList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                userStatListElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementUserStatList in userStatList {
                    hashCode = (hashCode &* 31) &+ oneElementUserStatList.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImonlineUserInfo"
        }
        override public func className() -> String {
            return "Im.Server.ImonlineUserInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImonlineUserInfo = Im.Server.ImonlineUserInfo()
            public func getMessage() -> Im.Server.ImonlineUserInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x0708
            public var userStatList:Array<Im.BaseDefine.ServerUserStat> {
                get {
                    return builderResult.userStatList
                }
                set (value) {
                    builderResult.userStatList = value
                }
            }
            @discardableResult
            public func setUserStatList(_ value:Array<Im.BaseDefine.ServerUserStat>) -> Im.Server.ImonlineUserInfo.Builder {
                self.userStatList = value
                return self
            }
            @discardableResult
            public func clearUserStatList() -> Im.Server.ImonlineUserInfo.Builder {
                builderResult.userStatList.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImonlineUserInfo.Builder {
                builderResult = Im.Server.ImonlineUserInfo()
                return self
            }
            override public func clone() throws -> Im.Server.ImonlineUserInfo.Builder {
                return try Im.Server.ImonlineUserInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImonlineUserInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImonlineUserInfo {
                let returnMe:Im.Server.ImonlineUserInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImonlineUserInfo) throws -> Im.Server.ImonlineUserInfo.Builder {
                if other == Im.Server.ImonlineUserInfo() {
                    return self
                }
                if !other.userStatList.isEmpty  {
                     builderResult.userStatList += other.userStatList
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImonlineUserInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImonlineUserInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Im.BaseDefine.ServerUserStat.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        userStatList.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImonlineUserInfo.Builder {
                let resultDecodedBuilder = Im.Server.ImonlineUserInfo.Builder()
                if let jsonValueUserStatList = jsonMap["userStatList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayUserStatList:Array<Im.BaseDefine.ServerUserStat> = []
                    for oneValueUserStatList in jsonValueUserStatList {
                        let messageFromStringUserStatList = try Im.BaseDefine.ServerUserStat.Builder.decodeToBuilder(jsonMap:oneValueUserStatList).build()

                        jsonArrayUserStatList.append(messageFromStringUserStatList)
                    }
                    resultDecodedBuilder.userStatList = jsonArrayUserStatList
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImonlineUserInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImonlineUserInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImmsgServInfo : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImmsgServInfo.Builder

        public static func == (lhs: Im.Server.ImmsgServInfo, rhs: Im.Server.ImmsgServInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasIp1 == rhs.hasIp1) && (!lhs.hasIp1 || lhs.ip1 == rhs.ip1)
            fieldCheck = fieldCheck && (lhs.hasIp2 == rhs.hasIp2) && (!lhs.hasIp2 || lhs.ip2 == rhs.ip2)
            fieldCheck = fieldCheck && (lhs.hasPort == rhs.hasPort) && (!lhs.hasPort || lhs.port == rhs.port)
            fieldCheck = fieldCheck && (lhs.hasMaxConnCnt == rhs.hasMaxConnCnt) && (!lhs.hasMaxConnCnt || lhs.maxConnCnt == rhs.maxConnCnt)
            fieldCheck = fieldCheck && (lhs.hasCurConnCnt == rhs.hasCurConnCnt) && (!lhs.hasCurConnCnt || lhs.curConnCnt == rhs.curConnCnt)
            fieldCheck = fieldCheck && (lhs.hasHostName == rhs.hasHostName) && (!lhs.hasHostName || lhs.hostName == rhs.hostName)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x0709
        public fileprivate(set) var ip1:String! = nil
        public fileprivate(set) var hasIp1:Bool = false

        public fileprivate(set) var ip2:String! = nil
        public fileprivate(set) var hasIp2:Bool = false

        public fileprivate(set) var port:UInt32! = nil
        public fileprivate(set) var hasPort:Bool = false

        public fileprivate(set) var maxConnCnt:UInt32! = nil
        public fileprivate(set) var hasMaxConnCnt:Bool = false

        public fileprivate(set) var curConnCnt:UInt32! = nil
        public fileprivate(set) var hasCurConnCnt:Bool = false

        public fileprivate(set) var hostName:String! = nil
        public fileprivate(set) var hasHostName:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasIp1 {
                return false
            }
            if !hasIp2 {
                return false
            }
            if !hasPort {
                return false
            }
            if !hasMaxConnCnt {
                return false
            }
            if !hasCurConnCnt {
                return false
            }
            if !hasHostName {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasIp1 {
                try codedOutputStream.writeString(fieldNumber: 1, value:ip1)
            }
            if hasIp2 {
                try codedOutputStream.writeString(fieldNumber: 2, value:ip2)
            }
            if hasPort {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:port)
            }
            if hasMaxConnCnt {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:maxConnCnt)
            }
            if hasCurConnCnt {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:curConnCnt)
            }
            if hasHostName {
                try codedOutputStream.writeString(fieldNumber: 6, value:hostName)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasIp1 {
                serialize_size += ip1.computeStringSize(fieldNumber: 1)
            }
            if hasIp2 {
                serialize_size += ip2.computeStringSize(fieldNumber: 2)
            }
            if hasPort {
                serialize_size += port.computeUInt32Size(fieldNumber: 3)
            }
            if hasMaxConnCnt {
                serialize_size += maxConnCnt.computeUInt32Size(fieldNumber: 4)
            }
            if hasCurConnCnt {
                serialize_size += curConnCnt.computeUInt32Size(fieldNumber: 5)
            }
            if hasHostName {
                serialize_size += hostName.computeStringSize(fieldNumber: 6)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImmsgServInfo.Builder {
            return Im.Server.ImmsgServInfo.classBuilder() as! Im.Server.ImmsgServInfo.Builder
        }
        public func getBuilder() -> Im.Server.ImmsgServInfo.Builder {
            return classBuilder() as! Im.Server.ImmsgServInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImmsgServInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImmsgServInfo.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImmsgServInfo.Builder {
            return try Im.Server.ImmsgServInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImmsgServInfo) throws -> Im.Server.ImmsgServInfo.Builder {
            return try Im.Server.ImmsgServInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasIp1 {
                jsonMap["ip1"] = ip1
            }
            if hasIp2 {
                jsonMap["ip2"] = ip2
            }
            if hasPort {
                jsonMap["port"] = UInt(port)
            }
            if hasMaxConnCnt {
                jsonMap["maxConnCnt"] = UInt(maxConnCnt)
            }
            if hasCurConnCnt {
                jsonMap["curConnCnt"] = UInt(curConnCnt)
            }
            if hasHostName {
                jsonMap["hostName"] = hostName
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImmsgServInfo {
            return try Im.Server.ImmsgServInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImmsgServInfo {
            return try Im.Server.ImmsgServInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasIp1 {
                output += "\(indent) ip1: \(ip1) \n"
            }
            if hasIp2 {
                output += "\(indent) ip2: \(ip2) \n"
            }
            if hasPort {
                output += "\(indent) port: \(port) \n"
            }
            if hasMaxConnCnt {
                output += "\(indent) maxConnCnt: \(maxConnCnt) \n"
            }
            if hasCurConnCnt {
                output += "\(indent) curConnCnt: \(curConnCnt) \n"
            }
            if hasHostName {
                output += "\(indent) hostName: \(hostName) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasIp1 {
                    hashCode = (hashCode &* 31) &+ ip1.hashValue
                }
                if hasIp2 {
                    hashCode = (hashCode &* 31) &+ ip2.hashValue
                }
                if hasPort {
                    hashCode = (hashCode &* 31) &+ port.hashValue
                }
                if hasMaxConnCnt {
                    hashCode = (hashCode &* 31) &+ maxConnCnt.hashValue
                }
                if hasCurConnCnt {
                    hashCode = (hashCode &* 31) &+ curConnCnt.hashValue
                }
                if hasHostName {
                    hashCode = (hashCode &* 31) &+ hostName.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImmsgServInfo"
        }
        override public func className() -> String {
            return "Im.Server.ImmsgServInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImmsgServInfo = Im.Server.ImmsgServInfo()
            public func getMessage() -> Im.Server.ImmsgServInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x0709
            public var ip1:String {
                get {
                    return builderResult.ip1
                }
                set (value) {
                    builderResult.hasIp1 = true
                    builderResult.ip1 = value
                }
            }
            public var hasIp1:Bool {
                get {
                    return builderResult.hasIp1
                }
            }
            @discardableResult
            public func setIp1(_ value:String) -> Im.Server.ImmsgServInfo.Builder {
                self.ip1 = value
                return self
            }
            @discardableResult
            public func clearIp1() -> Im.Server.ImmsgServInfo.Builder{
                builderResult.hasIp1 = false
                builderResult.ip1 = nil
                return self
            }
            public var ip2:String {
                get {
                    return builderResult.ip2
                }
                set (value) {
                    builderResult.hasIp2 = true
                    builderResult.ip2 = value
                }
            }
            public var hasIp2:Bool {
                get {
                    return builderResult.hasIp2
                }
            }
            @discardableResult
            public func setIp2(_ value:String) -> Im.Server.ImmsgServInfo.Builder {
                self.ip2 = value
                return self
            }
            @discardableResult
            public func clearIp2() -> Im.Server.ImmsgServInfo.Builder{
                builderResult.hasIp2 = false
                builderResult.ip2 = nil
                return self
            }
            public var port:UInt32 {
                get {
                    return builderResult.port
                }
                set (value) {
                    builderResult.hasPort = true
                    builderResult.port = value
                }
            }
            public var hasPort:Bool {
                get {
                    return builderResult.hasPort
                }
            }
            @discardableResult
            public func setPort(_ value:UInt32) -> Im.Server.ImmsgServInfo.Builder {
                self.port = value
                return self
            }
            @discardableResult
            public func clearPort() -> Im.Server.ImmsgServInfo.Builder{
                builderResult.hasPort = false
                builderResult.port = nil
                return self
            }
            public var maxConnCnt:UInt32 {
                get {
                    return builderResult.maxConnCnt
                }
                set (value) {
                    builderResult.hasMaxConnCnt = true
                    builderResult.maxConnCnt = value
                }
            }
            public var hasMaxConnCnt:Bool {
                get {
                    return builderResult.hasMaxConnCnt
                }
            }
            @discardableResult
            public func setMaxConnCnt(_ value:UInt32) -> Im.Server.ImmsgServInfo.Builder {
                self.maxConnCnt = value
                return self
            }
            @discardableResult
            public func clearMaxConnCnt() -> Im.Server.ImmsgServInfo.Builder{
                builderResult.hasMaxConnCnt = false
                builderResult.maxConnCnt = nil
                return self
            }
            public var curConnCnt:UInt32 {
                get {
                    return builderResult.curConnCnt
                }
                set (value) {
                    builderResult.hasCurConnCnt = true
                    builderResult.curConnCnt = value
                }
            }
            public var hasCurConnCnt:Bool {
                get {
                    return builderResult.hasCurConnCnt
                }
            }
            @discardableResult
            public func setCurConnCnt(_ value:UInt32) -> Im.Server.ImmsgServInfo.Builder {
                self.curConnCnt = value
                return self
            }
            @discardableResult
            public func clearCurConnCnt() -> Im.Server.ImmsgServInfo.Builder{
                builderResult.hasCurConnCnt = false
                builderResult.curConnCnt = nil
                return self
            }
            public var hostName:String {
                get {
                    return builderResult.hostName
                }
                set (value) {
                    builderResult.hasHostName = true
                    builderResult.hostName = value
                }
            }
            public var hasHostName:Bool {
                get {
                    return builderResult.hasHostName
                }
            }
            @discardableResult
            public func setHostName(_ value:String) -> Im.Server.ImmsgServInfo.Builder {
                self.hostName = value
                return self
            }
            @discardableResult
            public func clearHostName() -> Im.Server.ImmsgServInfo.Builder{
                builderResult.hasHostName = false
                builderResult.hostName = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImmsgServInfo.Builder {
                builderResult = Im.Server.ImmsgServInfo()
                return self
            }
            override public func clone() throws -> Im.Server.ImmsgServInfo.Builder {
                return try Im.Server.ImmsgServInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImmsgServInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImmsgServInfo {
                let returnMe:Im.Server.ImmsgServInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImmsgServInfo) throws -> Im.Server.ImmsgServInfo.Builder {
                if other == Im.Server.ImmsgServInfo() {
                    return self
                }
                if other.hasIp1 {
                    ip1 = other.ip1
                }
                if other.hasIp2 {
                    ip2 = other.ip2
                }
                if other.hasPort {
                    port = other.port
                }
                if other.hasMaxConnCnt {
                    maxConnCnt = other.maxConnCnt
                }
                if other.hasCurConnCnt {
                    curConnCnt = other.curConnCnt
                }
                if other.hasHostName {
                    hostName = other.hostName
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImmsgServInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImmsgServInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        ip1 = try codedInputStream.readString()

                    case 18:
                        ip2 = try codedInputStream.readString()

                    case 24:
                        port = try codedInputStream.readUInt32()

                    case 32:
                        maxConnCnt = try codedInputStream.readUInt32()

                    case 40:
                        curConnCnt = try codedInputStream.readUInt32()

                    case 50:
                        hostName = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImmsgServInfo.Builder {
                let resultDecodedBuilder = Im.Server.ImmsgServInfo.Builder()
                if let jsonValueIp1 = jsonMap["ip1"] as? String {
                    resultDecodedBuilder.ip1 = jsonValueIp1
                }
                if let jsonValueIp2 = jsonMap["ip2"] as? String {
                    resultDecodedBuilder.ip2 = jsonValueIp2
                }
                if let jsonValuePort = jsonMap["port"] as? UInt {
                    resultDecodedBuilder.port = UInt32(jsonValuePort)
                } else if let jsonValuePort = jsonMap["port"] as? String {
                    resultDecodedBuilder.port = UInt32(jsonValuePort)!
                }
                if let jsonValueMaxConnCnt = jsonMap["maxConnCnt"] as? UInt {
                    resultDecodedBuilder.maxConnCnt = UInt32(jsonValueMaxConnCnt)
                } else if let jsonValueMaxConnCnt = jsonMap["maxConnCnt"] as? String {
                    resultDecodedBuilder.maxConnCnt = UInt32(jsonValueMaxConnCnt)!
                }
                if let jsonValueCurConnCnt = jsonMap["curConnCnt"] as? UInt {
                    resultDecodedBuilder.curConnCnt = UInt32(jsonValueCurConnCnt)
                } else if let jsonValueCurConnCnt = jsonMap["curConnCnt"] as? String {
                    resultDecodedBuilder.curConnCnt = UInt32(jsonValueCurConnCnt)!
                }
                if let jsonValueHostName = jsonMap["hostName"] as? String {
                    resultDecodedBuilder.hostName = jsonValueHostName
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImmsgServInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImmsgServInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImuserStatusUpdate : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImuserStatusUpdate.Builder

        public static func == (lhs: Im.Server.ImuserStatusUpdate, rhs: Im.Server.ImuserStatusUpdate) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserStatus == rhs.hasUserStatus) && (!lhs.hasUserStatus || lhs.userStatus == rhs.userStatus)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasClientType == rhs.hasClientType) && (!lhs.hasClientType || lhs.clientType == rhs.clientType)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x070a
        public fileprivate(set) var userStatus:UInt32! = nil
        public fileprivate(set) var hasUserStatus:Bool = false

        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var clientType:Im.BaseDefine.ClientType = Im.BaseDefine.ClientType.clientTypeWindows
        public fileprivate(set) var hasClientType:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserStatus {
                return false
            }
            if !hasUserId {
                return false
            }
            if !hasClientType {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserStatus {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userStatus)
            }
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:userId)
            }
            if hasClientType {
                try codedOutputStream.writeEnum(fieldNumber: 3, value:clientType.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserStatus {
                serialize_size += userStatus.computeUInt32Size(fieldNumber: 1)
            }
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 2)
            }
            if (hasClientType) {
                serialize_size += clientType.rawValue.computeEnumSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImuserStatusUpdate.Builder {
            return Im.Server.ImuserStatusUpdate.classBuilder() as! Im.Server.ImuserStatusUpdate.Builder
        }
        public func getBuilder() -> Im.Server.ImuserStatusUpdate.Builder {
            return classBuilder() as! Im.Server.ImuserStatusUpdate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImuserStatusUpdate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImuserStatusUpdate.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImuserStatusUpdate.Builder {
            return try Im.Server.ImuserStatusUpdate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImuserStatusUpdate) throws -> Im.Server.ImuserStatusUpdate.Builder {
            return try Im.Server.ImuserStatusUpdate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserStatus {
                jsonMap["userStatus"] = UInt(userStatus)
            }
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasClientType {
                jsonMap["clientType"] = clientType.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImuserStatusUpdate {
            return try Im.Server.ImuserStatusUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImuserStatusUpdate {
            return try Im.Server.ImuserStatusUpdate.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserStatus {
                output += "\(indent) userStatus: \(userStatus) \n"
            }
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasClientType) {
                output += "\(indent) clientType: \(clientType.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserStatus {
                    hashCode = (hashCode &* 31) &+ userStatus.hashValue
                }
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasClientType {
                     hashCode = (hashCode &* 31) &+ clientType.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImuserStatusUpdate"
        }
        override public func className() -> String {
            return "Im.Server.ImuserStatusUpdate"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImuserStatusUpdate = Im.Server.ImuserStatusUpdate()
            public func getMessage() -> Im.Server.ImuserStatusUpdate {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x070a
            public var userStatus:UInt32 {
                get {
                    return builderResult.userStatus
                }
                set (value) {
                    builderResult.hasUserStatus = true
                    builderResult.userStatus = value
                }
            }
            public var hasUserStatus:Bool {
                get {
                    return builderResult.hasUserStatus
                }
            }
            @discardableResult
            public func setUserStatus(_ value:UInt32) -> Im.Server.ImuserStatusUpdate.Builder {
                self.userStatus = value
                return self
            }
            @discardableResult
            public func clearUserStatus() -> Im.Server.ImuserStatusUpdate.Builder{
                builderResult.hasUserStatus = false
                builderResult.userStatus = nil
                return self
            }
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Server.ImuserStatusUpdate.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Server.ImuserStatusUpdate.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var clientType:Im.BaseDefine.ClientType {
                    get {
                        return builderResult.clientType
                    }
                    set (value) {
                        builderResult.hasClientType = true
                        builderResult.clientType = value
                    }
                }
                public var hasClientType:Bool{
                    get {
                        return builderResult.hasClientType
                    }
                }
            @discardableResult
                public func setClientType(_ value:Im.BaseDefine.ClientType) -> Im.Server.ImuserStatusUpdate.Builder {
                  self.clientType = value
                  return self
                }
            @discardableResult
                public func clearClientType() -> Im.Server.ImuserStatusUpdate.Builder {
                   builderResult.hasClientType = false
                   builderResult.clientType = .clientTypeWindows
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImuserStatusUpdate.Builder {
                builderResult = Im.Server.ImuserStatusUpdate()
                return self
            }
            override public func clone() throws -> Im.Server.ImuserStatusUpdate.Builder {
                return try Im.Server.ImuserStatusUpdate.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImuserStatusUpdate {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImuserStatusUpdate {
                let returnMe:Im.Server.ImuserStatusUpdate = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImuserStatusUpdate) throws -> Im.Server.ImuserStatusUpdate.Builder {
                if other == Im.Server.ImuserStatusUpdate() {
                    return self
                }
                if other.hasUserStatus {
                    userStatus = other.userStatus
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasClientType {
                    clientType = other.clientType
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImuserStatusUpdate.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImuserStatusUpdate.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userStatus = try codedInputStream.readUInt32()

                    case 16:
                        userId = try codedInputStream.readUInt32()

                    case 24:
                        let valueIntclientType = try codedInputStream.readEnum()
                        if let enumsclientType = Im.BaseDefine.ClientType(rawValue:valueIntclientType){
                            clientType = enumsclientType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntclientType))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImuserStatusUpdate.Builder {
                let resultDecodedBuilder = Im.Server.ImuserStatusUpdate.Builder()
                if let jsonValueUserStatus = jsonMap["userStatus"] as? UInt {
                    resultDecodedBuilder.userStatus = UInt32(jsonValueUserStatus)
                } else if let jsonValueUserStatus = jsonMap["userStatus"] as? String {
                    resultDecodedBuilder.userStatus = UInt32(jsonValueUserStatus)!
                }
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueClientType = jsonMap["clientType"] as? String {
                    resultDecodedBuilder.clientType = try Im.BaseDefine.ClientType.fromString(jsonValueClientType)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImuserStatusUpdate.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImuserStatusUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImuserCntUpdate : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImuserCntUpdate.Builder

        public static func == (lhs: Im.Server.ImuserCntUpdate, rhs: Im.Server.ImuserCntUpdate) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserAction == rhs.hasUserAction) && (!lhs.hasUserAction || lhs.userAction == rhs.userAction)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x070b
        public fileprivate(set) var userAction:UInt32! = nil
        public fileprivate(set) var hasUserAction:Bool = false

        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserAction {
                return false
            }
            if !hasUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserAction {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userAction)
            }
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:userId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserAction {
                serialize_size += userAction.computeUInt32Size(fieldNumber: 1)
            }
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImuserCntUpdate.Builder {
            return Im.Server.ImuserCntUpdate.classBuilder() as! Im.Server.ImuserCntUpdate.Builder
        }
        public func getBuilder() -> Im.Server.ImuserCntUpdate.Builder {
            return classBuilder() as! Im.Server.ImuserCntUpdate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImuserCntUpdate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImuserCntUpdate.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImuserCntUpdate.Builder {
            return try Im.Server.ImuserCntUpdate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImuserCntUpdate) throws -> Im.Server.ImuserCntUpdate.Builder {
            return try Im.Server.ImuserCntUpdate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserAction {
                jsonMap["userAction"] = UInt(userAction)
            }
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImuserCntUpdate {
            return try Im.Server.ImuserCntUpdate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImuserCntUpdate {
            return try Im.Server.ImuserCntUpdate.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserAction {
                output += "\(indent) userAction: \(userAction) \n"
            }
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserAction {
                    hashCode = (hashCode &* 31) &+ userAction.hashValue
                }
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImuserCntUpdate"
        }
        override public func className() -> String {
            return "Im.Server.ImuserCntUpdate"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImuserCntUpdate = Im.Server.ImuserCntUpdate()
            public func getMessage() -> Im.Server.ImuserCntUpdate {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x070b
            public var userAction:UInt32 {
                get {
                    return builderResult.userAction
                }
                set (value) {
                    builderResult.hasUserAction = true
                    builderResult.userAction = value
                }
            }
            public var hasUserAction:Bool {
                get {
                    return builderResult.hasUserAction
                }
            }
            @discardableResult
            public func setUserAction(_ value:UInt32) -> Im.Server.ImuserCntUpdate.Builder {
                self.userAction = value
                return self
            }
            @discardableResult
            public func clearUserAction() -> Im.Server.ImuserCntUpdate.Builder{
                builderResult.hasUserAction = false
                builderResult.userAction = nil
                return self
            }
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Server.ImuserCntUpdate.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Server.ImuserCntUpdate.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImuserCntUpdate.Builder {
                builderResult = Im.Server.ImuserCntUpdate()
                return self
            }
            override public func clone() throws -> Im.Server.ImuserCntUpdate.Builder {
                return try Im.Server.ImuserCntUpdate.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImuserCntUpdate {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImuserCntUpdate {
                let returnMe:Im.Server.ImuserCntUpdate = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImuserCntUpdate) throws -> Im.Server.ImuserCntUpdate.Builder {
                if other == Im.Server.ImuserCntUpdate() {
                    return self
                }
                if other.hasUserAction {
                    userAction = other.userAction
                }
                if other.hasUserId {
                    userId = other.userId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImuserCntUpdate.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImuserCntUpdate.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userAction = try codedInputStream.readUInt32()

                    case 16:
                        userId = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImuserCntUpdate.Builder {
                let resultDecodedBuilder = Im.Server.ImuserCntUpdate.Builder()
                if let jsonValueUserAction = jsonMap["userAction"] as? UInt {
                    resultDecodedBuilder.userAction = UInt32(jsonValueUserAction)
                } else if let jsonValueUserAction = jsonMap["userAction"] as? String {
                    resultDecodedBuilder.userAction = UInt32(jsonValueUserAction)!
                }
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImuserCntUpdate.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImuserCntUpdate.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImserverKickUser : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImserverKickUser.Builder

        public static func == (lhs: Im.Server.ImserverKickUser, rhs: Im.Server.ImserverKickUser) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasClientType == rhs.hasClientType) && (!lhs.hasClientType || lhs.clientType == rhs.clientType)
            fieldCheck = fieldCheck && (lhs.hasReason == rhs.hasReason) && (!lhs.hasReason || lhs.reason == rhs.reason)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x070d
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var clientType:Im.BaseDefine.ClientType = Im.BaseDefine.ClientType.clientTypeWindows
        public fileprivate(set) var hasClientType:Bool = false
        ///KICK_REASON_DUPLICATE_USER = 1;
        public fileprivate(set) var reason:UInt32! = nil
        public fileprivate(set) var hasReason:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasClientType {
                return false
            }
            if !hasReason {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasClientType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:clientType.rawValue)
            }
            if hasReason {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:reason)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasClientType) {
                serialize_size += clientType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasReason {
                serialize_size += reason.computeUInt32Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImserverKickUser.Builder {
            return Im.Server.ImserverKickUser.classBuilder() as! Im.Server.ImserverKickUser.Builder
        }
        public func getBuilder() -> Im.Server.ImserverKickUser.Builder {
            return classBuilder() as! Im.Server.ImserverKickUser.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImserverKickUser.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImserverKickUser.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImserverKickUser.Builder {
            return try Im.Server.ImserverKickUser.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImserverKickUser) throws -> Im.Server.ImserverKickUser.Builder {
            return try Im.Server.ImserverKickUser.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasClientType {
                jsonMap["clientType"] = clientType.toString()
            }
            if hasReason {
                jsonMap["reason"] = UInt(reason)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImserverKickUser {
            return try Im.Server.ImserverKickUser.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImserverKickUser {
            return try Im.Server.ImserverKickUser.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasClientType) {
                output += "\(indent) clientType: \(clientType.description)\n"
            }
            if hasReason {
                output += "\(indent) reason: \(reason) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasClientType {
                     hashCode = (hashCode &* 31) &+ clientType.hashValue
                }
                if hasReason {
                    hashCode = (hashCode &* 31) &+ reason.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImserverKickUser"
        }
        override public func className() -> String {
            return "Im.Server.ImserverKickUser"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImserverKickUser = Im.Server.ImserverKickUser()
            public func getMessage() -> Im.Server.ImserverKickUser {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x070d
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Server.ImserverKickUser.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Server.ImserverKickUser.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var clientType:Im.BaseDefine.ClientType {
                    get {
                        return builderResult.clientType
                    }
                    set (value) {
                        builderResult.hasClientType = true
                        builderResult.clientType = value
                    }
                }
                public var hasClientType:Bool{
                    get {
                        return builderResult.hasClientType
                    }
                }
            @discardableResult
                public func setClientType(_ value:Im.BaseDefine.ClientType) -> Im.Server.ImserverKickUser.Builder {
                  self.clientType = value
                  return self
                }
            @discardableResult
                public func clearClientType() -> Im.Server.ImserverKickUser.Builder {
                   builderResult.hasClientType = false
                   builderResult.clientType = .clientTypeWindows
                   return self
                }
            ///KICK_REASON_DUPLICATE_USER = 1;
            public var reason:UInt32 {
                get {
                    return builderResult.reason
                }
                set (value) {
                    builderResult.hasReason = true
                    builderResult.reason = value
                }
            }
            public var hasReason:Bool {
                get {
                    return builderResult.hasReason
                }
            }
            @discardableResult
            public func setReason(_ value:UInt32) -> Im.Server.ImserverKickUser.Builder {
                self.reason = value
                return self
            }
            @discardableResult
            public func clearReason() -> Im.Server.ImserverKickUser.Builder{
                builderResult.hasReason = false
                builderResult.reason = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImserverKickUser.Builder {
                builderResult = Im.Server.ImserverKickUser()
                return self
            }
            override public func clone() throws -> Im.Server.ImserverKickUser.Builder {
                return try Im.Server.ImserverKickUser.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImserverKickUser {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImserverKickUser {
                let returnMe:Im.Server.ImserverKickUser = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImserverKickUser) throws -> Im.Server.ImserverKickUser.Builder {
                if other == Im.Server.ImserverKickUser() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasClientType {
                    clientType = other.clientType
                }
                if other.hasReason {
                    reason = other.reason
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImserverKickUser.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImserverKickUser.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntclientType = try codedInputStream.readEnum()
                        if let enumsclientType = Im.BaseDefine.ClientType(rawValue:valueIntclientType){
                            clientType = enumsclientType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntclientType))
                        }

                    case 24:
                        reason = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImserverKickUser.Builder {
                let resultDecodedBuilder = Im.Server.ImserverKickUser.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueClientType = jsonMap["clientType"] as? String {
                    resultDecodedBuilder.clientType = try Im.BaseDefine.ClientType.fromString(jsonValueClientType)
                }
                if let jsonValueReason = jsonMap["reason"] as? UInt {
                    resultDecodedBuilder.reason = UInt32(jsonValueReason)
                } else if let jsonValueReason = jsonMap["reason"] as? String {
                    resultDecodedBuilder.reason = UInt32(jsonValueReason)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImserverKickUser.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImserverKickUser.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImserverPcloginStatusNotify : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImserverPcloginStatusNotify.Builder

        public static func == (lhs: Im.Server.ImserverPcloginStatusNotify, rhs: Im.Server.ImserverPcloginStatusNotify) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasLoginStatus == rhs.hasLoginStatus) && (!lhs.hasLoginStatus || lhs.loginStatus == rhs.loginStatus)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x070e
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        ///1: on   0: off
        public fileprivate(set) var loginStatus:UInt32! = nil
        public fileprivate(set) var hasLoginStatus:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasLoginStatus {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasLoginStatus {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:loginStatus)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasLoginStatus {
                serialize_size += loginStatus.computeUInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImserverPcloginStatusNotify.Builder {
            return Im.Server.ImserverPcloginStatusNotify.classBuilder() as! Im.Server.ImserverPcloginStatusNotify.Builder
        }
        public func getBuilder() -> Im.Server.ImserverPcloginStatusNotify.Builder {
            return classBuilder() as! Im.Server.ImserverPcloginStatusNotify.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImserverPcloginStatusNotify.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImserverPcloginStatusNotify.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImserverPcloginStatusNotify.Builder {
            return try Im.Server.ImserverPcloginStatusNotify.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImserverPcloginStatusNotify) throws -> Im.Server.ImserverPcloginStatusNotify.Builder {
            return try Im.Server.ImserverPcloginStatusNotify.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasLoginStatus {
                jsonMap["loginStatus"] = UInt(loginStatus)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImserverPcloginStatusNotify {
            return try Im.Server.ImserverPcloginStatusNotify.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImserverPcloginStatusNotify {
            return try Im.Server.ImserverPcloginStatusNotify.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasLoginStatus {
                output += "\(indent) loginStatus: \(loginStatus) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasLoginStatus {
                    hashCode = (hashCode &* 31) &+ loginStatus.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImserverPcloginStatusNotify"
        }
        override public func className() -> String {
            return "Im.Server.ImserverPcloginStatusNotify"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImserverPcloginStatusNotify = Im.Server.ImserverPcloginStatusNotify()
            public func getMessage() -> Im.Server.ImserverPcloginStatusNotify {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x070e
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Server.ImserverPcloginStatusNotify.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Server.ImserverPcloginStatusNotify.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            ///1: on   0: off
            public var loginStatus:UInt32 {
                get {
                    return builderResult.loginStatus
                }
                set (value) {
                    builderResult.hasLoginStatus = true
                    builderResult.loginStatus = value
                }
            }
            public var hasLoginStatus:Bool {
                get {
                    return builderResult.hasLoginStatus
                }
            }
            @discardableResult
            public func setLoginStatus(_ value:UInt32) -> Im.Server.ImserverPcloginStatusNotify.Builder {
                self.loginStatus = value
                return self
            }
            @discardableResult
            public func clearLoginStatus() -> Im.Server.ImserverPcloginStatusNotify.Builder{
                builderResult.hasLoginStatus = false
                builderResult.loginStatus = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImserverPcloginStatusNotify.Builder {
                builderResult = Im.Server.ImserverPcloginStatusNotify()
                return self
            }
            override public func clone() throws -> Im.Server.ImserverPcloginStatusNotify.Builder {
                return try Im.Server.ImserverPcloginStatusNotify.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImserverPcloginStatusNotify {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImserverPcloginStatusNotify {
                let returnMe:Im.Server.ImserverPcloginStatusNotify = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImserverPcloginStatusNotify) throws -> Im.Server.ImserverPcloginStatusNotify.Builder {
                if other == Im.Server.ImserverPcloginStatusNotify() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasLoginStatus {
                    loginStatus = other.loginStatus
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImserverPcloginStatusNotify.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImserverPcloginStatusNotify.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        loginStatus = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImserverPcloginStatusNotify.Builder {
                let resultDecodedBuilder = Im.Server.ImserverPcloginStatusNotify.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueLoginStatus = jsonMap["loginStatus"] as? UInt {
                    resultDecodedBuilder.loginStatus = UInt32(jsonValueLoginStatus)
                } else if let jsonValueLoginStatus = jsonMap["loginStatus"] as? String {
                    resultDecodedBuilder.loginStatus = UInt32(jsonValueLoginStatus)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImserverPcloginStatusNotify.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImserverPcloginStatusNotify.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImpushToUserReq : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImpushToUserReq.Builder

        public static func == (lhs: Im.Server.ImpushToUserReq, rhs: Im.Server.ImpushToUserReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFlash == rhs.hasFlash) && (!lhs.hasFlash || lhs.flash == rhs.flash)
            fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
            fieldCheck = fieldCheck && (lhs.userTokenList == rhs.userTokenList)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x070f
        public fileprivate(set) var flash:String! = nil
        public fileprivate(set) var hasFlash:Bool = false

        public fileprivate(set) var data:String! = nil
        public fileprivate(set) var hasData:Bool = false

        public fileprivate(set) var userTokenList:Array<Im.BaseDefine.UserTokenInfo>  = Array<Im.BaseDefine.UserTokenInfo>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasFlash {
                return false
            }
            if !hasData {
                return false
            }
            var isInitUserTokenList:Bool = true
            for oneElementUserTokenList in userTokenList {
                if !oneElementUserTokenList.isInitialized() {
                    isInitUserTokenList = false
                    break 
                }
            }
            if !isInitUserTokenList {
                return isInitUserTokenList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFlash {
                try codedOutputStream.writeString(fieldNumber: 1, value:flash)
            }
            if hasData {
                try codedOutputStream.writeString(fieldNumber: 2, value:data)
            }
            for oneElementUserTokenList in userTokenList {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementUserTokenList)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFlash {
                serialize_size += flash.computeStringSize(fieldNumber: 1)
            }
            if hasData {
                serialize_size += data.computeStringSize(fieldNumber: 2)
            }
            for oneElementUserTokenList in userTokenList {
                serialize_size += oneElementUserTokenList.computeMessageSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImpushToUserReq.Builder {
            return Im.Server.ImpushToUserReq.classBuilder() as! Im.Server.ImpushToUserReq.Builder
        }
        public func getBuilder() -> Im.Server.ImpushToUserReq.Builder {
            return classBuilder() as! Im.Server.ImpushToUserReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImpushToUserReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImpushToUserReq.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImpushToUserReq.Builder {
            return try Im.Server.ImpushToUserReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImpushToUserReq) throws -> Im.Server.ImpushToUserReq.Builder {
            return try Im.Server.ImpushToUserReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFlash {
                jsonMap["flash"] = flash
            }
            if hasData {
                jsonMap["data"] = data
            }
            if !userTokenList.isEmpty {
                var jsonArrayUserTokenList:Array<Dictionary<String,Any>> = []
                for oneValueUserTokenList in userTokenList {
                    let ecodedMessageUserTokenList = try oneValueUserTokenList.encode()
                    jsonArrayUserTokenList.append(ecodedMessageUserTokenList)
                }
                jsonMap["userTokenList"] = jsonArrayUserTokenList
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImpushToUserReq {
            return try Im.Server.ImpushToUserReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImpushToUserReq {
            return try Im.Server.ImpushToUserReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFlash {
                output += "\(indent) flash: \(flash) \n"
            }
            if hasData {
                output += "\(indent) data: \(data) \n"
            }
            var userTokenListElementIndex:Int = 0
            for oneElementUserTokenList in userTokenList {
                output += "\(indent) userTokenList[\(userTokenListElementIndex)] {\n"
                output += try oneElementUserTokenList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                userTokenListElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFlash {
                    hashCode = (hashCode &* 31) &+ flash.hashValue
                }
                if hasData {
                    hashCode = (hashCode &* 31) &+ data.hashValue
                }
                for oneElementUserTokenList in userTokenList {
                    hashCode = (hashCode &* 31) &+ oneElementUserTokenList.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImpushToUserReq"
        }
        override public func className() -> String {
            return "Im.Server.ImpushToUserReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImpushToUserReq = Im.Server.ImpushToUserReq()
            public func getMessage() -> Im.Server.ImpushToUserReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x070f
            public var flash:String {
                get {
                    return builderResult.flash
                }
                set (value) {
                    builderResult.hasFlash = true
                    builderResult.flash = value
                }
            }
            public var hasFlash:Bool {
                get {
                    return builderResult.hasFlash
                }
            }
            @discardableResult
            public func setFlash(_ value:String) -> Im.Server.ImpushToUserReq.Builder {
                self.flash = value
                return self
            }
            @discardableResult
            public func clearFlash() -> Im.Server.ImpushToUserReq.Builder{
                builderResult.hasFlash = false
                builderResult.flash = nil
                return self
            }
            public var data:String {
                get {
                    return builderResult.data
                }
                set (value) {
                    builderResult.hasData = true
                    builderResult.data = value
                }
            }
            public var hasData:Bool {
                get {
                    return builderResult.hasData
                }
            }
            @discardableResult
            public func setData(_ value:String) -> Im.Server.ImpushToUserReq.Builder {
                self.data = value
                return self
            }
            @discardableResult
            public func clearData() -> Im.Server.ImpushToUserReq.Builder{
                builderResult.hasData = false
                builderResult.data = nil
                return self
            }
            public var userTokenList:Array<Im.BaseDefine.UserTokenInfo> {
                get {
                    return builderResult.userTokenList
                }
                set (value) {
                    builderResult.userTokenList = value
                }
            }
            @discardableResult
            public func setUserTokenList(_ value:Array<Im.BaseDefine.UserTokenInfo>) -> Im.Server.ImpushToUserReq.Builder {
                self.userTokenList = value
                return self
            }
            @discardableResult
            public func clearUserTokenList() -> Im.Server.ImpushToUserReq.Builder {
                builderResult.userTokenList.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImpushToUserReq.Builder {
                builderResult = Im.Server.ImpushToUserReq()
                return self
            }
            override public func clone() throws -> Im.Server.ImpushToUserReq.Builder {
                return try Im.Server.ImpushToUserReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImpushToUserReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImpushToUserReq {
                let returnMe:Im.Server.ImpushToUserReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImpushToUserReq) throws -> Im.Server.ImpushToUserReq.Builder {
                if other == Im.Server.ImpushToUserReq() {
                    return self
                }
                if other.hasFlash {
                    flash = other.flash
                }
                if other.hasData {
                    data = other.data
                }
                if !other.userTokenList.isEmpty  {
                     builderResult.userTokenList += other.userTokenList
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImpushToUserReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImpushToUserReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        flash = try codedInputStream.readString()

                    case 18:
                        data = try codedInputStream.readString()

                    case 26:
                        let subBuilder = Im.BaseDefine.UserTokenInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        userTokenList.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImpushToUserReq.Builder {
                let resultDecodedBuilder = Im.Server.ImpushToUserReq.Builder()
                if let jsonValueFlash = jsonMap["flash"] as? String {
                    resultDecodedBuilder.flash = jsonValueFlash
                }
                if let jsonValueData = jsonMap["data"] as? String {
                    resultDecodedBuilder.data = jsonValueData
                }
                if let jsonValueUserTokenList = jsonMap["userTokenList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayUserTokenList:Array<Im.BaseDefine.UserTokenInfo> = []
                    for oneValueUserTokenList in jsonValueUserTokenList {
                        let messageFromStringUserTokenList = try Im.BaseDefine.UserTokenInfo.Builder.decodeToBuilder(jsonMap:oneValueUserTokenList).build()

                        jsonArrayUserTokenList.append(messageFromStringUserTokenList)
                    }
                    resultDecodedBuilder.userTokenList = jsonArrayUserTokenList
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImpushToUserReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImpushToUserReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImpushToUserRsp : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImpushToUserRsp.Builder

        public static func == (lhs: Im.Server.ImpushToUserRsp, rhs: Im.Server.ImpushToUserRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.pushResultList == rhs.pushResultList)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var pushResultList:Array<Im.BaseDefine.PushResult>  = Array<Im.BaseDefine.PushResult>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitPushResultList:Bool = true
            for oneElementPushResultList in pushResultList {
                if !oneElementPushResultList.isInitialized() {
                    isInitPushResultList = false
                    break 
                }
            }
            if !isInitPushResultList {
                return isInitPushResultList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementPushResultList in pushResultList {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementPushResultList)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementPushResultList in pushResultList {
                serialize_size += oneElementPushResultList.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImpushToUserRsp.Builder {
            return Im.Server.ImpushToUserRsp.classBuilder() as! Im.Server.ImpushToUserRsp.Builder
        }
        public func getBuilder() -> Im.Server.ImpushToUserRsp.Builder {
            return classBuilder() as! Im.Server.ImpushToUserRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImpushToUserRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImpushToUserRsp.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImpushToUserRsp.Builder {
            return try Im.Server.ImpushToUserRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImpushToUserRsp) throws -> Im.Server.ImpushToUserRsp.Builder {
            return try Im.Server.ImpushToUserRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !pushResultList.isEmpty {
                var jsonArrayPushResultList:Array<Dictionary<String,Any>> = []
                for oneValuePushResultList in pushResultList {
                    let ecodedMessagePushResultList = try oneValuePushResultList.encode()
                    jsonArrayPushResultList.append(ecodedMessagePushResultList)
                }
                jsonMap["pushResultList"] = jsonArrayPushResultList
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImpushToUserRsp {
            return try Im.Server.ImpushToUserRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImpushToUserRsp {
            return try Im.Server.ImpushToUserRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var pushResultListElementIndex:Int = 0
            for oneElementPushResultList in pushResultList {
                output += "\(indent) pushResultList[\(pushResultListElementIndex)] {\n"
                output += try oneElementPushResultList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                pushResultListElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementPushResultList in pushResultList {
                    hashCode = (hashCode &* 31) &+ oneElementPushResultList.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImpushToUserRsp"
        }
        override public func className() -> String {
            return "Im.Server.ImpushToUserRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImpushToUserRsp = Im.Server.ImpushToUserRsp()
            public func getMessage() -> Im.Server.ImpushToUserRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x0710
            public var pushResultList:Array<Im.BaseDefine.PushResult> {
                get {
                    return builderResult.pushResultList
                }
                set (value) {
                    builderResult.pushResultList = value
                }
            }
            @discardableResult
            public func setPushResultList(_ value:Array<Im.BaseDefine.PushResult>) -> Im.Server.ImpushToUserRsp.Builder {
                self.pushResultList = value
                return self
            }
            @discardableResult
            public func clearPushResultList() -> Im.Server.ImpushToUserRsp.Builder {
                builderResult.pushResultList.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImpushToUserRsp.Builder {
                builderResult = Im.Server.ImpushToUserRsp()
                return self
            }
            override public func clone() throws -> Im.Server.ImpushToUserRsp.Builder {
                return try Im.Server.ImpushToUserRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImpushToUserRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImpushToUserRsp {
                let returnMe:Im.Server.ImpushToUserRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImpushToUserRsp) throws -> Im.Server.ImpushToUserRsp.Builder {
                if other == Im.Server.ImpushToUserRsp() {
                    return self
                }
                if !other.pushResultList.isEmpty  {
                     builderResult.pushResultList += other.pushResultList
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImpushToUserRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImpushToUserRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Im.BaseDefine.PushResult.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        pushResultList.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImpushToUserRsp.Builder {
                let resultDecodedBuilder = Im.Server.ImpushToUserRsp.Builder()
                if let jsonValuePushResultList = jsonMap["pushResultList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayPushResultList:Array<Im.BaseDefine.PushResult> = []
                    for oneValuePushResultList in jsonValuePushResultList {
                        let messageFromStringPushResultList = try Im.BaseDefine.PushResult.Builder.decodeToBuilder(jsonMap:oneValuePushResultList).build()

                        jsonArrayPushResultList.append(messageFromStringPushResultList)
                    }
                    resultDecodedBuilder.pushResultList = jsonArrayPushResultList
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImpushToUserRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImpushToUserRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgroupGetShieldReq : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImgroupGetShieldReq.Builder

        public static func == (lhs: Im.Server.ImgroupGetShieldReq, rhs: Im.Server.ImgroupGetShieldReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x0711
        public fileprivate(set) var groupId:UInt32! = nil
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var userId:Array<UInt32> = Array<UInt32>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:groupId)
            }
            if !userId.isEmpty {
                for oneValueuserId in userId {
                    try codedOutputStream.writeUInt32(fieldNumber: 2, value:oneValueuserId)
                }
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeUInt32Size(fieldNumber: 1)
            }
            var dataSizeUserId:Int32 = 0
            for oneValueuserId in userId {
                dataSizeUserId += oneValueuserId.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeUserId
            serialize_size += 1 * Int32(userId.count)
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImgroupGetShieldReq.Builder {
            return Im.Server.ImgroupGetShieldReq.classBuilder() as! Im.Server.ImgroupGetShieldReq.Builder
        }
        public func getBuilder() -> Im.Server.ImgroupGetShieldReq.Builder {
            return classBuilder() as! Im.Server.ImgroupGetShieldReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImgroupGetShieldReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImgroupGetShieldReq.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImgroupGetShieldReq.Builder {
            return try Im.Server.ImgroupGetShieldReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImgroupGetShieldReq) throws -> Im.Server.ImgroupGetShieldReq.Builder {
            return try Im.Server.ImgroupGetShieldReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = UInt(groupId)
            }
            if !userId.isEmpty {
                var jsonArrayUserId:Array<UInt> = []
                for oneValueUserId in userId {
                    jsonArrayUserId.append(UInt(oneValueUserId))
                }
                jsonMap["userId"] = jsonArrayUserId
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImgroupGetShieldReq {
            return try Im.Server.ImgroupGetShieldReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImgroupGetShieldReq {
            return try Im.Server.ImgroupGetShieldReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            var userIdElementIndex:Int = 0
            for oneValueUserId in userId  {
                output += "\(indent) userId[\(userIdElementIndex)]: \(oneValueUserId)\n"
                userIdElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                for oneValueUserId in userId {
                    hashCode = (hashCode &* 31) &+ oneValueUserId.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImgroupGetShieldReq"
        }
        override public func className() -> String {
            return "Im.Server.ImgroupGetShieldReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImgroupGetShieldReq = Im.Server.ImgroupGetShieldReq()
            public func getMessage() -> Im.Server.ImgroupGetShieldReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x0711
            public var groupId:UInt32 {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:UInt32) -> Im.Server.ImgroupGetShieldReq.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Im.Server.ImgroupGetShieldReq.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = nil
                return self
            }
            public var userId:Array<UInt32> {
                get {
                    return builderResult.userId
                }
                set (array) {
                    builderResult.userId = array
                }
            }
            @discardableResult
            public func setUserId(_ value:Array<UInt32>) -> Im.Server.ImgroupGetShieldReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Server.ImgroupGetShieldReq.Builder {
                builderResult.userId.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Server.ImgroupGetShieldReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Server.ImgroupGetShieldReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImgroupGetShieldReq.Builder {
                builderResult = Im.Server.ImgroupGetShieldReq()
                return self
            }
            override public func clone() throws -> Im.Server.ImgroupGetShieldReq.Builder {
                return try Im.Server.ImgroupGetShieldReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImgroupGetShieldReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImgroupGetShieldReq {
                let returnMe:Im.Server.ImgroupGetShieldReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImgroupGetShieldReq) throws -> Im.Server.ImgroupGetShieldReq.Builder {
                if other == Im.Server.ImgroupGetShieldReq() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if !other.userId.isEmpty {
                    builderResult.userId += other.userId
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImgroupGetShieldReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgroupGetShieldReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        groupId = try codedInputStream.readUInt32()

                    case 16:
                        userId += [try codedInputStream.readUInt32()]

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImgroupGetShieldReq.Builder {
                let resultDecodedBuilder = Im.Server.ImgroupGetShieldReq.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? UInt {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)
                } else if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)!
                }
                if let jsonValueUserId = jsonMap["userId"] as? Array<UInt> {
                    var jsonArrayUserId:Array<UInt32> = []
                    for oneValueUserId in jsonValueUserId {
                        jsonArrayUserId.append(UInt32(oneValueUserId))
                    }
                    resultDecodedBuilder.userId = jsonArrayUserId
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImgroupGetShieldReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImgroupGetShieldReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgroupGetShieldRsp : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImgroupGetShieldRsp.Builder

        public static func == (lhs: Im.Server.ImgroupGetShieldRsp, rhs: Im.Server.ImgroupGetShieldRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.shieldStatusList == rhs.shieldStatusList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id: 			0x0712
        public fileprivate(set) var groupId:UInt32! = nil
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var shieldStatusList:Array<Im.BaseDefine.ShieldStatus>  = Array<Im.BaseDefine.ShieldStatus>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            var isInitShieldStatusList:Bool = true
            for oneElementShieldStatusList in shieldStatusList {
                if !oneElementShieldStatusList.isInitialized() {
                    isInitShieldStatusList = false
                    break 
                }
            }
            if !isInitShieldStatusList {
                return isInitShieldStatusList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:groupId)
            }
            for oneElementShieldStatusList in shieldStatusList {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementShieldStatusList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeUInt32Size(fieldNumber: 1)
            }
            for oneElementShieldStatusList in shieldStatusList {
                serialize_size += oneElementShieldStatusList.computeMessageSize(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImgroupGetShieldRsp.Builder {
            return Im.Server.ImgroupGetShieldRsp.classBuilder() as! Im.Server.ImgroupGetShieldRsp.Builder
        }
        public func getBuilder() -> Im.Server.ImgroupGetShieldRsp.Builder {
            return classBuilder() as! Im.Server.ImgroupGetShieldRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImgroupGetShieldRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImgroupGetShieldRsp.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImgroupGetShieldRsp.Builder {
            return try Im.Server.ImgroupGetShieldRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImgroupGetShieldRsp) throws -> Im.Server.ImgroupGetShieldRsp.Builder {
            return try Im.Server.ImgroupGetShieldRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = UInt(groupId)
            }
            if !shieldStatusList.isEmpty {
                var jsonArrayShieldStatusList:Array<Dictionary<String,Any>> = []
                for oneValueShieldStatusList in shieldStatusList {
                    let ecodedMessageShieldStatusList = try oneValueShieldStatusList.encode()
                    jsonArrayShieldStatusList.append(ecodedMessageShieldStatusList)
                }
                jsonMap["shieldStatusList"] = jsonArrayShieldStatusList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImgroupGetShieldRsp {
            return try Im.Server.ImgroupGetShieldRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImgroupGetShieldRsp {
            return try Im.Server.ImgroupGetShieldRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            var shieldStatusListElementIndex:Int = 0
            for oneElementShieldStatusList in shieldStatusList {
                output += "\(indent) shieldStatusList[\(shieldStatusListElementIndex)] {\n"
                output += try oneElementShieldStatusList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                shieldStatusListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                for oneElementShieldStatusList in shieldStatusList {
                    hashCode = (hashCode &* 31) &+ oneElementShieldStatusList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImgroupGetShieldRsp"
        }
        override public func className() -> String {
            return "Im.Server.ImgroupGetShieldRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImgroupGetShieldRsp = Im.Server.ImgroupGetShieldRsp()
            public func getMessage() -> Im.Server.ImgroupGetShieldRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 			0x0712
            public var groupId:UInt32 {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:UInt32) -> Im.Server.ImgroupGetShieldRsp.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Im.Server.ImgroupGetShieldRsp.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = nil
                return self
            }
            public var shieldStatusList:Array<Im.BaseDefine.ShieldStatus> {
                get {
                    return builderResult.shieldStatusList
                }
                set (value) {
                    builderResult.shieldStatusList = value
                }
            }
            @discardableResult
            public func setShieldStatusList(_ value:Array<Im.BaseDefine.ShieldStatus>) -> Im.Server.ImgroupGetShieldRsp.Builder {
                self.shieldStatusList = value
                return self
            }
            @discardableResult
            public func clearShieldStatusList() -> Im.Server.ImgroupGetShieldRsp.Builder {
                builderResult.shieldStatusList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Server.ImgroupGetShieldRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Server.ImgroupGetShieldRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImgroupGetShieldRsp.Builder {
                builderResult = Im.Server.ImgroupGetShieldRsp()
                return self
            }
            override public func clone() throws -> Im.Server.ImgroupGetShieldRsp.Builder {
                return try Im.Server.ImgroupGetShieldRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImgroupGetShieldRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImgroupGetShieldRsp {
                let returnMe:Im.Server.ImgroupGetShieldRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImgroupGetShieldRsp) throws -> Im.Server.ImgroupGetShieldRsp.Builder {
                if other == Im.Server.ImgroupGetShieldRsp() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if !other.shieldStatusList.isEmpty  {
                     builderResult.shieldStatusList += other.shieldStatusList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImgroupGetShieldRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgroupGetShieldRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        groupId = try codedInputStream.readUInt32()

                    case 18:
                        let subBuilder = Im.BaseDefine.ShieldStatus.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        shieldStatusList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImgroupGetShieldRsp.Builder {
                let resultDecodedBuilder = Im.Server.ImgroupGetShieldRsp.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? UInt {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)
                } else if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)!
                }
                if let jsonValueShieldStatusList = jsonMap["shieldStatusList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayShieldStatusList:Array<Im.BaseDefine.ShieldStatus> = []
                    for oneValueShieldStatusList in jsonValueShieldStatusList {
                        let messageFromStringShieldStatusList = try Im.BaseDefine.ShieldStatus.Builder.decodeToBuilder(jsonMap:oneValueShieldStatusList).build()

                        jsonArrayShieldStatusList.append(messageFromStringShieldStatusList)
                    }
                    resultDecodedBuilder.shieldStatusList = jsonArrayShieldStatusList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImgroupGetShieldRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImgroupGetShieldRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfileTransferReq : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImfileTransferReq.Builder

        public static func == (lhs: Im.Server.ImfileTransferReq, rhs: Im.Server.ImfileTransferReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFromUserId == rhs.hasFromUserId) && (!lhs.hasFromUserId || lhs.fromUserId == rhs.fromUserId)
            fieldCheck = fieldCheck && (lhs.hasToUserId == rhs.hasToUserId) && (!lhs.hasToUserId || lhs.toUserId == rhs.toUserId)
            fieldCheck = fieldCheck && (lhs.hasFileName == rhs.hasFileName) && (!lhs.hasFileName || lhs.fileName == rhs.fileName)
            fieldCheck = fieldCheck && (lhs.hasFileSize == rhs.hasFileSize) && (!lhs.hasFileSize || lhs.fileSize == rhs.fileSize)
            fieldCheck = fieldCheck && (lhs.hasTransMode == rhs.hasTransMode) && (!lhs.hasTransMode || lhs.transMode == rhs.transMode)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x0715
        public fileprivate(set) var fromUserId:UInt32! = nil
        public fileprivate(set) var hasFromUserId:Bool = false

        public fileprivate(set) var toUserId:UInt32! = nil
        public fileprivate(set) var hasToUserId:Bool = false

        public fileprivate(set) var fileName:String! = nil
        public fileprivate(set) var hasFileName:Bool = false

        public fileprivate(set) var fileSize:UInt32! = nil
        public fileprivate(set) var hasFileSize:Bool = false

        public fileprivate(set) var transMode:Im.BaseDefine.TransferFileType = Im.BaseDefine.TransferFileType.fileTypeOnline
        public fileprivate(set) var hasTransMode:Bool = false
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasFromUserId {
                return false
            }
            if !hasToUserId {
                return false
            }
            if !hasFileName {
                return false
            }
            if !hasFileSize {
                return false
            }
            if !hasTransMode {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFromUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:fromUserId)
            }
            if hasToUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:toUserId)
            }
            if hasFileName {
                try codedOutputStream.writeString(fieldNumber: 3, value:fileName)
            }
            if hasFileSize {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:fileSize)
            }
            if hasTransMode {
                try codedOutputStream.writeEnum(fieldNumber: 5, value:transMode.rawValue)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFromUserId {
                serialize_size += fromUserId.computeUInt32Size(fieldNumber: 1)
            }
            if hasToUserId {
                serialize_size += toUserId.computeUInt32Size(fieldNumber: 2)
            }
            if hasFileName {
                serialize_size += fileName.computeStringSize(fieldNumber: 3)
            }
            if hasFileSize {
                serialize_size += fileSize.computeUInt32Size(fieldNumber: 4)
            }
            if (hasTransMode) {
                serialize_size += transMode.rawValue.computeEnumSize(fieldNumber: 5)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImfileTransferReq.Builder {
            return Im.Server.ImfileTransferReq.classBuilder() as! Im.Server.ImfileTransferReq.Builder
        }
        public func getBuilder() -> Im.Server.ImfileTransferReq.Builder {
            return classBuilder() as! Im.Server.ImfileTransferReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImfileTransferReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImfileTransferReq.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImfileTransferReq.Builder {
            return try Im.Server.ImfileTransferReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImfileTransferReq) throws -> Im.Server.ImfileTransferReq.Builder {
            return try Im.Server.ImfileTransferReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFromUserId {
                jsonMap["fromUserId"] = UInt(fromUserId)
            }
            if hasToUserId {
                jsonMap["toUserId"] = UInt(toUserId)
            }
            if hasFileName {
                jsonMap["fileName"] = fileName
            }
            if hasFileSize {
                jsonMap["fileSize"] = UInt(fileSize)
            }
            if hasTransMode {
                jsonMap["transMode"] = transMode.toString()
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImfileTransferReq {
            return try Im.Server.ImfileTransferReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImfileTransferReq {
            return try Im.Server.ImfileTransferReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFromUserId {
                output += "\(indent) fromUserId: \(fromUserId) \n"
            }
            if hasToUserId {
                output += "\(indent) toUserId: \(toUserId) \n"
            }
            if hasFileName {
                output += "\(indent) fileName: \(fileName) \n"
            }
            if hasFileSize {
                output += "\(indent) fileSize: \(fileSize) \n"
            }
            if (hasTransMode) {
                output += "\(indent) transMode: \(transMode.description)\n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFromUserId {
                    hashCode = (hashCode &* 31) &+ fromUserId.hashValue
                }
                if hasToUserId {
                    hashCode = (hashCode &* 31) &+ toUserId.hashValue
                }
                if hasFileName {
                    hashCode = (hashCode &* 31) &+ fileName.hashValue
                }
                if hasFileSize {
                    hashCode = (hashCode &* 31) &+ fileSize.hashValue
                }
                if hasTransMode {
                     hashCode = (hashCode &* 31) &+ transMode.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImfileTransferReq"
        }
        override public func className() -> String {
            return "Im.Server.ImfileTransferReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImfileTransferReq = Im.Server.ImfileTransferReq()
            public func getMessage() -> Im.Server.ImfileTransferReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x0715
            public var fromUserId:UInt32 {
                get {
                    return builderResult.fromUserId
                }
                set (value) {
                    builderResult.hasFromUserId = true
                    builderResult.fromUserId = value
                }
            }
            public var hasFromUserId:Bool {
                get {
                    return builderResult.hasFromUserId
                }
            }
            @discardableResult
            public func setFromUserId(_ value:UInt32) -> Im.Server.ImfileTransferReq.Builder {
                self.fromUserId = value
                return self
            }
            @discardableResult
            public func clearFromUserId() -> Im.Server.ImfileTransferReq.Builder{
                builderResult.hasFromUserId = false
                builderResult.fromUserId = nil
                return self
            }
            public var toUserId:UInt32 {
                get {
                    return builderResult.toUserId
                }
                set (value) {
                    builderResult.hasToUserId = true
                    builderResult.toUserId = value
                }
            }
            public var hasToUserId:Bool {
                get {
                    return builderResult.hasToUserId
                }
            }
            @discardableResult
            public func setToUserId(_ value:UInt32) -> Im.Server.ImfileTransferReq.Builder {
                self.toUserId = value
                return self
            }
            @discardableResult
            public func clearToUserId() -> Im.Server.ImfileTransferReq.Builder{
                builderResult.hasToUserId = false
                builderResult.toUserId = nil
                return self
            }
            public var fileName:String {
                get {
                    return builderResult.fileName
                }
                set (value) {
                    builderResult.hasFileName = true
                    builderResult.fileName = value
                }
            }
            public var hasFileName:Bool {
                get {
                    return builderResult.hasFileName
                }
            }
            @discardableResult
            public func setFileName(_ value:String) -> Im.Server.ImfileTransferReq.Builder {
                self.fileName = value
                return self
            }
            @discardableResult
            public func clearFileName() -> Im.Server.ImfileTransferReq.Builder{
                builderResult.hasFileName = false
                builderResult.fileName = nil
                return self
            }
            public var fileSize:UInt32 {
                get {
                    return builderResult.fileSize
                }
                set (value) {
                    builderResult.hasFileSize = true
                    builderResult.fileSize = value
                }
            }
            public var hasFileSize:Bool {
                get {
                    return builderResult.hasFileSize
                }
            }
            @discardableResult
            public func setFileSize(_ value:UInt32) -> Im.Server.ImfileTransferReq.Builder {
                self.fileSize = value
                return self
            }
            @discardableResult
            public func clearFileSize() -> Im.Server.ImfileTransferReq.Builder{
                builderResult.hasFileSize = false
                builderResult.fileSize = nil
                return self
            }
                public var transMode:Im.BaseDefine.TransferFileType {
                    get {
                        return builderResult.transMode
                    }
                    set (value) {
                        builderResult.hasTransMode = true
                        builderResult.transMode = value
                    }
                }
                public var hasTransMode:Bool{
                    get {
                        return builderResult.hasTransMode
                    }
                }
            @discardableResult
                public func setTransMode(_ value:Im.BaseDefine.TransferFileType) -> Im.Server.ImfileTransferReq.Builder {
                  self.transMode = value
                  return self
                }
            @discardableResult
                public func clearTransMode() -> Im.Server.ImfileTransferReq.Builder {
                   builderResult.hasTransMode = false
                   builderResult.transMode = .fileTypeOnline
                   return self
                }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Server.ImfileTransferReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Server.ImfileTransferReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImfileTransferReq.Builder {
                builderResult = Im.Server.ImfileTransferReq()
                return self
            }
            override public func clone() throws -> Im.Server.ImfileTransferReq.Builder {
                return try Im.Server.ImfileTransferReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImfileTransferReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImfileTransferReq {
                let returnMe:Im.Server.ImfileTransferReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImfileTransferReq) throws -> Im.Server.ImfileTransferReq.Builder {
                if other == Im.Server.ImfileTransferReq() {
                    return self
                }
                if other.hasFromUserId {
                    fromUserId = other.fromUserId
                }
                if other.hasToUserId {
                    toUserId = other.toUserId
                }
                if other.hasFileName {
                    fileName = other.fileName
                }
                if other.hasFileSize {
                    fileSize = other.fileSize
                }
                if other.hasTransMode {
                    transMode = other.transMode
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImfileTransferReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileTransferReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        fromUserId = try codedInputStream.readUInt32()

                    case 16:
                        toUserId = try codedInputStream.readUInt32()

                    case 26:
                        fileName = try codedInputStream.readString()

                    case 32:
                        fileSize = try codedInputStream.readUInt32()

                    case 40:
                        let valueInttransMode = try codedInputStream.readEnum()
                        if let enumstransMode = Im.BaseDefine.TransferFileType(rawValue:valueInttransMode){
                            transMode = enumstransMode
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueInttransMode))
                        }

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImfileTransferReq.Builder {
                let resultDecodedBuilder = Im.Server.ImfileTransferReq.Builder()
                if let jsonValueFromUserId = jsonMap["fromUserId"] as? UInt {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)
                } else if let jsonValueFromUserId = jsonMap["fromUserId"] as? String {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)!
                }
                if let jsonValueToUserId = jsonMap["toUserId"] as? UInt {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)
                } else if let jsonValueToUserId = jsonMap["toUserId"] as? String {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)!
                }
                if let jsonValueFileName = jsonMap["fileName"] as? String {
                    resultDecodedBuilder.fileName = jsonValueFileName
                }
                if let jsonValueFileSize = jsonMap["fileSize"] as? UInt {
                    resultDecodedBuilder.fileSize = UInt32(jsonValueFileSize)
                } else if let jsonValueFileSize = jsonMap["fileSize"] as? String {
                    resultDecodedBuilder.fileSize = UInt32(jsonValueFileSize)!
                }
                if let jsonValueTransMode = jsonMap["transMode"] as? String {
                    resultDecodedBuilder.transMode = try Im.BaseDefine.TransferFileType.fromString(jsonValueTransMode)
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImfileTransferReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImfileTransferReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfileTransferRsp : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImfileTransferRsp.Builder

        public static func == (lhs: Im.Server.ImfileTransferRsp, rhs: Im.Server.ImfileTransferRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasFromUserId == rhs.hasFromUserId) && (!lhs.hasFromUserId || lhs.fromUserId == rhs.fromUserId)
            fieldCheck = fieldCheck && (lhs.hasToUserId == rhs.hasToUserId) && (!lhs.hasToUserId || lhs.toUserId == rhs.toUserId)
            fieldCheck = fieldCheck && (lhs.hasFileName == rhs.hasFileName) && (!lhs.hasFileName || lhs.fileName == rhs.fileName)
            fieldCheck = fieldCheck && (lhs.hasFileSize == rhs.hasFileSize) && (!lhs.hasFileSize || lhs.fileSize == rhs.fileSize)
            fieldCheck = fieldCheck && (lhs.hasTaskId == rhs.hasTaskId) && (!lhs.hasTaskId || lhs.taskId == rhs.taskId)
            fieldCheck = fieldCheck && (lhs.hasTransMode == rhs.hasTransMode) && (!lhs.hasTransMode || lhs.transMode == rhs.transMode)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x0716
        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        public fileprivate(set) var fromUserId:UInt32! = nil
        public fileprivate(set) var hasFromUserId:Bool = false

        public fileprivate(set) var toUserId:UInt32! = nil
        public fileprivate(set) var hasToUserId:Bool = false

        public fileprivate(set) var fileName:String! = nil
        public fileprivate(set) var hasFileName:Bool = false

        public fileprivate(set) var fileSize:UInt32! = nil
        public fileprivate(set) var hasFileSize:Bool = false

        public fileprivate(set) var taskId:String! = nil
        public fileprivate(set) var hasTaskId:Bool = false

        public fileprivate(set) var transMode:Im.BaseDefine.TransferFileType = Im.BaseDefine.TransferFileType.fileTypeOnline
        public fileprivate(set) var hasTransMode:Bool = false
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasResultCode {
                return false
            }
            if !hasFromUserId {
                return false
            }
            if !hasToUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:resultCode)
            }
            if hasFromUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:fromUserId)
            }
            if hasToUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:toUserId)
            }
            if hasFileName {
                try codedOutputStream.writeString(fieldNumber: 4, value:fileName)
            }
            if hasFileSize {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:fileSize)
            }
            if hasTaskId {
                try codedOutputStream.writeString(fieldNumber: 6, value:taskId)
            }
            if hasTransMode {
                try codedOutputStream.writeEnum(fieldNumber: 7, value:transMode.rawValue)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 1)
            }
            if hasFromUserId {
                serialize_size += fromUserId.computeUInt32Size(fieldNumber: 2)
            }
            if hasToUserId {
                serialize_size += toUserId.computeUInt32Size(fieldNumber: 3)
            }
            if hasFileName {
                serialize_size += fileName.computeStringSize(fieldNumber: 4)
            }
            if hasFileSize {
                serialize_size += fileSize.computeUInt32Size(fieldNumber: 5)
            }
            if hasTaskId {
                serialize_size += taskId.computeStringSize(fieldNumber: 6)
            }
            if (hasTransMode) {
                serialize_size += transMode.rawValue.computeEnumSize(fieldNumber: 7)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImfileTransferRsp.Builder {
            return Im.Server.ImfileTransferRsp.classBuilder() as! Im.Server.ImfileTransferRsp.Builder
        }
        public func getBuilder() -> Im.Server.ImfileTransferRsp.Builder {
            return classBuilder() as! Im.Server.ImfileTransferRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImfileTransferRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImfileTransferRsp.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImfileTransferRsp.Builder {
            return try Im.Server.ImfileTransferRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImfileTransferRsp) throws -> Im.Server.ImfileTransferRsp.Builder {
            return try Im.Server.ImfileTransferRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            if hasFromUserId {
                jsonMap["fromUserId"] = UInt(fromUserId)
            }
            if hasToUserId {
                jsonMap["toUserId"] = UInt(toUserId)
            }
            if hasFileName {
                jsonMap["fileName"] = fileName
            }
            if hasFileSize {
                jsonMap["fileSize"] = UInt(fileSize)
            }
            if hasTaskId {
                jsonMap["taskId"] = taskId
            }
            if hasTransMode {
                jsonMap["transMode"] = transMode.toString()
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImfileTransferRsp {
            return try Im.Server.ImfileTransferRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImfileTransferRsp {
            return try Im.Server.ImfileTransferRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            if hasFromUserId {
                output += "\(indent) fromUserId: \(fromUserId) \n"
            }
            if hasToUserId {
                output += "\(indent) toUserId: \(toUserId) \n"
            }
            if hasFileName {
                output += "\(indent) fileName: \(fileName) \n"
            }
            if hasFileSize {
                output += "\(indent) fileSize: \(fileSize) \n"
            }
            if hasTaskId {
                output += "\(indent) taskId: \(taskId) \n"
            }
            if (hasTransMode) {
                output += "\(indent) transMode: \(transMode.description)\n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasFromUserId {
                    hashCode = (hashCode &* 31) &+ fromUserId.hashValue
                }
                if hasToUserId {
                    hashCode = (hashCode &* 31) &+ toUserId.hashValue
                }
                if hasFileName {
                    hashCode = (hashCode &* 31) &+ fileName.hashValue
                }
                if hasFileSize {
                    hashCode = (hashCode &* 31) &+ fileSize.hashValue
                }
                if hasTaskId {
                    hashCode = (hashCode &* 31) &+ taskId.hashValue
                }
                if hasTransMode {
                     hashCode = (hashCode &* 31) &+ transMode.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImfileTransferRsp"
        }
        override public func className() -> String {
            return "Im.Server.ImfileTransferRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImfileTransferRsp = Im.Server.ImfileTransferRsp()
            public func getMessage() -> Im.Server.ImfileTransferRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x0716
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.Server.ImfileTransferRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.Server.ImfileTransferRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            public var fromUserId:UInt32 {
                get {
                    return builderResult.fromUserId
                }
                set (value) {
                    builderResult.hasFromUserId = true
                    builderResult.fromUserId = value
                }
            }
            public var hasFromUserId:Bool {
                get {
                    return builderResult.hasFromUserId
                }
            }
            @discardableResult
            public func setFromUserId(_ value:UInt32) -> Im.Server.ImfileTransferRsp.Builder {
                self.fromUserId = value
                return self
            }
            @discardableResult
            public func clearFromUserId() -> Im.Server.ImfileTransferRsp.Builder{
                builderResult.hasFromUserId = false
                builderResult.fromUserId = nil
                return self
            }
            public var toUserId:UInt32 {
                get {
                    return builderResult.toUserId
                }
                set (value) {
                    builderResult.hasToUserId = true
                    builderResult.toUserId = value
                }
            }
            public var hasToUserId:Bool {
                get {
                    return builderResult.hasToUserId
                }
            }
            @discardableResult
            public func setToUserId(_ value:UInt32) -> Im.Server.ImfileTransferRsp.Builder {
                self.toUserId = value
                return self
            }
            @discardableResult
            public func clearToUserId() -> Im.Server.ImfileTransferRsp.Builder{
                builderResult.hasToUserId = false
                builderResult.toUserId = nil
                return self
            }
            public var fileName:String {
                get {
                    return builderResult.fileName
                }
                set (value) {
                    builderResult.hasFileName = true
                    builderResult.fileName = value
                }
            }
            public var hasFileName:Bool {
                get {
                    return builderResult.hasFileName
                }
            }
            @discardableResult
            public func setFileName(_ value:String) -> Im.Server.ImfileTransferRsp.Builder {
                self.fileName = value
                return self
            }
            @discardableResult
            public func clearFileName() -> Im.Server.ImfileTransferRsp.Builder{
                builderResult.hasFileName = false
                builderResult.fileName = nil
                return self
            }
            public var fileSize:UInt32 {
                get {
                    return builderResult.fileSize
                }
                set (value) {
                    builderResult.hasFileSize = true
                    builderResult.fileSize = value
                }
            }
            public var hasFileSize:Bool {
                get {
                    return builderResult.hasFileSize
                }
            }
            @discardableResult
            public func setFileSize(_ value:UInt32) -> Im.Server.ImfileTransferRsp.Builder {
                self.fileSize = value
                return self
            }
            @discardableResult
            public func clearFileSize() -> Im.Server.ImfileTransferRsp.Builder{
                builderResult.hasFileSize = false
                builderResult.fileSize = nil
                return self
            }
            public var taskId:String {
                get {
                    return builderResult.taskId
                }
                set (value) {
                    builderResult.hasTaskId = true
                    builderResult.taskId = value
                }
            }
            public var hasTaskId:Bool {
                get {
                    return builderResult.hasTaskId
                }
            }
            @discardableResult
            public func setTaskId(_ value:String) -> Im.Server.ImfileTransferRsp.Builder {
                self.taskId = value
                return self
            }
            @discardableResult
            public func clearTaskId() -> Im.Server.ImfileTransferRsp.Builder{
                builderResult.hasTaskId = false
                builderResult.taskId = nil
                return self
            }
                public var transMode:Im.BaseDefine.TransferFileType {
                    get {
                        return builderResult.transMode
                    }
                    set (value) {
                        builderResult.hasTransMode = true
                        builderResult.transMode = value
                    }
                }
                public var hasTransMode:Bool{
                    get {
                        return builderResult.hasTransMode
                    }
                }
            @discardableResult
                public func setTransMode(_ value:Im.BaseDefine.TransferFileType) -> Im.Server.ImfileTransferRsp.Builder {
                  self.transMode = value
                  return self
                }
            @discardableResult
                public func clearTransMode() -> Im.Server.ImfileTransferRsp.Builder {
                   builderResult.hasTransMode = false
                   builderResult.transMode = .fileTypeOnline
                   return self
                }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Server.ImfileTransferRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Server.ImfileTransferRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImfileTransferRsp.Builder {
                builderResult = Im.Server.ImfileTransferRsp()
                return self
            }
            override public func clone() throws -> Im.Server.ImfileTransferRsp.Builder {
                return try Im.Server.ImfileTransferRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImfileTransferRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImfileTransferRsp {
                let returnMe:Im.Server.ImfileTransferRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImfileTransferRsp) throws -> Im.Server.ImfileTransferRsp.Builder {
                if other == Im.Server.ImfileTransferRsp() {
                    return self
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasFromUserId {
                    fromUserId = other.fromUserId
                }
                if other.hasToUserId {
                    toUserId = other.toUserId
                }
                if other.hasFileName {
                    fileName = other.fileName
                }
                if other.hasFileSize {
                    fileSize = other.fileSize
                }
                if other.hasTaskId {
                    taskId = other.taskId
                }
                if other.hasTransMode {
                    transMode = other.transMode
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImfileTransferRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileTransferRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        resultCode = try codedInputStream.readUInt32()

                    case 16:
                        fromUserId = try codedInputStream.readUInt32()

                    case 24:
                        toUserId = try codedInputStream.readUInt32()

                    case 34:
                        fileName = try codedInputStream.readString()

                    case 40:
                        fileSize = try codedInputStream.readUInt32()

                    case 50:
                        taskId = try codedInputStream.readString()

                    case 56:
                        let valueInttransMode = try codedInputStream.readEnum()
                        if let enumstransMode = Im.BaseDefine.TransferFileType(rawValue:valueInttransMode){
                            transMode = enumstransMode
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 7, value:Int64(valueInttransMode))
                        }

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImfileTransferRsp.Builder {
                let resultDecodedBuilder = Im.Server.ImfileTransferRsp.Builder()
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                if let jsonValueFromUserId = jsonMap["fromUserId"] as? UInt {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)
                } else if let jsonValueFromUserId = jsonMap["fromUserId"] as? String {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)!
                }
                if let jsonValueToUserId = jsonMap["toUserId"] as? UInt {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)
                } else if let jsonValueToUserId = jsonMap["toUserId"] as? String {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)!
                }
                if let jsonValueFileName = jsonMap["fileName"] as? String {
                    resultDecodedBuilder.fileName = jsonValueFileName
                }
                if let jsonValueFileSize = jsonMap["fileSize"] as? UInt {
                    resultDecodedBuilder.fileSize = UInt32(jsonValueFileSize)
                } else if let jsonValueFileSize = jsonMap["fileSize"] as? String {
                    resultDecodedBuilder.fileSize = UInt32(jsonValueFileSize)!
                }
                if let jsonValueTaskId = jsonMap["taskId"] as? String {
                    resultDecodedBuilder.taskId = jsonValueTaskId
                }
                if let jsonValueTransMode = jsonMap["transMode"] as? String {
                    resultDecodedBuilder.transMode = try Im.BaseDefine.TransferFileType.fromString(jsonValueTransMode)
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImfileTransferRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImfileTransferRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    ///cmd id:			0x0717
    final public class ImfileServerIpreq : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImfileServerIpreq.Builder

        public static func == (lhs: Im.Server.ImfileServerIpreq, rhs: Im.Server.ImfileServerIpreq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImfileServerIpreq.Builder {
            return Im.Server.ImfileServerIpreq.classBuilder() as! Im.Server.ImfileServerIpreq.Builder
        }
        public func getBuilder() -> Im.Server.ImfileServerIpreq.Builder {
            return classBuilder() as! Im.Server.ImfileServerIpreq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImfileServerIpreq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImfileServerIpreq.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImfileServerIpreq.Builder {
            return try Im.Server.ImfileServerIpreq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImfileServerIpreq) throws -> Im.Server.ImfileServerIpreq.Builder {
            return try Im.Server.ImfileServerIpreq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            let jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImfileServerIpreq {
            return try Im.Server.ImfileServerIpreq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImfileServerIpreq {
            return try Im.Server.ImfileServerIpreq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImfileServerIpreq"
        }
        override public func className() -> String {
            return "Im.Server.ImfileServerIpreq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImfileServerIpreq = Im.Server.ImfileServerIpreq()
            public func getMessage() -> Im.Server.ImfileServerIpreq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImfileServerIpreq.Builder {
                builderResult = Im.Server.ImfileServerIpreq()
                return self
            }
            override public func clone() throws -> Im.Server.ImfileServerIpreq.Builder {
                return try Im.Server.ImfileServerIpreq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImfileServerIpreq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImfileServerIpreq {
                let returnMe:Im.Server.ImfileServerIpreq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImfileServerIpreq) throws -> Im.Server.ImfileServerIpreq.Builder {
                if other == Im.Server.ImfileServerIpreq() {
                    return self
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImfileServerIpreq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileServerIpreq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImfileServerIpreq.Builder {
                let resultDecodedBuilder = Im.Server.ImfileServerIpreq.Builder()
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImfileServerIpreq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImfileServerIpreq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfileServerIprsp : GeneratedMessage {
        public typealias BuilderType = Im.Server.ImfileServerIprsp.Builder

        public static func == (lhs: Im.Server.ImfileServerIprsp, rhs: Im.Server.ImfileServerIprsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.ipAddrList == rhs.ipAddrList)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var ipAddrList:Array<Im.BaseDefine.IpAddr>  = Array<Im.BaseDefine.IpAddr>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            var isInitIpAddrList:Bool = true
            for oneElementIpAddrList in ipAddrList {
                if !oneElementIpAddrList.isInitialized() {
                    isInitIpAddrList = false
                    break 
                }
            }
            if !isInitIpAddrList {
                return isInitIpAddrList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            for oneElementIpAddrList in ipAddrList {
                  try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementIpAddrList)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            for oneElementIpAddrList in ipAddrList {
                serialize_size += oneElementIpAddrList.computeMessageSize(fieldNumber: 1)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Server.ImfileServerIprsp.Builder {
            return Im.Server.ImfileServerIprsp.classBuilder() as! Im.Server.ImfileServerIprsp.Builder
        }
        public func getBuilder() -> Im.Server.ImfileServerIprsp.Builder {
            return classBuilder() as! Im.Server.ImfileServerIprsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImfileServerIprsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Server.ImfileServerIprsp.Builder()
        }
        public func toBuilder() throws -> Im.Server.ImfileServerIprsp.Builder {
            return try Im.Server.ImfileServerIprsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Server.ImfileServerIprsp) throws -> Im.Server.ImfileServerIprsp.Builder {
            return try Im.Server.ImfileServerIprsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if !ipAddrList.isEmpty {
                var jsonArrayIpAddrList:Array<Dictionary<String,Any>> = []
                for oneValueIpAddrList in ipAddrList {
                    let ecodedMessageIpAddrList = try oneValueIpAddrList.encode()
                    jsonArrayIpAddrList.append(ecodedMessageIpAddrList)
                }
                jsonMap["ipAddrList"] = jsonArrayIpAddrList
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImfileServerIprsp {
            return try Im.Server.ImfileServerIprsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Server.ImfileServerIprsp {
            return try Im.Server.ImfileServerIprsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            var ipAddrListElementIndex:Int = 0
            for oneElementIpAddrList in ipAddrList {
                output += "\(indent) ipAddrList[\(ipAddrListElementIndex)] {\n"
                output += try oneElementIpAddrList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                ipAddrListElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                for oneElementIpAddrList in ipAddrList {
                    hashCode = (hashCode &* 31) &+ oneElementIpAddrList.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Server.ImfileServerIprsp"
        }
        override public func className() -> String {
            return "Im.Server.ImfileServerIprsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Server.ImfileServerIprsp = Im.Server.ImfileServerIprsp()
            public func getMessage() -> Im.Server.ImfileServerIprsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x0718
            public var ipAddrList:Array<Im.BaseDefine.IpAddr> {
                get {
                    return builderResult.ipAddrList
                }
                set (value) {
                    builderResult.ipAddrList = value
                }
            }
            @discardableResult
            public func setIpAddrList(_ value:Array<Im.BaseDefine.IpAddr>) -> Im.Server.ImfileServerIprsp.Builder {
                self.ipAddrList = value
                return self
            }
            @discardableResult
            public func clearIpAddrList() -> Im.Server.ImfileServerIprsp.Builder {
                builderResult.ipAddrList.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Server.ImfileServerIprsp.Builder {
                builderResult = Im.Server.ImfileServerIprsp()
                return self
            }
            override public func clone() throws -> Im.Server.ImfileServerIprsp.Builder {
                return try Im.Server.ImfileServerIprsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Server.ImfileServerIprsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Server.ImfileServerIprsp {
                let returnMe:Im.Server.ImfileServerIprsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Server.ImfileServerIprsp) throws -> Im.Server.ImfileServerIprsp.Builder {
                if other == Im.Server.ImfileServerIprsp() {
                    return self
                }
                if !other.ipAddrList.isEmpty  {
                     builderResult.ipAddrList += other.ipAddrList
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImfileServerIprsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileServerIprsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        let subBuilder = Im.BaseDefine.IpAddr.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        ipAddrList.append(subBuilder.buildPartial())

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Server.ImfileServerIprsp.Builder {
                let resultDecodedBuilder = Im.Server.ImfileServerIprsp.Builder()
                if let jsonValueIpAddrList = jsonMap["ipAddrList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayIpAddrList:Array<Im.BaseDefine.IpAddr> = []
                    for oneValueIpAddrList in jsonValueIpAddrList {
                        let messageFromStringIpAddrList = try Im.BaseDefine.IpAddr.Builder.decodeToBuilder(jsonMap:oneValueIpAddrList).build()

                        jsonArrayIpAddrList.append(messageFromStringIpAddrList)
                    }
                    resultDecodedBuilder.ipAddrList = jsonArrayIpAddrList
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Server.ImfileServerIprsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Server.ImfileServerIprsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Im.Server.ImstopReceivePacket: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImstopReceivePacket> {
        var mergedArray = Array<Im.Server.ImstopReceivePacket>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImstopReceivePacket? {
        return try Im.Server.ImstopReceivePacket.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImstopReceivePacket {
        return try Im.Server.ImstopReceivePacket.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImstopReceivePacket {
        return try Im.Server.ImstopReceivePacket.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImstopReceivePacket {
        return try Im.Server.ImstopReceivePacket.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImstopReceivePacket {
        return try Im.Server.ImstopReceivePacket.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImstopReceivePacket {
        return try Im.Server.ImstopReceivePacket.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImstopReceivePacket {
        return try Im.Server.ImstopReceivePacket.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "result": return self.result
        default: return nil
        }
    }
}
extension Im.Server.ImstopReceivePacket.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImstopReceivePacket
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "result": return self.result
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "result":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.result = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImvalidateReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImvalidateReq> {
        var mergedArray = Array<Im.Server.ImvalidateReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImvalidateReq? {
        return try Im.Server.ImvalidateReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImvalidateReq {
        return try Im.Server.ImvalidateReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImvalidateReq {
        return try Im.Server.ImvalidateReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImvalidateReq {
        return try Im.Server.ImvalidateReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImvalidateReq {
        return try Im.Server.ImvalidateReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImvalidateReq {
        return try Im.Server.ImvalidateReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImvalidateReq {
        return try Im.Server.ImvalidateReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userName": return self.userName
        case "password": return self.password
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Server.ImvalidateReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImvalidateReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userName": return self.userName
            case "password": return self.password
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userName = newSubscriptValue
            case "password":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.password = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImvalidateRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImvalidateRsp> {
        var mergedArray = Array<Im.Server.ImvalidateRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImvalidateRsp? {
        return try Im.Server.ImvalidateRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImvalidateRsp {
        return try Im.Server.ImvalidateRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImvalidateRsp {
        return try Im.Server.ImvalidateRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImvalidateRsp {
        return try Im.Server.ImvalidateRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImvalidateRsp {
        return try Im.Server.ImvalidateRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImvalidateRsp {
        return try Im.Server.ImvalidateRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImvalidateRsp {
        return try Im.Server.ImvalidateRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userName": return self.userName
        case "resultCode": return self.resultCode
        case "resultString": return self.resultString
        case "userInfo": return self.userInfo
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Server.ImvalidateRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImvalidateRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userName": return self.userName
            case "resultCode": return self.resultCode
            case "resultString": return self.resultString
            case "userInfo": return self.userInfo
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userName = newSubscriptValue
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "resultString":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.resultString = newSubscriptValue
            case "userInfo":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.UserInfo else {
                    return
                }
                self.userInfo = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImgetDeviceTokenReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImgetDeviceTokenReq> {
        var mergedArray = Array<Im.Server.ImgetDeviceTokenReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImgetDeviceTokenReq? {
        return try Im.Server.ImgetDeviceTokenReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImgetDeviceTokenReq {
        return try Im.Server.ImgetDeviceTokenReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgetDeviceTokenReq {
        return try Im.Server.ImgetDeviceTokenReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImgetDeviceTokenReq {
        return try Im.Server.ImgetDeviceTokenReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgetDeviceTokenReq {
        return try Im.Server.ImgetDeviceTokenReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImgetDeviceTokenReq {
        return try Im.Server.ImgetDeviceTokenReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgetDeviceTokenReq {
        return try Im.Server.ImgetDeviceTokenReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Server.ImgetDeviceTokenReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImgetDeviceTokenReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.userId = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImgetDeviceTokenRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImgetDeviceTokenRsp> {
        var mergedArray = Array<Im.Server.ImgetDeviceTokenRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImgetDeviceTokenRsp? {
        return try Im.Server.ImgetDeviceTokenRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImgetDeviceTokenRsp {
        return try Im.Server.ImgetDeviceTokenRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgetDeviceTokenRsp {
        return try Im.Server.ImgetDeviceTokenRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImgetDeviceTokenRsp {
        return try Im.Server.ImgetDeviceTokenRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgetDeviceTokenRsp {
        return try Im.Server.ImgetDeviceTokenRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImgetDeviceTokenRsp {
        return try Im.Server.ImgetDeviceTokenRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgetDeviceTokenRsp {
        return try Im.Server.ImgetDeviceTokenRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userTokenInfo": return self.userTokenInfo
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Server.ImgetDeviceTokenRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImgetDeviceTokenRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userTokenInfo": return self.userTokenInfo
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userTokenInfo":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.UserTokenInfo> else {
                    return
                }
                self.userTokenInfo = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImroleSet: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImroleSet> {
        var mergedArray = Array<Im.Server.ImroleSet>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImroleSet? {
        return try Im.Server.ImroleSet.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImroleSet {
        return try Im.Server.ImroleSet.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImroleSet {
        return try Im.Server.ImroleSet.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImroleSet {
        return try Im.Server.ImroleSet.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImroleSet {
        return try Im.Server.ImroleSet.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImroleSet {
        return try Im.Server.ImroleSet.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImroleSet {
        return try Im.Server.ImroleSet.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "master": return self.master
        default: return nil
        }
    }
}
extension Im.Server.ImroleSet.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImroleSet
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "master": return self.master
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "master":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.master = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImonlineUserInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImonlineUserInfo> {
        var mergedArray = Array<Im.Server.ImonlineUserInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImonlineUserInfo? {
        return try Im.Server.ImonlineUserInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImonlineUserInfo {
        return try Im.Server.ImonlineUserInfo.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImonlineUserInfo {
        return try Im.Server.ImonlineUserInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImonlineUserInfo {
        return try Im.Server.ImonlineUserInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImonlineUserInfo {
        return try Im.Server.ImonlineUserInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImonlineUserInfo {
        return try Im.Server.ImonlineUserInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImonlineUserInfo {
        return try Im.Server.ImonlineUserInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userStatList": return self.userStatList
        default: return nil
        }
    }
}
extension Im.Server.ImonlineUserInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImonlineUserInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userStatList": return self.userStatList
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userStatList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.ServerUserStat> else {
                    return
                }
                self.userStatList = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImmsgServInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImmsgServInfo> {
        var mergedArray = Array<Im.Server.ImmsgServInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImmsgServInfo? {
        return try Im.Server.ImmsgServInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImmsgServInfo {
        return try Im.Server.ImmsgServInfo.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImmsgServInfo {
        return try Im.Server.ImmsgServInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImmsgServInfo {
        return try Im.Server.ImmsgServInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImmsgServInfo {
        return try Im.Server.ImmsgServInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImmsgServInfo {
        return try Im.Server.ImmsgServInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImmsgServInfo {
        return try Im.Server.ImmsgServInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "ip1": return self.ip1
        case "ip2": return self.ip2
        case "port": return self.port
        case "maxConnCnt": return self.maxConnCnt
        case "curConnCnt": return self.curConnCnt
        case "hostName": return self.hostName
        default: return nil
        }
    }
}
extension Im.Server.ImmsgServInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImmsgServInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "ip1": return self.ip1
            case "ip2": return self.ip2
            case "port": return self.port
            case "maxConnCnt": return self.maxConnCnt
            case "curConnCnt": return self.curConnCnt
            case "hostName": return self.hostName
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "ip1":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.ip1 = newSubscriptValue
            case "ip2":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.ip2 = newSubscriptValue
            case "port":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.port = newSubscriptValue
            case "maxConnCnt":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.maxConnCnt = newSubscriptValue
            case "curConnCnt":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.curConnCnt = newSubscriptValue
            case "hostName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.hostName = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImuserStatusUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImuserStatusUpdate> {
        var mergedArray = Array<Im.Server.ImuserStatusUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImuserStatusUpdate? {
        return try Im.Server.ImuserStatusUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImuserStatusUpdate {
        return try Im.Server.ImuserStatusUpdate.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImuserStatusUpdate {
        return try Im.Server.ImuserStatusUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImuserStatusUpdate {
        return try Im.Server.ImuserStatusUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImuserStatusUpdate {
        return try Im.Server.ImuserStatusUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImuserStatusUpdate {
        return try Im.Server.ImuserStatusUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImuserStatusUpdate {
        return try Im.Server.ImuserStatusUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userStatus": return self.userStatus
        case "userId": return self.userId
        case "clientType": return self.clientType
        default: return nil
        }
    }
}
extension Im.Server.ImuserStatusUpdate.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImuserStatusUpdate
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userStatus": return self.userStatus
            case "userId": return self.userId
            case "clientType": return self.clientType
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userStatus":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userStatus = newSubscriptValue
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "clientType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.ClientType else {
                    return
                }
                self.clientType = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImuserCntUpdate: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImuserCntUpdate> {
        var mergedArray = Array<Im.Server.ImuserCntUpdate>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImuserCntUpdate? {
        return try Im.Server.ImuserCntUpdate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImuserCntUpdate {
        return try Im.Server.ImuserCntUpdate.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImuserCntUpdate {
        return try Im.Server.ImuserCntUpdate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImuserCntUpdate {
        return try Im.Server.ImuserCntUpdate.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImuserCntUpdate {
        return try Im.Server.ImuserCntUpdate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImuserCntUpdate {
        return try Im.Server.ImuserCntUpdate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImuserCntUpdate {
        return try Im.Server.ImuserCntUpdate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userAction": return self.userAction
        case "userId": return self.userId
        default: return nil
        }
    }
}
extension Im.Server.ImuserCntUpdate.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImuserCntUpdate
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userAction": return self.userAction
            case "userId": return self.userId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userAction":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userAction = newSubscriptValue
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImserverKickUser: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImserverKickUser> {
        var mergedArray = Array<Im.Server.ImserverKickUser>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImserverKickUser? {
        return try Im.Server.ImserverKickUser.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImserverKickUser {
        return try Im.Server.ImserverKickUser.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImserverKickUser {
        return try Im.Server.ImserverKickUser.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImserverKickUser {
        return try Im.Server.ImserverKickUser.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImserverKickUser {
        return try Im.Server.ImserverKickUser.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImserverKickUser {
        return try Im.Server.ImserverKickUser.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImserverKickUser {
        return try Im.Server.ImserverKickUser.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "clientType": return self.clientType
        case "reason": return self.reason
        default: return nil
        }
    }
}
extension Im.Server.ImserverKickUser.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImserverKickUser
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "clientType": return self.clientType
            case "reason": return self.reason
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "clientType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.ClientType else {
                    return
                }
                self.clientType = newSubscriptValue
            case "reason":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.reason = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImserverPcloginStatusNotify: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImserverPcloginStatusNotify> {
        var mergedArray = Array<Im.Server.ImserverPcloginStatusNotify>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImserverPcloginStatusNotify? {
        return try Im.Server.ImserverPcloginStatusNotify.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImserverPcloginStatusNotify {
        return try Im.Server.ImserverPcloginStatusNotify.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImserverPcloginStatusNotify {
        return try Im.Server.ImserverPcloginStatusNotify.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImserverPcloginStatusNotify {
        return try Im.Server.ImserverPcloginStatusNotify.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImserverPcloginStatusNotify {
        return try Im.Server.ImserverPcloginStatusNotify.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImserverPcloginStatusNotify {
        return try Im.Server.ImserverPcloginStatusNotify.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImserverPcloginStatusNotify {
        return try Im.Server.ImserverPcloginStatusNotify.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "loginStatus": return self.loginStatus
        default: return nil
        }
    }
}
extension Im.Server.ImserverPcloginStatusNotify.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImserverPcloginStatusNotify
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "loginStatus": return self.loginStatus
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "loginStatus":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.loginStatus = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImpushToUserReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImpushToUserReq> {
        var mergedArray = Array<Im.Server.ImpushToUserReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImpushToUserReq? {
        return try Im.Server.ImpushToUserReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImpushToUserReq {
        return try Im.Server.ImpushToUserReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImpushToUserReq {
        return try Im.Server.ImpushToUserReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImpushToUserReq {
        return try Im.Server.ImpushToUserReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImpushToUserReq {
        return try Im.Server.ImpushToUserReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImpushToUserReq {
        return try Im.Server.ImpushToUserReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImpushToUserReq {
        return try Im.Server.ImpushToUserReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "flash": return self.flash
        case "data": return self.data
        case "userTokenList": return self.userTokenList
        default: return nil
        }
    }
}
extension Im.Server.ImpushToUserReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImpushToUserReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "flash": return self.flash
            case "data": return self.data
            case "userTokenList": return self.userTokenList
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "flash":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.flash = newSubscriptValue
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.data = newSubscriptValue
            case "userTokenList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.UserTokenInfo> else {
                    return
                }
                self.userTokenList = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImpushToUserRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImpushToUserRsp> {
        var mergedArray = Array<Im.Server.ImpushToUserRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImpushToUserRsp? {
        return try Im.Server.ImpushToUserRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImpushToUserRsp {
        return try Im.Server.ImpushToUserRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImpushToUserRsp {
        return try Im.Server.ImpushToUserRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImpushToUserRsp {
        return try Im.Server.ImpushToUserRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImpushToUserRsp {
        return try Im.Server.ImpushToUserRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImpushToUserRsp {
        return try Im.Server.ImpushToUserRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImpushToUserRsp {
        return try Im.Server.ImpushToUserRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "pushResultList": return self.pushResultList
        default: return nil
        }
    }
}
extension Im.Server.ImpushToUserRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImpushToUserRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "pushResultList": return self.pushResultList
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "pushResultList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.PushResult> else {
                    return
                }
                self.pushResultList = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImgroupGetShieldReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImgroupGetShieldReq> {
        var mergedArray = Array<Im.Server.ImgroupGetShieldReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImgroupGetShieldReq? {
        return try Im.Server.ImgroupGetShieldReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImgroupGetShieldReq {
        return try Im.Server.ImgroupGetShieldReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgroupGetShieldReq {
        return try Im.Server.ImgroupGetShieldReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImgroupGetShieldReq {
        return try Im.Server.ImgroupGetShieldReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgroupGetShieldReq {
        return try Im.Server.ImgroupGetShieldReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImgroupGetShieldReq {
        return try Im.Server.ImgroupGetShieldReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgroupGetShieldReq {
        return try Im.Server.ImgroupGetShieldReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        case "userId": return self.userId
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Server.ImgroupGetShieldReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImgroupGetShieldReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            case "userId": return self.userId
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.groupId = newSubscriptValue
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.userId = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImgroupGetShieldRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImgroupGetShieldRsp> {
        var mergedArray = Array<Im.Server.ImgroupGetShieldRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImgroupGetShieldRsp? {
        return try Im.Server.ImgroupGetShieldRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImgroupGetShieldRsp {
        return try Im.Server.ImgroupGetShieldRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgroupGetShieldRsp {
        return try Im.Server.ImgroupGetShieldRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImgroupGetShieldRsp {
        return try Im.Server.ImgroupGetShieldRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgroupGetShieldRsp {
        return try Im.Server.ImgroupGetShieldRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImgroupGetShieldRsp {
        return try Im.Server.ImgroupGetShieldRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImgroupGetShieldRsp {
        return try Im.Server.ImgroupGetShieldRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        case "shieldStatusList": return self.shieldStatusList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Server.ImgroupGetShieldRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImgroupGetShieldRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            case "shieldStatusList": return self.shieldStatusList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.groupId = newSubscriptValue
            case "shieldStatusList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.ShieldStatus> else {
                    return
                }
                self.shieldStatusList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImfileTransferReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImfileTransferReq> {
        var mergedArray = Array<Im.Server.ImfileTransferReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImfileTransferReq? {
        return try Im.Server.ImfileTransferReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImfileTransferReq {
        return try Im.Server.ImfileTransferReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileTransferReq {
        return try Im.Server.ImfileTransferReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImfileTransferReq {
        return try Im.Server.ImfileTransferReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileTransferReq {
        return try Im.Server.ImfileTransferReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImfileTransferReq {
        return try Im.Server.ImfileTransferReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileTransferReq {
        return try Im.Server.ImfileTransferReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "fromUserId": return self.fromUserId
        case "toUserId": return self.toUserId
        case "fileName": return self.fileName
        case "fileSize": return self.fileSize
        case "transMode": return self.transMode
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Server.ImfileTransferReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImfileTransferReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "fromUserId": return self.fromUserId
            case "toUserId": return self.toUserId
            case "fileName": return self.fileName
            case "fileSize": return self.fileSize
            case "transMode": return self.transMode
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "fromUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fromUserId = newSubscriptValue
            case "toUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.toUserId = newSubscriptValue
            case "fileName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fileName = newSubscriptValue
            case "fileSize":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fileSize = newSubscriptValue
            case "transMode":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.TransferFileType else {
                    return
                }
                self.transMode = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImfileTransferRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImfileTransferRsp> {
        var mergedArray = Array<Im.Server.ImfileTransferRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImfileTransferRsp? {
        return try Im.Server.ImfileTransferRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImfileTransferRsp {
        return try Im.Server.ImfileTransferRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileTransferRsp {
        return try Im.Server.ImfileTransferRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImfileTransferRsp {
        return try Im.Server.ImfileTransferRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileTransferRsp {
        return try Im.Server.ImfileTransferRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImfileTransferRsp {
        return try Im.Server.ImfileTransferRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileTransferRsp {
        return try Im.Server.ImfileTransferRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "resultCode": return self.resultCode
        case "fromUserId": return self.fromUserId
        case "toUserId": return self.toUserId
        case "fileName": return self.fileName
        case "fileSize": return self.fileSize
        case "taskId": return self.taskId
        case "transMode": return self.transMode
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Server.ImfileTransferRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImfileTransferRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "resultCode": return self.resultCode
            case "fromUserId": return self.fromUserId
            case "toUserId": return self.toUserId
            case "fileName": return self.fileName
            case "fileSize": return self.fileSize
            case "taskId": return self.taskId
            case "transMode": return self.transMode
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "fromUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fromUserId = newSubscriptValue
            case "toUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.toUserId = newSubscriptValue
            case "fileName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fileName = newSubscriptValue
            case "fileSize":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fileSize = newSubscriptValue
            case "taskId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.taskId = newSubscriptValue
            case "transMode":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.TransferFileType else {
                    return
                }
                self.transMode = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Server.ImfileServerIpreq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImfileServerIpreq> {
        var mergedArray = Array<Im.Server.ImfileServerIpreq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImfileServerIpreq? {
        return try Im.Server.ImfileServerIpreq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImfileServerIpreq {
        return try Im.Server.ImfileServerIpreq.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileServerIpreq {
        return try Im.Server.ImfileServerIpreq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImfileServerIpreq {
        return try Im.Server.ImfileServerIpreq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileServerIpreq {
        return try Im.Server.ImfileServerIpreq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImfileServerIpreq {
        return try Im.Server.ImfileServerIpreq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileServerIpreq {
        return try Im.Server.ImfileServerIpreq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        return nil
    }
}
extension Im.Server.ImfileServerIpreq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImfileServerIpreq
    public subscript(key: String) -> Any? {
        get { return nil }
        set { }
    }
}
extension Im.Server.ImfileServerIprsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Server.ImfileServerIprsp> {
        var mergedArray = Array<Im.Server.ImfileServerIprsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Server.ImfileServerIprsp? {
        return try Im.Server.ImfileServerIprsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Server.ImfileServerIprsp {
        return try Im.Server.ImfileServerIprsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Server.ImserverRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileServerIprsp {
        return try Im.Server.ImfileServerIprsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Server.ImfileServerIprsp {
        return try Im.Server.ImfileServerIprsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileServerIprsp {
        return try Im.Server.ImfileServerIprsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Server.ImfileServerIprsp {
        return try Im.Server.ImfileServerIprsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Server.ImfileServerIprsp {
        return try Im.Server.ImfileServerIprsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "ipAddrList": return self.ipAddrList
        default: return nil
        }
    }
}
extension Im.Server.ImfileServerIprsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Server.ImfileServerIprsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "ipAddrList": return self.ipAddrList
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "ipAddrList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.IpAddr> else {
                    return
                }
                self.ipAddrList = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
