/// Generated by the Protocol Buffers 3.3.2 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "IM.BaseDefine.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers

public struct Im {
    public struct BaseDefine { }
}

public extension Im.BaseDefine {
    public struct ImbaseDefineRoot {
        public static let `default` = ImbaseDefineRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }



    //Enum type declaration start 

    /// service id
    public enum ServiceId:Int32, GeneratedEnum {
        ///for login
        case sidLogin = 1

        ///for friend list
        case sidBuddyList = 2
        case sidMsg = 3

        ///for group message
        case sidGroup = 4
        case sidFile = 5
        case sidSwitchService = 6
        case sidOther = 7
        case sidInternal = 8
        public func toString() -> String {
            switch self {
            case .sidLogin: return "SID_LOGIN"
            case .sidBuddyList: return "SID_BUDDY_LIST"
            case .sidMsg: return "SID_MSG"
            case .sidGroup: return "SID_GROUP"
            case .sidFile: return "SID_FILE"
            case .sidSwitchService: return "SID_SWITCH_SERVICE"
            case .sidOther: return "SID_OTHER"
            case .sidInternal: return "SID_INTERNAL"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.ServiceId {
            switch str {
            case "SID_LOGIN":    return .sidLogin
            case "SID_BUDDY_LIST":    return .sidBuddyList
            case "SID_MSG":    return .sidMsg
            case "SID_GROUP":    return .sidGroup
            case "SID_FILE":    return .sidFile
            case "SID_SWITCH_SERVICE":    return .sidSwitchService
            case "SID_OTHER":    return .sidOther
            case "SID_INTERNAL":    return .sidInternal
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .sidLogin: return ".sidLogin"
            case .sidBuddyList: return ".sidBuddyList"
            case .sidMsg: return ".sidMsg"
            case .sidGroup: return ".sidGroup"
            case .sidFile: return ".sidFile"
            case .sidSwitchService: return ".sidSwitchService"
            case .sidOther: return ".sidOther"
            case .sidInternal: return ".sidInternal"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:ServiceId, rhs:ServiceId) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    /// command id for login
    public enum LoginCmdId:Int32, GeneratedEnum {
        case cidLoginReqMsgserver = 257
        case cidLoginResMsgserver = 258
        case cidLoginReqUserlogin = 259
        case cidLoginResUserlogin = 260
        case cidLoginReqLoginout = 261
        case cidLoginResLoginout = 262
        case cidLoginKickUser = 263
        case cidLoginReqDevicetoken = 264
        case cidLoginResDevicetoken = 265
        case cidLoginReqKickpcclient = 266
        case cidLoginResKickpcclient = 267

        ///勿扰
        case cidLoginReqPushShield = 268
        case cidLoginResPushShield = 269
        case cidLoginReqQueryPushShield = 270
        case cidLoginResQueryPushShield = 271

        ///修改密碼
        case cidLoginReqModifyPass = 272
        case cidLoginResModifyPass = 273
        public func toString() -> String {
            switch self {
            case .cidLoginReqMsgserver: return "CID_LOGIN_REQ_MSGSERVER"
            case .cidLoginResMsgserver: return "CID_LOGIN_RES_MSGSERVER"
            case .cidLoginReqUserlogin: return "CID_LOGIN_REQ_USERLOGIN"
            case .cidLoginResUserlogin: return "CID_LOGIN_RES_USERLOGIN"
            case .cidLoginReqLoginout: return "CID_LOGIN_REQ_LOGINOUT"
            case .cidLoginResLoginout: return "CID_LOGIN_RES_LOGINOUT"
            case .cidLoginKickUser: return "CID_LOGIN_KICK_USER"
            case .cidLoginReqDevicetoken: return "CID_LOGIN_REQ_DEVICETOKEN"
            case .cidLoginResDevicetoken: return "CID_LOGIN_RES_DEVICETOKEN"
            case .cidLoginReqKickpcclient: return "CID_LOGIN_REQ_KICKPCCLIENT"
            case .cidLoginResKickpcclient: return "CID_LOGIN_RES_KICKPCCLIENT"
            case .cidLoginReqPushShield: return "CID_LOGIN_REQ_PUSH_SHIELD"
            case .cidLoginResPushShield: return "CID_LOGIN_RES_PUSH_SHIELD"
            case .cidLoginReqQueryPushShield: return "CID_LOGIN_REQ_QUERY_PUSH_SHIELD"
            case .cidLoginResQueryPushShield: return "CID_LOGIN_RES_QUERY_PUSH_SHIELD"
            case .cidLoginReqModifyPass: return "CID_LOGIN_REQ_MODIFY_PASS"
            case .cidLoginResModifyPass: return "CID_LOGIN_RES_MODIFY_PASS"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.LoginCmdId {
            switch str {
            case "CID_LOGIN_REQ_MSGSERVER":    return .cidLoginReqMsgserver
            case "CID_LOGIN_RES_MSGSERVER":    return .cidLoginResMsgserver
            case "CID_LOGIN_REQ_USERLOGIN":    return .cidLoginReqUserlogin
            case "CID_LOGIN_RES_USERLOGIN":    return .cidLoginResUserlogin
            case "CID_LOGIN_REQ_LOGINOUT":    return .cidLoginReqLoginout
            case "CID_LOGIN_RES_LOGINOUT":    return .cidLoginResLoginout
            case "CID_LOGIN_KICK_USER":    return .cidLoginKickUser
            case "CID_LOGIN_REQ_DEVICETOKEN":    return .cidLoginReqDevicetoken
            case "CID_LOGIN_RES_DEVICETOKEN":    return .cidLoginResDevicetoken
            case "CID_LOGIN_REQ_KICKPCCLIENT":    return .cidLoginReqKickpcclient
            case "CID_LOGIN_RES_KICKPCCLIENT":    return .cidLoginResKickpcclient
            case "CID_LOGIN_REQ_PUSH_SHIELD":    return .cidLoginReqPushShield
            case "CID_LOGIN_RES_PUSH_SHIELD":    return .cidLoginResPushShield
            case "CID_LOGIN_REQ_QUERY_PUSH_SHIELD":    return .cidLoginReqQueryPushShield
            case "CID_LOGIN_RES_QUERY_PUSH_SHIELD":    return .cidLoginResQueryPushShield
            case "CID_LOGIN_REQ_MODIFY_PASS":    return .cidLoginReqModifyPass
            case "CID_LOGIN_RES_MODIFY_PASS":    return .cidLoginResModifyPass
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .cidLoginReqMsgserver: return ".cidLoginReqMsgserver"
            case .cidLoginResMsgserver: return ".cidLoginResMsgserver"
            case .cidLoginReqUserlogin: return ".cidLoginReqUserlogin"
            case .cidLoginResUserlogin: return ".cidLoginResUserlogin"
            case .cidLoginReqLoginout: return ".cidLoginReqLoginout"
            case .cidLoginResLoginout: return ".cidLoginResLoginout"
            case .cidLoginKickUser: return ".cidLoginKickUser"
            case .cidLoginReqDevicetoken: return ".cidLoginReqDevicetoken"
            case .cidLoginResDevicetoken: return ".cidLoginResDevicetoken"
            case .cidLoginReqKickpcclient: return ".cidLoginReqKickpcclient"
            case .cidLoginResKickpcclient: return ".cidLoginResKickpcclient"
            case .cidLoginReqPushShield: return ".cidLoginReqPushShield"
            case .cidLoginResPushShield: return ".cidLoginResPushShield"
            case .cidLoginReqQueryPushShield: return ".cidLoginReqQueryPushShield"
            case .cidLoginResQueryPushShield: return ".cidLoginResQueryPushShield"
            case .cidLoginReqModifyPass: return ".cidLoginReqModifyPass"
            case .cidLoginResModifyPass: return ".cidLoginResModifyPass"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:LoginCmdId, rhs:LoginCmdId) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    /// command id for buddy list
    public enum BuddyListCmdId:Int32, GeneratedEnum {
        case cidBuddyListRecentContactSessionRequest = 513
        case cidBuddyListRecentContactSessionResponse = 514
        case cidBuddyListStatusNotify = 515
        case cidBuddyListUserInfoRequest = 516
        case cidBuddyListUserInfoResponse = 517
        case cidBuddyListRemoveSessionReq = 518
        case cidBuddyListRemoveSessionRes = 519
        case cidBuddyListAllUserRequest = 520
        case cidBuddyListAllUserResponse = 521
        case cidBuddyListUsersStatusRequest = 522
        case cidBuddyListUsersStatusResponse = 523
        case cidBuddyListChangeAvatarRequest = 524
        case cidBuddyListChangeAvatarResponse = 525
        case cidBuddyListPcLoginStatusNotify = 526
        case cidBuddyListRemoveSessionNotify = 527
        case cidBuddyListDepartmentRequest = 528
        case cidBuddyListDepartmentResponse = 529

        ///头像更改通知
        case cidBuddyListAvatarChangedNotify = 530

        ///修改个性签名请求
        case cidBuddyListChangeSignInfoRequest = 531
        case cidBuddyListChangeSignInfoResponse = 532

        ///签名修改通知
        case cidBuddyListSignInfoChangedNotify = 533

        ///真正的好友列表
        case cidFriendUserListRequest = 534
        case cidFriendUserListResponse = 535
        public func toString() -> String {
            switch self {
            case .cidBuddyListRecentContactSessionRequest: return "CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST"
            case .cidBuddyListRecentContactSessionResponse: return "CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE"
            case .cidBuddyListStatusNotify: return "CID_BUDDY_LIST_STATUS_NOTIFY"
            case .cidBuddyListUserInfoRequest: return "CID_BUDDY_LIST_USER_INFO_REQUEST"
            case .cidBuddyListUserInfoResponse: return "CID_BUDDY_LIST_USER_INFO_RESPONSE"
            case .cidBuddyListRemoveSessionReq: return "CID_BUDDY_LIST_REMOVE_SESSION_REQ"
            case .cidBuddyListRemoveSessionRes: return "CID_BUDDY_LIST_REMOVE_SESSION_RES"
            case .cidBuddyListAllUserRequest: return "CID_BUDDY_LIST_ALL_USER_REQUEST"
            case .cidBuddyListAllUserResponse: return "CID_BUDDY_LIST_ALL_USER_RESPONSE"
            case .cidBuddyListUsersStatusRequest: return "CID_BUDDY_LIST_USERS_STATUS_REQUEST"
            case .cidBuddyListUsersStatusResponse: return "CID_BUDDY_LIST_USERS_STATUS_RESPONSE"
            case .cidBuddyListChangeAvatarRequest: return "CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST"
            case .cidBuddyListChangeAvatarResponse: return "CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE"
            case .cidBuddyListPcLoginStatusNotify: return "CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY"
            case .cidBuddyListRemoveSessionNotify: return "CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY"
            case .cidBuddyListDepartmentRequest: return "CID_BUDDY_LIST_DEPARTMENT_REQUEST"
            case .cidBuddyListDepartmentResponse: return "CID_BUDDY_LIST_DEPARTMENT_RESPONSE"
            case .cidBuddyListAvatarChangedNotify: return "CID_BUDDY_LIST_AVATAR_CHANGED_NOTIFY"
            case .cidBuddyListChangeSignInfoRequest: return "CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST"
            case .cidBuddyListChangeSignInfoResponse: return "CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE"
            case .cidBuddyListSignInfoChangedNotify: return "CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY"
            case .cidFriendUserListRequest: return "CID_FRIEND_USER_LIST_REQUEST"
            case .cidFriendUserListResponse: return "CID_FRIEND_USER_LIST_RESPONSE"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.BuddyListCmdId {
            switch str {
            case "CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST":    return .cidBuddyListRecentContactSessionRequest
            case "CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE":    return .cidBuddyListRecentContactSessionResponse
            case "CID_BUDDY_LIST_STATUS_NOTIFY":    return .cidBuddyListStatusNotify
            case "CID_BUDDY_LIST_USER_INFO_REQUEST":    return .cidBuddyListUserInfoRequest
            case "CID_BUDDY_LIST_USER_INFO_RESPONSE":    return .cidBuddyListUserInfoResponse
            case "CID_BUDDY_LIST_REMOVE_SESSION_REQ":    return .cidBuddyListRemoveSessionReq
            case "CID_BUDDY_LIST_REMOVE_SESSION_RES":    return .cidBuddyListRemoveSessionRes
            case "CID_BUDDY_LIST_ALL_USER_REQUEST":    return .cidBuddyListAllUserRequest
            case "CID_BUDDY_LIST_ALL_USER_RESPONSE":    return .cidBuddyListAllUserResponse
            case "CID_BUDDY_LIST_USERS_STATUS_REQUEST":    return .cidBuddyListUsersStatusRequest
            case "CID_BUDDY_LIST_USERS_STATUS_RESPONSE":    return .cidBuddyListUsersStatusResponse
            case "CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST":    return .cidBuddyListChangeAvatarRequest
            case "CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE":    return .cidBuddyListChangeAvatarResponse
            case "CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY":    return .cidBuddyListPcLoginStatusNotify
            case "CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY":    return .cidBuddyListRemoveSessionNotify
            case "CID_BUDDY_LIST_DEPARTMENT_REQUEST":    return .cidBuddyListDepartmentRequest
            case "CID_BUDDY_LIST_DEPARTMENT_RESPONSE":    return .cidBuddyListDepartmentResponse
            case "CID_BUDDY_LIST_AVATAR_CHANGED_NOTIFY":    return .cidBuddyListAvatarChangedNotify
            case "CID_BUDDY_LIST_CHANGE_SIGN_INFO_REQUEST":    return .cidBuddyListChangeSignInfoRequest
            case "CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE":    return .cidBuddyListChangeSignInfoResponse
            case "CID_BUDDY_LIST_SIGN_INFO_CHANGED_NOTIFY":    return .cidBuddyListSignInfoChangedNotify
            case "CID_FRIEND_USER_LIST_REQUEST":    return .cidFriendUserListRequest
            case "CID_FRIEND_USER_LIST_RESPONSE":    return .cidFriendUserListResponse
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .cidBuddyListRecentContactSessionRequest: return ".cidBuddyListRecentContactSessionRequest"
            case .cidBuddyListRecentContactSessionResponse: return ".cidBuddyListRecentContactSessionResponse"
            case .cidBuddyListStatusNotify: return ".cidBuddyListStatusNotify"
            case .cidBuddyListUserInfoRequest: return ".cidBuddyListUserInfoRequest"
            case .cidBuddyListUserInfoResponse: return ".cidBuddyListUserInfoResponse"
            case .cidBuddyListRemoveSessionReq: return ".cidBuddyListRemoveSessionReq"
            case .cidBuddyListRemoveSessionRes: return ".cidBuddyListRemoveSessionRes"
            case .cidBuddyListAllUserRequest: return ".cidBuddyListAllUserRequest"
            case .cidBuddyListAllUserResponse: return ".cidBuddyListAllUserResponse"
            case .cidBuddyListUsersStatusRequest: return ".cidBuddyListUsersStatusRequest"
            case .cidBuddyListUsersStatusResponse: return ".cidBuddyListUsersStatusResponse"
            case .cidBuddyListChangeAvatarRequest: return ".cidBuddyListChangeAvatarRequest"
            case .cidBuddyListChangeAvatarResponse: return ".cidBuddyListChangeAvatarResponse"
            case .cidBuddyListPcLoginStatusNotify: return ".cidBuddyListPcLoginStatusNotify"
            case .cidBuddyListRemoveSessionNotify: return ".cidBuddyListRemoveSessionNotify"
            case .cidBuddyListDepartmentRequest: return ".cidBuddyListDepartmentRequest"
            case .cidBuddyListDepartmentResponse: return ".cidBuddyListDepartmentResponse"
            case .cidBuddyListAvatarChangedNotify: return ".cidBuddyListAvatarChangedNotify"
            case .cidBuddyListChangeSignInfoRequest: return ".cidBuddyListChangeSignInfoRequest"
            case .cidBuddyListChangeSignInfoResponse: return ".cidBuddyListChangeSignInfoResponse"
            case .cidBuddyListSignInfoChangedNotify: return ".cidBuddyListSignInfoChangedNotify"
            case .cidFriendUserListRequest: return ".cidFriendUserListRequest"
            case .cidFriendUserListResponse: return ".cidFriendUserListResponse"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:BuddyListCmdId, rhs:BuddyListCmdId) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    /// command id for msg
    public enum MessageCmdId:Int32, GeneratedEnum {
        case cidMsgData = 769
        case cidMsgDataAck = 770
        case cidMsgReadAck = 771

        ///已读消息通知
        case cidMsgReadNotify = 772
        case cidMsgTimeRequest = 773
        case cidMsgTimeResponse = 774
        case cidMsgUnreadCntRequest = 775
        case cidMsgUnreadCntResponse = 776

        ///获取指定队列消息
        case cidMsgListRequest = 777
        case cidMsgListResponse = 778
        case cidMsgGetLatestMsgIdReq = 779
        case cidMsgGetLatestMsgIdRsp = 780
        case cidMsgGetByMsgIdReq = 781
        case cidMsgGetByMsgIdRes = 782
        public func toString() -> String {
            switch self {
            case .cidMsgData: return "CID_MSG_DATA"
            case .cidMsgDataAck: return "CID_MSG_DATA_ACK"
            case .cidMsgReadAck: return "CID_MSG_READ_ACK"
            case .cidMsgReadNotify: return "CID_MSG_READ_NOTIFY"
            case .cidMsgTimeRequest: return "CID_MSG_TIME_REQUEST"
            case .cidMsgTimeResponse: return "CID_MSG_TIME_RESPONSE"
            case .cidMsgUnreadCntRequest: return "CID_MSG_UNREAD_CNT_REQUEST"
            case .cidMsgUnreadCntResponse: return "CID_MSG_UNREAD_CNT_RESPONSE"
            case .cidMsgListRequest: return "CID_MSG_LIST_REQUEST"
            case .cidMsgListResponse: return "CID_MSG_LIST_RESPONSE"
            case .cidMsgGetLatestMsgIdReq: return "CID_MSG_GET_LATEST_MSG_ID_REQ"
            case .cidMsgGetLatestMsgIdRsp: return "CID_MSG_GET_LATEST_MSG_ID_RSP"
            case .cidMsgGetByMsgIdReq: return "CID_MSG_GET_BY_MSG_ID_REQ"
            case .cidMsgGetByMsgIdRes: return "CID_MSG_GET_BY_MSG_ID_RES"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.MessageCmdId {
            switch str {
            case "CID_MSG_DATA":    return .cidMsgData
            case "CID_MSG_DATA_ACK":    return .cidMsgDataAck
            case "CID_MSG_READ_ACK":    return .cidMsgReadAck
            case "CID_MSG_READ_NOTIFY":    return .cidMsgReadNotify
            case "CID_MSG_TIME_REQUEST":    return .cidMsgTimeRequest
            case "CID_MSG_TIME_RESPONSE":    return .cidMsgTimeResponse
            case "CID_MSG_UNREAD_CNT_REQUEST":    return .cidMsgUnreadCntRequest
            case "CID_MSG_UNREAD_CNT_RESPONSE":    return .cidMsgUnreadCntResponse
            case "CID_MSG_LIST_REQUEST":    return .cidMsgListRequest
            case "CID_MSG_LIST_RESPONSE":    return .cidMsgListResponse
            case "CID_MSG_GET_LATEST_MSG_ID_REQ":    return .cidMsgGetLatestMsgIdReq
            case "CID_MSG_GET_LATEST_MSG_ID_RSP":    return .cidMsgGetLatestMsgIdRsp
            case "CID_MSG_GET_BY_MSG_ID_REQ":    return .cidMsgGetByMsgIdReq
            case "CID_MSG_GET_BY_MSG_ID_RES":    return .cidMsgGetByMsgIdRes
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .cidMsgData: return ".cidMsgData"
            case .cidMsgDataAck: return ".cidMsgDataAck"
            case .cidMsgReadAck: return ".cidMsgReadAck"
            case .cidMsgReadNotify: return ".cidMsgReadNotify"
            case .cidMsgTimeRequest: return ".cidMsgTimeRequest"
            case .cidMsgTimeResponse: return ".cidMsgTimeResponse"
            case .cidMsgUnreadCntRequest: return ".cidMsgUnreadCntRequest"
            case .cidMsgUnreadCntResponse: return ".cidMsgUnreadCntResponse"
            case .cidMsgListRequest: return ".cidMsgListRequest"
            case .cidMsgListResponse: return ".cidMsgListResponse"
            case .cidMsgGetLatestMsgIdReq: return ".cidMsgGetLatestMsgIdReq"
            case .cidMsgGetLatestMsgIdRsp: return ".cidMsgGetLatestMsgIdRsp"
            case .cidMsgGetByMsgIdReq: return ".cidMsgGetByMsgIdReq"
            case .cidMsgGetByMsgIdRes: return ".cidMsgGetByMsgIdRes"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:MessageCmdId, rhs:MessageCmdId) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    /// command id for group message
    public enum GroupCmdId:Int32, GeneratedEnum {
        case cidGroupNormalListRequest = 1025
        case cidGroupNormalListResponse = 1026
        case cidGroupInfoRequest = 1027
        case cidGroupInfoResponse = 1028
        case cidGroupCreateRequest = 1029
        case cidGroupCreateResponse = 1030
        case cidGroupChangeMemberRequest = 1031
        case cidGroupChangeMemberResponse = 1032
        case cidGroupShieldGroupRequest = 1033
        case cidGroupShieldGroupResponse = 1034
        case cidGroupChangeMemberNotify = 1035
        public func toString() -> String {
            switch self {
            case .cidGroupNormalListRequest: return "CID_GROUP_NORMAL_LIST_REQUEST"
            case .cidGroupNormalListResponse: return "CID_GROUP_NORMAL_LIST_RESPONSE"
            case .cidGroupInfoRequest: return "CID_GROUP_INFO_REQUEST"
            case .cidGroupInfoResponse: return "CID_GROUP_INFO_RESPONSE"
            case .cidGroupCreateRequest: return "CID_GROUP_CREATE_REQUEST"
            case .cidGroupCreateResponse: return "CID_GROUP_CREATE_RESPONSE"
            case .cidGroupChangeMemberRequest: return "CID_GROUP_CHANGE_MEMBER_REQUEST"
            case .cidGroupChangeMemberResponse: return "CID_GROUP_CHANGE_MEMBER_RESPONSE"
            case .cidGroupShieldGroupRequest: return "CID_GROUP_SHIELD_GROUP_REQUEST"
            case .cidGroupShieldGroupResponse: return "CID_GROUP_SHIELD_GROUP_RESPONSE"
            case .cidGroupChangeMemberNotify: return "CID_GROUP_CHANGE_MEMBER_NOTIFY"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.GroupCmdId {
            switch str {
            case "CID_GROUP_NORMAL_LIST_REQUEST":    return .cidGroupNormalListRequest
            case "CID_GROUP_NORMAL_LIST_RESPONSE":    return .cidGroupNormalListResponse
            case "CID_GROUP_INFO_REQUEST":    return .cidGroupInfoRequest
            case "CID_GROUP_INFO_RESPONSE":    return .cidGroupInfoResponse
            case "CID_GROUP_CREATE_REQUEST":    return .cidGroupCreateRequest
            case "CID_GROUP_CREATE_RESPONSE":    return .cidGroupCreateResponse
            case "CID_GROUP_CHANGE_MEMBER_REQUEST":    return .cidGroupChangeMemberRequest
            case "CID_GROUP_CHANGE_MEMBER_RESPONSE":    return .cidGroupChangeMemberResponse
            case "CID_GROUP_SHIELD_GROUP_REQUEST":    return .cidGroupShieldGroupRequest
            case "CID_GROUP_SHIELD_GROUP_RESPONSE":    return .cidGroupShieldGroupResponse
            case "CID_GROUP_CHANGE_MEMBER_NOTIFY":    return .cidGroupChangeMemberNotify
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .cidGroupNormalListRequest: return ".cidGroupNormalListRequest"
            case .cidGroupNormalListResponse: return ".cidGroupNormalListResponse"
            case .cidGroupInfoRequest: return ".cidGroupInfoRequest"
            case .cidGroupInfoResponse: return ".cidGroupInfoResponse"
            case .cidGroupCreateRequest: return ".cidGroupCreateRequest"
            case .cidGroupCreateResponse: return ".cidGroupCreateResponse"
            case .cidGroupChangeMemberRequest: return ".cidGroupChangeMemberRequest"
            case .cidGroupChangeMemberResponse: return ".cidGroupChangeMemberResponse"
            case .cidGroupShieldGroupRequest: return ".cidGroupShieldGroupRequest"
            case .cidGroupShieldGroupResponse: return ".cidGroupShieldGroupResponse"
            case .cidGroupChangeMemberNotify: return ".cidGroupChangeMemberNotify"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:GroupCmdId, rhs:GroupCmdId) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum FileCmdId:Int32, GeneratedEnum {
        ///sender/receiver need to login to
        case cidFileLoginReq = 1281

        ///login success or failure
        case cidFileLoginRes = 1282
        case cidFileState = 1283
        case cidFilePullDataReq = 1284
        case cidFilePullDataRsp = 1285

        /// To MsgServer
        case cidFileRequest = 1286

        ///receiver -> sender
        case cidFileResponse = 1287
        case cidFileNotify = 1288
        case cidFileHasOfflineReq = 1289
        case cidFileHasOfflineRes = 1290
        case cidFileAddOfflineReq = 1291
        case cidFileDelOfflineReq = 1292
        public func toString() -> String {
            switch self {
            case .cidFileLoginReq: return "CID_FILE_LOGIN_REQ"
            case .cidFileLoginRes: return "CID_FILE_LOGIN_RES"
            case .cidFileState: return "CID_FILE_STATE"
            case .cidFilePullDataReq: return "CID_FILE_PULL_DATA_REQ"
            case .cidFilePullDataRsp: return "CID_FILE_PULL_DATA_RSP"
            case .cidFileRequest: return "CID_FILE_REQUEST"
            case .cidFileResponse: return "CID_FILE_RESPONSE"
            case .cidFileNotify: return "CID_FILE_NOTIFY"
            case .cidFileHasOfflineReq: return "CID_FILE_HAS_OFFLINE_REQ"
            case .cidFileHasOfflineRes: return "CID_FILE_HAS_OFFLINE_RES"
            case .cidFileAddOfflineReq: return "CID_FILE_ADD_OFFLINE_REQ"
            case .cidFileDelOfflineReq: return "CID_FILE_DEL_OFFLINE_REQ"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.FileCmdId {
            switch str {
            case "CID_FILE_LOGIN_REQ":    return .cidFileLoginReq
            case "CID_FILE_LOGIN_RES":    return .cidFileLoginRes
            case "CID_FILE_STATE":    return .cidFileState
            case "CID_FILE_PULL_DATA_REQ":    return .cidFilePullDataReq
            case "CID_FILE_PULL_DATA_RSP":    return .cidFilePullDataRsp
            case "CID_FILE_REQUEST":    return .cidFileRequest
            case "CID_FILE_RESPONSE":    return .cidFileResponse
            case "CID_FILE_NOTIFY":    return .cidFileNotify
            case "CID_FILE_HAS_OFFLINE_REQ":    return .cidFileHasOfflineReq
            case "CID_FILE_HAS_OFFLINE_RES":    return .cidFileHasOfflineRes
            case "CID_FILE_ADD_OFFLINE_REQ":    return .cidFileAddOfflineReq
            case "CID_FILE_DEL_OFFLINE_REQ":    return .cidFileDelOfflineReq
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .cidFileLoginReq: return ".cidFileLoginReq"
            case .cidFileLoginRes: return ".cidFileLoginRes"
            case .cidFileState: return ".cidFileState"
            case .cidFilePullDataReq: return ".cidFilePullDataReq"
            case .cidFilePullDataRsp: return ".cidFilePullDataRsp"
            case .cidFileRequest: return ".cidFileRequest"
            case .cidFileResponse: return ".cidFileResponse"
            case .cidFileNotify: return ".cidFileNotify"
            case .cidFileHasOfflineReq: return ".cidFileHasOfflineReq"
            case .cidFileHasOfflineRes: return ".cidFileHasOfflineRes"
            case .cidFileAddOfflineReq: return ".cidFileAddOfflineReq"
            case .cidFileDelOfflineReq: return ".cidFileDelOfflineReq"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:FileCmdId, rhs:FileCmdId) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    /// command id for switch service
    public enum SwitchServiceCmdId:Int32, GeneratedEnum {
        case cidSwitchP2PCmd = 1537
        public func toString() -> String {
            switch self {
            case .cidSwitchP2PCmd: return "CID_SWITCH_P2P_CMD"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.SwitchServiceCmdId {
            switch str {
            case "CID_SWITCH_P2P_CMD":    return .cidSwitchP2PCmd
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .cidSwitchP2PCmd: return ".cidSwitchP2PCmd"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:SwitchServiceCmdId, rhs:SwitchServiceCmdId) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum OtherCmdId:Int32, GeneratedEnum {
        case cidOtherHeartbeat = 1793
        case cidOtherStopRecvPacket = 1794
        case cidOtherValidateReq = 1795
        case cidOtherValidateRsp = 1796
        case cidOtherGetDeviceTokenReq = 1797
        case cidOtherGetDeviceTokenRsp = 1798
        case cidOtherRoleSet = 1799
        case cidOtherOnlineUserInfo = 1800
        case cidOtherMsgServInfo = 1801
        case cidOtherUserStatusUpdate = 1802
        case cidOtherUserCntUpdate = 1803
        case cidOtherServerKickUser = 1805
        case cidOtherLoginStatusNotify = 1806
        case cidOtherPushToUserReq = 1807
        case cidOtherPushToUserRsp = 1808
        case cidOtherGetShieldReq = 1809
        case cidOtherGetShieldRsp = 1810
        case cidOtherFileTransferReq = 1841
        case cidOtherFileTransferRsp = 1842
        case cidOtherFileServerIpReq = 1843
        case cidOtherFileServerIpRsp = 1844
        public func toString() -> String {
            switch self {
            case .cidOtherHeartbeat: return "CID_OTHER_HEARTBEAT"
            case .cidOtherStopRecvPacket: return "CID_OTHER_STOP_RECV_PACKET"
            case .cidOtherValidateReq: return "CID_OTHER_VALIDATE_REQ"
            case .cidOtherValidateRsp: return "CID_OTHER_VALIDATE_RSP"
            case .cidOtherGetDeviceTokenReq: return "CID_OTHER_GET_DEVICE_TOKEN_REQ"
            case .cidOtherGetDeviceTokenRsp: return "CID_OTHER_GET_DEVICE_TOKEN_RSP"
            case .cidOtherRoleSet: return "CID_OTHER_ROLE_SET"
            case .cidOtherOnlineUserInfo: return "CID_OTHER_ONLINE_USER_INFO"
            case .cidOtherMsgServInfo: return "CID_OTHER_MSG_SERV_INFO"
            case .cidOtherUserStatusUpdate: return "CID_OTHER_USER_STATUS_UPDATE"
            case .cidOtherUserCntUpdate: return "CID_OTHER_USER_CNT_UPDATE"
            case .cidOtherServerKickUser: return "CID_OTHER_SERVER_KICK_USER"
            case .cidOtherLoginStatusNotify: return "CID_OTHER_LOGIN_STATUS_NOTIFY"
            case .cidOtherPushToUserReq: return "CID_OTHER_PUSH_TO_USER_REQ"
            case .cidOtherPushToUserRsp: return "CID_OTHER_PUSH_TO_USER_RSP"
            case .cidOtherGetShieldReq: return "CID_OTHER_GET_SHIELD_REQ"
            case .cidOtherGetShieldRsp: return "CID_OTHER_GET_SHIELD_RSP"
            case .cidOtherFileTransferReq: return "CID_OTHER_FILE_TRANSFER_REQ"
            case .cidOtherFileTransferRsp: return "CID_OTHER_FILE_TRANSFER_RSP"
            case .cidOtherFileServerIpReq: return "CID_OTHER_FILE_SERVER_IP_REQ"
            case .cidOtherFileServerIpRsp: return "CID_OTHER_FILE_SERVER_IP_RSP"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.OtherCmdId {
            switch str {
            case "CID_OTHER_HEARTBEAT":    return .cidOtherHeartbeat
            case "CID_OTHER_STOP_RECV_PACKET":    return .cidOtherStopRecvPacket
            case "CID_OTHER_VALIDATE_REQ":    return .cidOtherValidateReq
            case "CID_OTHER_VALIDATE_RSP":    return .cidOtherValidateRsp
            case "CID_OTHER_GET_DEVICE_TOKEN_REQ":    return .cidOtherGetDeviceTokenReq
            case "CID_OTHER_GET_DEVICE_TOKEN_RSP":    return .cidOtherGetDeviceTokenRsp
            case "CID_OTHER_ROLE_SET":    return .cidOtherRoleSet
            case "CID_OTHER_ONLINE_USER_INFO":    return .cidOtherOnlineUserInfo
            case "CID_OTHER_MSG_SERV_INFO":    return .cidOtherMsgServInfo
            case "CID_OTHER_USER_STATUS_UPDATE":    return .cidOtherUserStatusUpdate
            case "CID_OTHER_USER_CNT_UPDATE":    return .cidOtherUserCntUpdate
            case "CID_OTHER_SERVER_KICK_USER":    return .cidOtherServerKickUser
            case "CID_OTHER_LOGIN_STATUS_NOTIFY":    return .cidOtherLoginStatusNotify
            case "CID_OTHER_PUSH_TO_USER_REQ":    return .cidOtherPushToUserReq
            case "CID_OTHER_PUSH_TO_USER_RSP":    return .cidOtherPushToUserRsp
            case "CID_OTHER_GET_SHIELD_REQ":    return .cidOtherGetShieldReq
            case "CID_OTHER_GET_SHIELD_RSP":    return .cidOtherGetShieldRsp
            case "CID_OTHER_FILE_TRANSFER_REQ":    return .cidOtherFileTransferReq
            case "CID_OTHER_FILE_TRANSFER_RSP":    return .cidOtherFileTransferRsp
            case "CID_OTHER_FILE_SERVER_IP_REQ":    return .cidOtherFileServerIpReq
            case "CID_OTHER_FILE_SERVER_IP_RSP":    return .cidOtherFileServerIpRsp
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .cidOtherHeartbeat: return ".cidOtherHeartbeat"
            case .cidOtherStopRecvPacket: return ".cidOtherStopRecvPacket"
            case .cidOtherValidateReq: return ".cidOtherValidateReq"
            case .cidOtherValidateRsp: return ".cidOtherValidateRsp"
            case .cidOtherGetDeviceTokenReq: return ".cidOtherGetDeviceTokenReq"
            case .cidOtherGetDeviceTokenRsp: return ".cidOtherGetDeviceTokenRsp"
            case .cidOtherRoleSet: return ".cidOtherRoleSet"
            case .cidOtherOnlineUserInfo: return ".cidOtherOnlineUserInfo"
            case .cidOtherMsgServInfo: return ".cidOtherMsgServInfo"
            case .cidOtherUserStatusUpdate: return ".cidOtherUserStatusUpdate"
            case .cidOtherUserCntUpdate: return ".cidOtherUserCntUpdate"
            case .cidOtherServerKickUser: return ".cidOtherServerKickUser"
            case .cidOtherLoginStatusNotify: return ".cidOtherLoginStatusNotify"
            case .cidOtherPushToUserReq: return ".cidOtherPushToUserReq"
            case .cidOtherPushToUserRsp: return ".cidOtherPushToUserRsp"
            case .cidOtherGetShieldReq: return ".cidOtherGetShieldReq"
            case .cidOtherGetShieldRsp: return ".cidOtherGetShieldRsp"
            case .cidOtherFileTransferReq: return ".cidOtherFileTransferReq"
            case .cidOtherFileTransferRsp: return ".cidOtherFileTransferRsp"
            case .cidOtherFileServerIpReq: return ".cidOtherFileServerIpReq"
            case .cidOtherFileServerIpRsp: return ".cidOtherFileServerIpRsp"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:OtherCmdId, rhs:OtherCmdId) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum ResultType:Int32, GeneratedEnum {
        case refuseReasonNone = 0
        case refuseReasonNoMsgServer = 1
        case refuseReasonMsgServerFull = 2
        case refuseReasonNoDbServer = 3
        case refuseReasonNoLoginServer = 4
        case refuseReasonNoRouteServer = 5
        case refuseReasonDbValidateFailed = 6
        case refuseReasonVersionTooOld = 7
        public func toString() -> String {
            switch self {
            case .refuseReasonNone: return "REFUSE_REASON_NONE"
            case .refuseReasonNoMsgServer: return "REFUSE_REASON_NO_MSG_SERVER"
            case .refuseReasonMsgServerFull: return "REFUSE_REASON_MSG_SERVER_FULL"
            case .refuseReasonNoDbServer: return "REFUSE_REASON_NO_DB_SERVER"
            case .refuseReasonNoLoginServer: return "REFUSE_REASON_NO_LOGIN_SERVER"
            case .refuseReasonNoRouteServer: return "REFUSE_REASON_NO_ROUTE_SERVER"
            case .refuseReasonDbValidateFailed: return "REFUSE_REASON_DB_VALIDATE_FAILED"
            case .refuseReasonVersionTooOld: return "REFUSE_REASON_VERSION_TOO_OLD"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.ResultType {
            switch str {
            case "REFUSE_REASON_NONE":    return .refuseReasonNone
            case "REFUSE_REASON_NO_MSG_SERVER":    return .refuseReasonNoMsgServer
            case "REFUSE_REASON_MSG_SERVER_FULL":    return .refuseReasonMsgServerFull
            case "REFUSE_REASON_NO_DB_SERVER":    return .refuseReasonNoDbServer
            case "REFUSE_REASON_NO_LOGIN_SERVER":    return .refuseReasonNoLoginServer
            case "REFUSE_REASON_NO_ROUTE_SERVER":    return .refuseReasonNoRouteServer
            case "REFUSE_REASON_DB_VALIDATE_FAILED":    return .refuseReasonDbValidateFailed
            case "REFUSE_REASON_VERSION_TOO_OLD":    return .refuseReasonVersionTooOld
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .refuseReasonNone: return ".refuseReasonNone"
            case .refuseReasonNoMsgServer: return ".refuseReasonNoMsgServer"
            case .refuseReasonMsgServerFull: return ".refuseReasonMsgServerFull"
            case .refuseReasonNoDbServer: return ".refuseReasonNoDbServer"
            case .refuseReasonNoLoginServer: return ".refuseReasonNoLoginServer"
            case .refuseReasonNoRouteServer: return ".refuseReasonNoRouteServer"
            case .refuseReasonDbValidateFailed: return ".refuseReasonDbValidateFailed"
            case .refuseReasonVersionTooOld: return ".refuseReasonVersionTooOld"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:ResultType, rhs:ResultType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum KickReasonType:Int32, GeneratedEnum {
        case kickReasonDuplicateUser = 1
        case kickReasonMobileKick = 2
        public func toString() -> String {
            switch self {
            case .kickReasonDuplicateUser: return "KICK_REASON_DUPLICATE_USER"
            case .kickReasonMobileKick: return "KICK_REASON_MOBILE_KICK"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.KickReasonType {
            switch str {
            case "KICK_REASON_DUPLICATE_USER":    return .kickReasonDuplicateUser
            case "KICK_REASON_MOBILE_KICK":    return .kickReasonMobileKick
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .kickReasonDuplicateUser: return ".kickReasonDuplicateUser"
            case .kickReasonMobileKick: return ".kickReasonMobileKick"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:KickReasonType, rhs:KickReasonType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum OnlineListType:Int32, GeneratedEnum {
        case onlineListTypeFriendList = 1
        public func toString() -> String {
            switch self {
            case .onlineListTypeFriendList: return "ONLINE_LIST_TYPE_FRIEND_LIST"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.OnlineListType {
            switch str {
            case "ONLINE_LIST_TYPE_FRIEND_LIST":    return .onlineListTypeFriendList
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .onlineListTypeFriendList: return ".onlineListTypeFriendList"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:OnlineListType, rhs:OnlineListType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum UserStatType:Int32, GeneratedEnum {
        case userStatusOnline = 1
        case userStatusOffline = 2
        case userStatusLeave = 3
        public func toString() -> String {
            switch self {
            case .userStatusOnline: return "USER_STATUS_ONLINE"
            case .userStatusOffline: return "USER_STATUS_OFFLINE"
            case .userStatusLeave: return "USER_STATUS_LEAVE"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.UserStatType {
            switch str {
            case "USER_STATUS_ONLINE":    return .userStatusOnline
            case "USER_STATUS_OFFLINE":    return .userStatusOffline
            case "USER_STATUS_LEAVE":    return .userStatusLeave
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .userStatusOnline: return ".userStatusOnline"
            case .userStatusOffline: return ".userStatusOffline"
            case .userStatusLeave: return ".userStatusLeave"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:UserStatType, rhs:UserStatType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    @objc public enum SessionType:Int32, GeneratedEnum {
        ///单个用户会话
        case sessionTypeSingle = 1

        ///群会话
        case sessionTypeGroup = 2
        public func toString() -> String {
            switch self {
            case .sessionTypeSingle: return "SESSION_TYPE_SINGLE"
            case .sessionTypeGroup: return "SESSION_TYPE_GROUP"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.SessionType {
            switch str {
            case "SESSION_TYPE_SINGLE":    return .sessionTypeSingle
            case "SESSION_TYPE_GROUP":    return .sessionTypeGroup
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .sessionTypeSingle: return ".sessionTypeSingle"
            case .sessionTypeGroup: return ".sessionTypeGroup"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:SessionType, rhs:SessionType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    @objc public enum MsgType:Int32, GeneratedEnum {
        case msgTypeSingleText = 1
        case msgTypeSingleAudio = 2
        case msgTypeGroupText = 17
        case msgTypeGroupAudio = 18
        public func toString() -> String {
            switch self {
            case .msgTypeSingleText: return "MSG_TYPE_SINGLE_TEXT"
            case .msgTypeSingleAudio: return "MSG_TYPE_SINGLE_AUDIO"
            case .msgTypeGroupText: return "MSG_TYPE_GROUP_TEXT"
            case .msgTypeGroupAudio: return "MSG_TYPE_GROUP_AUDIO"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.MsgType {
            switch str {
            case "MSG_TYPE_SINGLE_TEXT":    return .msgTypeSingleText
            case "MSG_TYPE_SINGLE_AUDIO":    return .msgTypeSingleAudio
            case "MSG_TYPE_GROUP_TEXT":    return .msgTypeGroupText
            case "MSG_TYPE_GROUP_AUDIO":    return .msgTypeGroupAudio
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .msgTypeSingleText: return ".msgTypeSingleText"
            case .msgTypeSingleAudio: return ".msgTypeSingleAudio"
            case .msgTypeGroupText: return ".msgTypeGroupText"
            case .msgTypeGroupAudio: return ".msgTypeGroupAudio"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:MsgType, rhs:MsgType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum ClientType:Int32, GeneratedEnum {
        case clientTypeWindows = 1
        case clientTypeMac = 2
        case clientTypeIos = 17
        case clientTypeAndroid = 18
        public func toString() -> String {
            switch self {
            case .clientTypeWindows: return "CLIENT_TYPE_WINDOWS"
            case .clientTypeMac: return "CLIENT_TYPE_MAC"
            case .clientTypeIos: return "CLIENT_TYPE_IOS"
            case .clientTypeAndroid: return "CLIENT_TYPE_ANDROID"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.ClientType {
            switch str {
            case "CLIENT_TYPE_WINDOWS":    return .clientTypeWindows
            case "CLIENT_TYPE_MAC":    return .clientTypeMac
            case "CLIENT_TYPE_IOS":    return .clientTypeIos
            case "CLIENT_TYPE_ANDROID":    return .clientTypeAndroid
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .clientTypeWindows: return ".clientTypeWindows"
            case .clientTypeMac: return ".clientTypeMac"
            case .clientTypeIos: return ".clientTypeIos"
            case .clientTypeAndroid: return ".clientTypeAndroid"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:ClientType, rhs:ClientType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum GroupType:Int32, GeneratedEnum {
        case groupTypeNormal = 1
        case groupTypeTmp = 2
        public func toString() -> String {
            switch self {
            case .groupTypeNormal: return "GROUP_TYPE_NORMAL"
            case .groupTypeTmp: return "GROUP_TYPE_TMP"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.GroupType {
            switch str {
            case "GROUP_TYPE_NORMAL":    return .groupTypeNormal
            case "GROUP_TYPE_TMP":    return .groupTypeTmp
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .groupTypeNormal: return ".groupTypeNormal"
            case .groupTypeTmp: return ".groupTypeTmp"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:GroupType, rhs:GroupType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum GroupModifyType:Int32, GeneratedEnum {
        case groupModifyTypeAdd = 1
        case groupModifyTypeDel = 2
        public func toString() -> String {
            switch self {
            case .groupModifyTypeAdd: return "GROUP_MODIFY_TYPE_ADD"
            case .groupModifyTypeDel: return "GROUP_MODIFY_TYPE_DEL"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.GroupModifyType {
            switch str {
            case "GROUP_MODIFY_TYPE_ADD":    return .groupModifyTypeAdd
            case "GROUP_MODIFY_TYPE_DEL":    return .groupModifyTypeDel
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .groupModifyTypeAdd: return ".groupModifyTypeAdd"
            case .groupModifyTypeDel: return ".groupModifyTypeDel"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:GroupModifyType, rhs:GroupModifyType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum TransferFileType:Int32, GeneratedEnum {
        case fileTypeOnline = 1
        case fileTypeOffline = 2
        public func toString() -> String {
            switch self {
            case .fileTypeOnline: return "FILE_TYPE_ONLINE"
            case .fileTypeOffline: return "FILE_TYPE_OFFLINE"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.TransferFileType {
            switch str {
            case "FILE_TYPE_ONLINE":    return .fileTypeOnline
            case "FILE_TYPE_OFFLINE":    return .fileTypeOffline
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .fileTypeOnline: return ".fileTypeOnline"
            case .fileTypeOffline: return ".fileTypeOffline"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:TransferFileType, rhs:TransferFileType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum ClientFileState:Int32, GeneratedEnum {
        case clientFilePeerReady = 0
        case clientFileCancel = 1
        case clientFileRefuse = 2
        case clientFileDone = 3
        public func toString() -> String {
            switch self {
            case .clientFilePeerReady: return "CLIENT_FILE_PEER_READY"
            case .clientFileCancel: return "CLIENT_FILE_CANCEL"
            case .clientFileRefuse: return "CLIENT_FILE_REFUSE"
            case .clientFileDone: return "CLIENT_FILE_DONE"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.ClientFileState {
            switch str {
            case "CLIENT_FILE_PEER_READY":    return .clientFilePeerReady
            case "CLIENT_FILE_CANCEL":    return .clientFileCancel
            case "CLIENT_FILE_REFUSE":    return .clientFileRefuse
            case "CLIENT_FILE_DONE":    return .clientFileDone
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .clientFilePeerReady: return ".clientFilePeerReady"
            case .clientFileCancel: return ".clientFileCancel"
            case .clientFileRefuse: return ".clientFileRefuse"
            case .clientFileDone: return ".clientFileDone"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:ClientFileState, rhs:ClientFileState) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum ClientFileRole:Int32, GeneratedEnum {
        case clientRealtimeSender = 1
        case clientRealtimeRecver = 2
        case clientOfflineUpload = 3
        case clientOfflineDownload = 4
        public func toString() -> String {
            switch self {
            case .clientRealtimeSender: return "CLIENT_REALTIME_SENDER"
            case .clientRealtimeRecver: return "CLIENT_REALTIME_RECVER"
            case .clientOfflineUpload: return "CLIENT_OFFLINE_UPLOAD"
            case .clientOfflineDownload: return "CLIENT_OFFLINE_DOWNLOAD"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.ClientFileRole {
            switch str {
            case "CLIENT_REALTIME_SENDER":    return .clientRealtimeSender
            case "CLIENT_REALTIME_RECVER":    return .clientRealtimeRecver
            case "CLIENT_OFFLINE_UPLOAD":    return .clientOfflineUpload
            case "CLIENT_OFFLINE_DOWNLOAD":    return .clientOfflineDownload
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .clientRealtimeSender: return ".clientRealtimeSender"
            case .clientRealtimeRecver: return ".clientRealtimeRecver"
            case .clientOfflineUpload: return ".clientOfflineUpload"
            case .clientOfflineDownload: return ".clientOfflineDownload"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:ClientFileRole, rhs:ClientFileRole) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum FileServerError:Int32, GeneratedEnum {
        case fileServerErrnoOk = 0
        case fileServerErrnoCreateTaskIdError = 1
        case fileServerErrnoCreateTaskError = 2
        case fileServerErrnoLoginInvalidToken = 3
        case fileServerErrnoInvalidUserForTask = 4
        case fileServerErrnoPullDataWithInvalidTaskId = 5
        case fileServerErrnoPullDataIllieageUser = 6
        case fileServerErrnoPullDataMkdirError = 7
        case fileServerErrnoPullDataOpenFileError = 8
        case fileServerErrnoPullDataReadFileHeaderError = 9
        case fileServerErrnoPullDataAllocMemError = 10
        case fileServerErrnoPullDataSeekOffsetError = 11
        case fileServerErrnoPullDataFinished = 12
        public func toString() -> String {
            switch self {
            case .fileServerErrnoOk: return "FILE_SERVER_ERRNO_OK"
            case .fileServerErrnoCreateTaskIdError: return "FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR"
            case .fileServerErrnoCreateTaskError: return "FILE_SERVER_ERRNO_CREATE_TASK_ERROR"
            case .fileServerErrnoLoginInvalidToken: return "FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN"
            case .fileServerErrnoInvalidUserForTask: return "FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK"
            case .fileServerErrnoPullDataWithInvalidTaskId: return "FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID"
            case .fileServerErrnoPullDataIllieageUser: return "FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER"
            case .fileServerErrnoPullDataMkdirError: return "FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR"
            case .fileServerErrnoPullDataOpenFileError: return "FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR"
            case .fileServerErrnoPullDataReadFileHeaderError: return "FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR"
            case .fileServerErrnoPullDataAllocMemError: return "FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR"
            case .fileServerErrnoPullDataSeekOffsetError: return "FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR"
            case .fileServerErrnoPullDataFinished: return "FILE_SERVER_ERRNO_PULL_DATA_FINISHED"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.FileServerError {
            switch str {
            case "FILE_SERVER_ERRNO_OK":    return .fileServerErrnoOk
            case "FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR":    return .fileServerErrnoCreateTaskIdError
            case "FILE_SERVER_ERRNO_CREATE_TASK_ERROR":    return .fileServerErrnoCreateTaskError
            case "FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN":    return .fileServerErrnoLoginInvalidToken
            case "FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK":    return .fileServerErrnoInvalidUserForTask
            case "FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID":    return .fileServerErrnoPullDataWithInvalidTaskId
            case "FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER":    return .fileServerErrnoPullDataIllieageUser
            case "FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR":    return .fileServerErrnoPullDataMkdirError
            case "FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR":    return .fileServerErrnoPullDataOpenFileError
            case "FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR":    return .fileServerErrnoPullDataReadFileHeaderError
            case "FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR":    return .fileServerErrnoPullDataAllocMemError
            case "FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR":    return .fileServerErrnoPullDataSeekOffsetError
            case "FILE_SERVER_ERRNO_PULL_DATA_FINISHED":    return .fileServerErrnoPullDataFinished
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .fileServerErrnoOk: return ".fileServerErrnoOk"
            case .fileServerErrnoCreateTaskIdError: return ".fileServerErrnoCreateTaskIdError"
            case .fileServerErrnoCreateTaskError: return ".fileServerErrnoCreateTaskError"
            case .fileServerErrnoLoginInvalidToken: return ".fileServerErrnoLoginInvalidToken"
            case .fileServerErrnoInvalidUserForTask: return ".fileServerErrnoInvalidUserForTask"
            case .fileServerErrnoPullDataWithInvalidTaskId: return ".fileServerErrnoPullDataWithInvalidTaskId"
            case .fileServerErrnoPullDataIllieageUser: return ".fileServerErrnoPullDataIllieageUser"
            case .fileServerErrnoPullDataMkdirError: return ".fileServerErrnoPullDataMkdirError"
            case .fileServerErrnoPullDataOpenFileError: return ".fileServerErrnoPullDataOpenFileError"
            case .fileServerErrnoPullDataReadFileHeaderError: return ".fileServerErrnoPullDataReadFileHeaderError"
            case .fileServerErrnoPullDataAllocMemError: return ".fileServerErrnoPullDataAllocMemError"
            case .fileServerErrnoPullDataSeekOffsetError: return ".fileServerErrnoPullDataSeekOffsetError"
            case .fileServerErrnoPullDataFinished: return ".fileServerErrnoPullDataFinished"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:FileServerError, rhs:FileServerError) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum SessionStatusType:Int32, GeneratedEnum {
        case sessionStatusOk = 0
        case sessionStatusDelete = 1
        public func toString() -> String {
            switch self {
            case .sessionStatusOk: return "SESSION_STATUS_OK"
            case .sessionStatusDelete: return "SESSION_STATUS_DELETE"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.SessionStatusType {
            switch str {
            case "SESSION_STATUS_OK":    return .sessionStatusOk
            case "SESSION_STATUS_DELETE":    return .sessionStatusDelete
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .sessionStatusOk: return ".sessionStatusOk"
            case .sessionStatusDelete: return ".sessionStatusDelete"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:SessionStatusType, rhs:SessionStatusType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 



    //Enum type declaration start 

    public enum DepartmentStatusType:Int32, GeneratedEnum {
        case deptStatusOk = 0
        case deptStatusDelete = 1
        public func toString() -> String {
            switch self {
            case .deptStatusOk: return "DEPT_STATUS_OK"
            case .deptStatusDelete: return "DEPT_STATUS_DELETE"
            }
        }
        public static func fromString(_ str:String) throws -> Im.BaseDefine.DepartmentStatusType {
            switch str {
            case "DEPT_STATUS_OK":    return .deptStatusOk
            case "DEPT_STATUS_DELETE":    return .deptStatusDelete
            default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
            }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
            case .deptStatusOk: return ".deptStatusOk"
            case .deptStatusDelete: return ".deptStatusDelete"
            }
        }
        public var hashValue:Int {
            return self.rawValue.hashValue
        }
        public static func ==(lhs:DepartmentStatusType, rhs:DepartmentStatusType) -> Bool {
            return lhs.hashValue == rhs.hashValue
        }
    }

    //Enum type declaration end 

    final public class IpAddr : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.IpAddr.Builder

        public static func == (lhs: Im.BaseDefine.IpAddr, rhs: Im.BaseDefine.IpAddr) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasIp == rhs.hasIp) && (!lhs.hasIp || lhs.ip == rhs.ip)
            fieldCheck = fieldCheck && (lhs.hasPort == rhs.hasPort) && (!lhs.hasPort || lhs.port == rhs.port)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var ip:String! = nil
        public fileprivate(set) var hasIp:Bool = false

        public fileprivate(set) var port:UInt32! = nil
        public fileprivate(set) var hasPort:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasIp {
                return false
            }
            if !hasPort {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasIp {
                try codedOutputStream.writeString(fieldNumber: 1, value:ip)
            }
            if hasPort {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:port)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasIp {
                serialize_size += ip.computeStringSize(fieldNumber: 1)
            }
            if hasPort {
                serialize_size += port.computeUInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.IpAddr.Builder {
            return Im.BaseDefine.IpAddr.classBuilder() as! Im.BaseDefine.IpAddr.Builder
        }
        public func getBuilder() -> Im.BaseDefine.IpAddr.Builder {
            return classBuilder() as! Im.BaseDefine.IpAddr.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.IpAddr.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.IpAddr.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.IpAddr.Builder {
            return try Im.BaseDefine.IpAddr.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.IpAddr) throws -> Im.BaseDefine.IpAddr.Builder {
            return try Im.BaseDefine.IpAddr.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasIp {
                jsonMap["ip"] = ip
            }
            if hasPort {
                jsonMap["port"] = UInt(port)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.IpAddr {
            return try Im.BaseDefine.IpAddr.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.IpAddr {
            return try Im.BaseDefine.IpAddr.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasIp {
                output += "\(indent) ip: \(ip) \n"
            }
            if hasPort {
                output += "\(indent) port: \(port) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasIp {
                    hashCode = (hashCode &* 31) &+ ip.hashValue
                }
                if hasPort {
                    hashCode = (hashCode &* 31) &+ port.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.IpAddr"
        }
        override public func className() -> String {
            return "Im.BaseDefine.IpAddr"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.IpAddr = Im.BaseDefine.IpAddr()
            public func getMessage() -> Im.BaseDefine.IpAddr {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var ip:String {
                get {
                    return builderResult.ip
                }
                set (value) {
                    builderResult.hasIp = true
                    builderResult.ip = value
                }
            }
            public var hasIp:Bool {
                get {
                    return builderResult.hasIp
                }
            }
            @discardableResult
            public func setIp(_ value:String) -> Im.BaseDefine.IpAddr.Builder {
                self.ip = value
                return self
            }
            @discardableResult
            public func clearIp() -> Im.BaseDefine.IpAddr.Builder{
                builderResult.hasIp = false
                builderResult.ip = nil
                return self
            }
            public var port:UInt32 {
                get {
                    return builderResult.port
                }
                set (value) {
                    builderResult.hasPort = true
                    builderResult.port = value
                }
            }
            public var hasPort:Bool {
                get {
                    return builderResult.hasPort
                }
            }
            @discardableResult
            public func setPort(_ value:UInt32) -> Im.BaseDefine.IpAddr.Builder {
                self.port = value
                return self
            }
            @discardableResult
            public func clearPort() -> Im.BaseDefine.IpAddr.Builder{
                builderResult.hasPort = false
                builderResult.port = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.IpAddr.Builder {
                builderResult = Im.BaseDefine.IpAddr()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.IpAddr.Builder {
                return try Im.BaseDefine.IpAddr.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.IpAddr {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.IpAddr {
                let returnMe:Im.BaseDefine.IpAddr = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.IpAddr) throws -> Im.BaseDefine.IpAddr.Builder {
                if other == Im.BaseDefine.IpAddr() {
                    return self
                }
                if other.hasIp {
                    ip = other.ip
                }
                if other.hasPort {
                    port = other.port
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.IpAddr.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.IpAddr.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        ip = try codedInputStream.readString()

                    case 16:
                        port = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.IpAddr.Builder {
                let resultDecodedBuilder = Im.BaseDefine.IpAddr.Builder()
                if let jsonValueIp = jsonMap["ip"] as? String {
                    resultDecodedBuilder.ip = jsonValueIp
                }
                if let jsonValuePort = jsonMap["port"] as? UInt {
                    resultDecodedBuilder.port = UInt32(jsonValuePort)
                } else if let jsonValuePort = jsonMap["port"] as? String {
                    resultDecodedBuilder.port = UInt32(jsonValuePort)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.IpAddr.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.IpAddr.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UserInfo : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.UserInfo.Builder

        public static func == (lhs: Im.BaseDefine.UserInfo, rhs: Im.BaseDefine.UserInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasUserGender == rhs.hasUserGender) && (!lhs.hasUserGender || lhs.userGender == rhs.userGender)
            fieldCheck = fieldCheck && (lhs.hasUserNickName == rhs.hasUserNickName) && (!lhs.hasUserNickName || lhs.userNickName == rhs.userNickName)
            fieldCheck = fieldCheck && (lhs.hasAvatarUrl == rhs.hasAvatarUrl) && (!lhs.hasAvatarUrl || lhs.avatarUrl == rhs.avatarUrl)
            fieldCheck = fieldCheck && (lhs.hasDepartmentId == rhs.hasDepartmentId) && (!lhs.hasDepartmentId || lhs.departmentId == rhs.departmentId)
            fieldCheck = fieldCheck && (lhs.hasEmail == rhs.hasEmail) && (!lhs.hasEmail || lhs.email == rhs.email)
            fieldCheck = fieldCheck && (lhs.hasUserRealName == rhs.hasUserRealName) && (!lhs.hasUserRealName || lhs.userRealName == rhs.userRealName)
            fieldCheck = fieldCheck && (lhs.hasUserTel == rhs.hasUserTel) && (!lhs.hasUserTel || lhs.userTel == rhs.userTel)
            fieldCheck = fieldCheck && (lhs.hasUserDomain == rhs.hasUserDomain) && (!lhs.hasUserDomain || lhs.userDomain == rhs.userDomain)
            fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
            fieldCheck = fieldCheck && (lhs.hasSignInfo == rhs.hasSignInfo) && (!lhs.hasSignInfo || lhs.signInfo == rhs.signInfo)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        ///用户性别,男：1 女：2 人妖/外星人：0
        public fileprivate(set) var userGender:UInt32! = nil
        public fileprivate(set) var hasUserGender:Bool = false

        ///绰号
        public fileprivate(set) var userNickName:String! = nil
        public fileprivate(set) var hasUserNickName:Bool = false

        public fileprivate(set) var avatarUrl:String! = nil
        public fileprivate(set) var hasAvatarUrl:Bool = false

        public fileprivate(set) var departmentId:UInt32! = nil
        public fileprivate(set) var hasDepartmentId:Bool = false

        public fileprivate(set) var email:String! = nil
        public fileprivate(set) var hasEmail:Bool = false

        ///真名
        public fileprivate(set) var userRealName:String! = nil
        public fileprivate(set) var hasUserRealName:Bool = false

        public fileprivate(set) var userTel:String! = nil
        public fileprivate(set) var hasUserTel:Bool = false

        ///用户名拼音
        public fileprivate(set) var userDomain:String! = nil
        public fileprivate(set) var hasUserDomain:Bool = false

        ///0:在职  1. 试用期 2. 正式 3. 离职 4.实习,  client端需要对“离职”进行不展示
        public fileprivate(set) var status:UInt32! = nil
        public fileprivate(set) var hasStatus:Bool = false

        public fileprivate(set) var signInfo:String! = nil
        public fileprivate(set) var hasSignInfo:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasUserGender {
                return false
            }
            if !hasUserNickName {
                return false
            }
            if !hasAvatarUrl {
                return false
            }
            if !hasDepartmentId {
                return false
            }
            if !hasEmail {
                return false
            }
            if !hasUserRealName {
                return false
            }
            if !hasUserTel {
                return false
            }
            if !hasUserDomain {
                return false
            }
            if !hasStatus {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasUserGender {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:userGender)
            }
            if hasUserNickName {
                try codedOutputStream.writeString(fieldNumber: 3, value:userNickName)
            }
            if hasAvatarUrl {
                try codedOutputStream.writeString(fieldNumber: 4, value:avatarUrl)
            }
            if hasDepartmentId {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:departmentId)
            }
            if hasEmail {
                try codedOutputStream.writeString(fieldNumber: 6, value:email)
            }
            if hasUserRealName {
                try codedOutputStream.writeString(fieldNumber: 7, value:userRealName)
            }
            if hasUserTel {
                try codedOutputStream.writeString(fieldNumber: 8, value:userTel)
            }
            if hasUserDomain {
                try codedOutputStream.writeString(fieldNumber: 9, value:userDomain)
            }
            if hasStatus {
                try codedOutputStream.writeUInt32(fieldNumber: 10, value:status)
            }
            if hasSignInfo {
                try codedOutputStream.writeString(fieldNumber: 11, value:signInfo)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasUserGender {
                serialize_size += userGender.computeUInt32Size(fieldNumber: 2)
            }
            if hasUserNickName {
                serialize_size += userNickName.computeStringSize(fieldNumber: 3)
            }
            if hasAvatarUrl {
                serialize_size += avatarUrl.computeStringSize(fieldNumber: 4)
            }
            if hasDepartmentId {
                serialize_size += departmentId.computeUInt32Size(fieldNumber: 5)
            }
            if hasEmail {
                serialize_size += email.computeStringSize(fieldNumber: 6)
            }
            if hasUserRealName {
                serialize_size += userRealName.computeStringSize(fieldNumber: 7)
            }
            if hasUserTel {
                serialize_size += userTel.computeStringSize(fieldNumber: 8)
            }
            if hasUserDomain {
                serialize_size += userDomain.computeStringSize(fieldNumber: 9)
            }
            if hasStatus {
                serialize_size += status.computeUInt32Size(fieldNumber: 10)
            }
            if hasSignInfo {
                serialize_size += signInfo.computeStringSize(fieldNumber: 11)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.UserInfo.Builder {
            return Im.BaseDefine.UserInfo.classBuilder() as! Im.BaseDefine.UserInfo.Builder
        }
        public func getBuilder() -> Im.BaseDefine.UserInfo.Builder {
            return classBuilder() as! Im.BaseDefine.UserInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.UserInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.UserInfo.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.UserInfo.Builder {
            return try Im.BaseDefine.UserInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.UserInfo) throws -> Im.BaseDefine.UserInfo.Builder {
            return try Im.BaseDefine.UserInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasUserGender {
                jsonMap["userGender"] = UInt(userGender)
            }
            if hasUserNickName {
                jsonMap["userNickName"] = userNickName
            }
            if hasAvatarUrl {
                jsonMap["avatarUrl"] = avatarUrl
            }
            if hasDepartmentId {
                jsonMap["departmentId"] = UInt(departmentId)
            }
            if hasEmail {
                jsonMap["email"] = email
            }
            if hasUserRealName {
                jsonMap["userRealName"] = userRealName
            }
            if hasUserTel {
                jsonMap["userTel"] = userTel
            }
            if hasUserDomain {
                jsonMap["userDomain"] = userDomain
            }
            if hasStatus {
                jsonMap["status"] = UInt(status)
            }
            if hasSignInfo {
                jsonMap["signInfo"] = signInfo
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.UserInfo {
            return try Im.BaseDefine.UserInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.UserInfo {
            return try Im.BaseDefine.UserInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasUserGender {
                output += "\(indent) userGender: \(userGender) \n"
            }
            if hasUserNickName {
                output += "\(indent) userNickName: \(userNickName) \n"
            }
            if hasAvatarUrl {
                output += "\(indent) avatarUrl: \(avatarUrl) \n"
            }
            if hasDepartmentId {
                output += "\(indent) departmentId: \(departmentId) \n"
            }
            if hasEmail {
                output += "\(indent) email: \(email) \n"
            }
            if hasUserRealName {
                output += "\(indent) userRealName: \(userRealName) \n"
            }
            if hasUserTel {
                output += "\(indent) userTel: \(userTel) \n"
            }
            if hasUserDomain {
                output += "\(indent) userDomain: \(userDomain) \n"
            }
            if hasStatus {
                output += "\(indent) status: \(status) \n"
            }
            if hasSignInfo {
                output += "\(indent) signInfo: \(signInfo) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasUserGender {
                    hashCode = (hashCode &* 31) &+ userGender.hashValue
                }
                if hasUserNickName {
                    hashCode = (hashCode &* 31) &+ userNickName.hashValue
                }
                if hasAvatarUrl {
                    hashCode = (hashCode &* 31) &+ avatarUrl.hashValue
                }
                if hasDepartmentId {
                    hashCode = (hashCode &* 31) &+ departmentId.hashValue
                }
                if hasEmail {
                    hashCode = (hashCode &* 31) &+ email.hashValue
                }
                if hasUserRealName {
                    hashCode = (hashCode &* 31) &+ userRealName.hashValue
                }
                if hasUserTel {
                    hashCode = (hashCode &* 31) &+ userTel.hashValue
                }
                if hasUserDomain {
                    hashCode = (hashCode &* 31) &+ userDomain.hashValue
                }
                if hasStatus {
                    hashCode = (hashCode &* 31) &+ status.hashValue
                }
                if hasSignInfo {
                    hashCode = (hashCode &* 31) &+ signInfo.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.UserInfo"
        }
        override public func className() -> String {
            return "Im.BaseDefine.UserInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.UserInfo = Im.BaseDefine.UserInfo()
            public func getMessage() -> Im.BaseDefine.UserInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.BaseDefine.UserInfo.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.BaseDefine.UserInfo.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            ///用户性别,男：1 女：2 人妖/外星人：0
            public var userGender:UInt32 {
                get {
                    return builderResult.userGender
                }
                set (value) {
                    builderResult.hasUserGender = true
                    builderResult.userGender = value
                }
            }
            public var hasUserGender:Bool {
                get {
                    return builderResult.hasUserGender
                }
            }
            @discardableResult
            public func setUserGender(_ value:UInt32) -> Im.BaseDefine.UserInfo.Builder {
                self.userGender = value
                return self
            }
            @discardableResult
            public func clearUserGender() -> Im.BaseDefine.UserInfo.Builder{
                builderResult.hasUserGender = false
                builderResult.userGender = nil
                return self
            }
            ///绰号
            public var userNickName:String {
                get {
                    return builderResult.userNickName
                }
                set (value) {
                    builderResult.hasUserNickName = true
                    builderResult.userNickName = value
                }
            }
            public var hasUserNickName:Bool {
                get {
                    return builderResult.hasUserNickName
                }
            }
            @discardableResult
            public func setUserNickName(_ value:String) -> Im.BaseDefine.UserInfo.Builder {
                self.userNickName = value
                return self
            }
            @discardableResult
            public func clearUserNickName() -> Im.BaseDefine.UserInfo.Builder{
                builderResult.hasUserNickName = false
                builderResult.userNickName = nil
                return self
            }
            public var avatarUrl:String {
                get {
                    return builderResult.avatarUrl
                }
                set (value) {
                    builderResult.hasAvatarUrl = true
                    builderResult.avatarUrl = value
                }
            }
            public var hasAvatarUrl:Bool {
                get {
                    return builderResult.hasAvatarUrl
                }
            }
            @discardableResult
            public func setAvatarUrl(_ value:String) -> Im.BaseDefine.UserInfo.Builder {
                self.avatarUrl = value
                return self
            }
            @discardableResult
            public func clearAvatarUrl() -> Im.BaseDefine.UserInfo.Builder{
                builderResult.hasAvatarUrl = false
                builderResult.avatarUrl = nil
                return self
            }
            public var departmentId:UInt32 {
                get {
                    return builderResult.departmentId
                }
                set (value) {
                    builderResult.hasDepartmentId = true
                    builderResult.departmentId = value
                }
            }
            public var hasDepartmentId:Bool {
                get {
                    return builderResult.hasDepartmentId
                }
            }
            @discardableResult
            public func setDepartmentId(_ value:UInt32) -> Im.BaseDefine.UserInfo.Builder {
                self.departmentId = value
                return self
            }
            @discardableResult
            public func clearDepartmentId() -> Im.BaseDefine.UserInfo.Builder{
                builderResult.hasDepartmentId = false
                builderResult.departmentId = nil
                return self
            }
            public var email:String {
                get {
                    return builderResult.email
                }
                set (value) {
                    builderResult.hasEmail = true
                    builderResult.email = value
                }
            }
            public var hasEmail:Bool {
                get {
                    return builderResult.hasEmail
                }
            }
            @discardableResult
            public func setEmail(_ value:String) -> Im.BaseDefine.UserInfo.Builder {
                self.email = value
                return self
            }
            @discardableResult
            public func clearEmail() -> Im.BaseDefine.UserInfo.Builder{
                builderResult.hasEmail = false
                builderResult.email = nil
                return self
            }
            ///真名
            public var userRealName:String {
                get {
                    return builderResult.userRealName
                }
                set (value) {
                    builderResult.hasUserRealName = true
                    builderResult.userRealName = value
                }
            }
            public var hasUserRealName:Bool {
                get {
                    return builderResult.hasUserRealName
                }
            }
            @discardableResult
            public func setUserRealName(_ value:String) -> Im.BaseDefine.UserInfo.Builder {
                self.userRealName = value
                return self
            }
            @discardableResult
            public func clearUserRealName() -> Im.BaseDefine.UserInfo.Builder{
                builderResult.hasUserRealName = false
                builderResult.userRealName = nil
                return self
            }
            public var userTel:String {
                get {
                    return builderResult.userTel
                }
                set (value) {
                    builderResult.hasUserTel = true
                    builderResult.userTel = value
                }
            }
            public var hasUserTel:Bool {
                get {
                    return builderResult.hasUserTel
                }
            }
            @discardableResult
            public func setUserTel(_ value:String) -> Im.BaseDefine.UserInfo.Builder {
                self.userTel = value
                return self
            }
            @discardableResult
            public func clearUserTel() -> Im.BaseDefine.UserInfo.Builder{
                builderResult.hasUserTel = false
                builderResult.userTel = nil
                return self
            }
            ///用户名拼音
            public var userDomain:String {
                get {
                    return builderResult.userDomain
                }
                set (value) {
                    builderResult.hasUserDomain = true
                    builderResult.userDomain = value
                }
            }
            public var hasUserDomain:Bool {
                get {
                    return builderResult.hasUserDomain
                }
            }
            @discardableResult
            public func setUserDomain(_ value:String) -> Im.BaseDefine.UserInfo.Builder {
                self.userDomain = value
                return self
            }
            @discardableResult
            public func clearUserDomain() -> Im.BaseDefine.UserInfo.Builder{
                builderResult.hasUserDomain = false
                builderResult.userDomain = nil
                return self
            }
            ///0:在职  1. 试用期 2. 正式 3. 离职 4.实习,  client端需要对“离职”进行不展示
            public var status:UInt32 {
                get {
                    return builderResult.status
                }
                set (value) {
                    builderResult.hasStatus = true
                    builderResult.status = value
                }
            }
            public var hasStatus:Bool {
                get {
                    return builderResult.hasStatus
                }
            }
            @discardableResult
            public func setStatus(_ value:UInt32) -> Im.BaseDefine.UserInfo.Builder {
                self.status = value
                return self
            }
            @discardableResult
            public func clearStatus() -> Im.BaseDefine.UserInfo.Builder{
                builderResult.hasStatus = false
                builderResult.status = nil
                return self
            }
            public var signInfo:String {
                get {
                    return builderResult.signInfo
                }
                set (value) {
                    builderResult.hasSignInfo = true
                    builderResult.signInfo = value
                }
            }
            public var hasSignInfo:Bool {
                get {
                    return builderResult.hasSignInfo
                }
            }
            @discardableResult
            public func setSignInfo(_ value:String) -> Im.BaseDefine.UserInfo.Builder {
                self.signInfo = value
                return self
            }
            @discardableResult
            public func clearSignInfo() -> Im.BaseDefine.UserInfo.Builder{
                builderResult.hasSignInfo = false
                builderResult.signInfo = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.UserInfo.Builder {
                builderResult = Im.BaseDefine.UserInfo()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.UserInfo.Builder {
                return try Im.BaseDefine.UserInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.UserInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.UserInfo {
                let returnMe:Im.BaseDefine.UserInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.UserInfo) throws -> Im.BaseDefine.UserInfo.Builder {
                if other == Im.BaseDefine.UserInfo() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasUserGender {
                    userGender = other.userGender
                }
                if other.hasUserNickName {
                    userNickName = other.userNickName
                }
                if other.hasAvatarUrl {
                    avatarUrl = other.avatarUrl
                }
                if other.hasDepartmentId {
                    departmentId = other.departmentId
                }
                if other.hasEmail {
                    email = other.email
                }
                if other.hasUserRealName {
                    userRealName = other.userRealName
                }
                if other.hasUserTel {
                    userTel = other.userTel
                }
                if other.hasUserDomain {
                    userDomain = other.userDomain
                }
                if other.hasStatus {
                    status = other.status
                }
                if other.hasSignInfo {
                    signInfo = other.signInfo
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.UserInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UserInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        userGender = try codedInputStream.readUInt32()

                    case 26:
                        userNickName = try codedInputStream.readString()

                    case 34:
                        avatarUrl = try codedInputStream.readString()

                    case 40:
                        departmentId = try codedInputStream.readUInt32()

                    case 50:
                        email = try codedInputStream.readString()

                    case 58:
                        userRealName = try codedInputStream.readString()

                    case 66:
                        userTel = try codedInputStream.readString()

                    case 74:
                        userDomain = try codedInputStream.readString()

                    case 80:
                        status = try codedInputStream.readUInt32()

                    case 90:
                        signInfo = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.UserInfo.Builder {
                let resultDecodedBuilder = Im.BaseDefine.UserInfo.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueUserGender = jsonMap["userGender"] as? UInt {
                    resultDecodedBuilder.userGender = UInt32(jsonValueUserGender)
                } else if let jsonValueUserGender = jsonMap["userGender"] as? String {
                    resultDecodedBuilder.userGender = UInt32(jsonValueUserGender)!
                }
                if let jsonValueUserNickName = jsonMap["userNickName"] as? String {
                    resultDecodedBuilder.userNickName = jsonValueUserNickName
                }
                if let jsonValueAvatarUrl = jsonMap["avatarUrl"] as? String {
                    resultDecodedBuilder.avatarUrl = jsonValueAvatarUrl
                }
                if let jsonValueDepartmentId = jsonMap["departmentId"] as? UInt {
                    resultDecodedBuilder.departmentId = UInt32(jsonValueDepartmentId)
                } else if let jsonValueDepartmentId = jsonMap["departmentId"] as? String {
                    resultDecodedBuilder.departmentId = UInt32(jsonValueDepartmentId)!
                }
                if let jsonValueEmail = jsonMap["email"] as? String {
                    resultDecodedBuilder.email = jsonValueEmail
                }
                if let jsonValueUserRealName = jsonMap["userRealName"] as? String {
                    resultDecodedBuilder.userRealName = jsonValueUserRealName
                }
                if let jsonValueUserTel = jsonMap["userTel"] as? String {
                    resultDecodedBuilder.userTel = jsonValueUserTel
                }
                if let jsonValueUserDomain = jsonMap["userDomain"] as? String {
                    resultDecodedBuilder.userDomain = jsonValueUserDomain
                }
                if let jsonValueStatus = jsonMap["status"] as? UInt {
                    resultDecodedBuilder.status = UInt32(jsonValueStatus)
                } else if let jsonValueStatus = jsonMap["status"] as? String {
                    resultDecodedBuilder.status = UInt32(jsonValueStatus)!
                }
                if let jsonValueSignInfo = jsonMap["signInfo"] as? String {
                    resultDecodedBuilder.signInfo = jsonValueSignInfo
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.UserInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.UserInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ContactSessionInfo : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.ContactSessionInfo.Builder

        public static func == (lhs: Im.BaseDefine.ContactSessionInfo, rhs: Im.BaseDefine.ContactSessionInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = fieldCheck && (lhs.hasSessionStatus == rhs.hasSessionStatus) && (!lhs.hasSessionStatus || lhs.sessionStatus == rhs.sessionStatus)
            fieldCheck = fieldCheck && (lhs.hasUpdatedTime == rhs.hasUpdatedTime) && (!lhs.hasUpdatedTime || lhs.updatedTime == rhs.updatedTime)
            fieldCheck = fieldCheck && (lhs.hasLatestMsgId == rhs.hasLatestMsgId) && (!lhs.hasLatestMsgId || lhs.latestMsgId == rhs.latestMsgId)
            fieldCheck = fieldCheck && (lhs.hasLatestMsgData == rhs.hasLatestMsgData) && (!lhs.hasLatestMsgData || lhs.latestMsgData == rhs.latestMsgData)
            fieldCheck = fieldCheck && (lhs.hasLatestMsgType == rhs.hasLatestMsgType) && (!lhs.hasLatestMsgType || lhs.latestMsgType == rhs.latestMsgType)
            fieldCheck = fieldCheck && (lhs.hasLatestMsgFromUserId == rhs.hasLatestMsgFromUserId) && (!lhs.hasLatestMsgFromUserId || lhs.latestMsgFromUserId == rhs.latestMsgFromUserId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        public fileprivate(set) var sessionStatus:Im.BaseDefine.SessionStatusType = Im.BaseDefine.SessionStatusType.sessionStatusOk
        public fileprivate(set) var hasSessionStatus:Bool = false
        public fileprivate(set) var updatedTime:UInt32! = nil
        public fileprivate(set) var hasUpdatedTime:Bool = false

        public fileprivate(set) var latestMsgId:UInt32! = nil
        public fileprivate(set) var hasLatestMsgId:Bool = false

        public fileprivate(set) var latestMsgData:Data! = nil
        public fileprivate(set) var hasLatestMsgData:Bool = false

        public fileprivate(set) var latestMsgType:Im.BaseDefine.MsgType = Im.BaseDefine.MsgType.msgTypeSingleText
        public fileprivate(set) var hasLatestMsgType:Bool = false
        public fileprivate(set) var latestMsgFromUserId:UInt32! = nil
        public fileprivate(set) var hasLatestMsgFromUserId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasSessionId {
                return false
            }
            if !hasSessionType {
                return false
            }
            if !hasSessionStatus {
                return false
            }
            if !hasUpdatedTime {
                return false
            }
            if !hasLatestMsgId {
                return false
            }
            if !hasLatestMsgData {
                return false
            }
            if !hasLatestMsgType {
                return false
            }
            if !hasLatestMsgFromUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:sessionId)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:sessionType.rawValue)
            }
            if hasSessionStatus {
                try codedOutputStream.writeEnum(fieldNumber: 3, value:sessionStatus.rawValue)
            }
            if hasUpdatedTime {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:updatedTime)
            }
            if hasLatestMsgId {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:latestMsgId)
            }
            if hasLatestMsgData {
                try codedOutputStream.writeData(fieldNumber: 6, value:latestMsgData)
            }
            if hasLatestMsgType {
                try codedOutputStream.writeEnum(fieldNumber: 7, value:latestMsgType.rawValue)
            }
            if hasLatestMsgFromUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 8, value:latestMsgFromUserId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if (hasSessionStatus) {
                serialize_size += sessionStatus.rawValue.computeEnumSize(fieldNumber: 3)
            }
            if hasUpdatedTime {
                serialize_size += updatedTime.computeUInt32Size(fieldNumber: 4)
            }
            if hasLatestMsgId {
                serialize_size += latestMsgId.computeUInt32Size(fieldNumber: 5)
            }
            if hasLatestMsgData {
                serialize_size += latestMsgData.computeDataSize(fieldNumber: 6)
            }
            if (hasLatestMsgType) {
                serialize_size += latestMsgType.rawValue.computeEnumSize(fieldNumber: 7)
            }
            if hasLatestMsgFromUserId {
                serialize_size += latestMsgFromUserId.computeUInt32Size(fieldNumber: 8)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.ContactSessionInfo.Builder {
            return Im.BaseDefine.ContactSessionInfo.classBuilder() as! Im.BaseDefine.ContactSessionInfo.Builder
        }
        public func getBuilder() -> Im.BaseDefine.ContactSessionInfo.Builder {
            return classBuilder() as! Im.BaseDefine.ContactSessionInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.ContactSessionInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.ContactSessionInfo.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.ContactSessionInfo.Builder {
            return try Im.BaseDefine.ContactSessionInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.ContactSessionInfo) throws -> Im.BaseDefine.ContactSessionInfo.Builder {
            return try Im.BaseDefine.ContactSessionInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            if hasSessionStatus {
                jsonMap["sessionStatus"] = sessionStatus.toString()
            }
            if hasUpdatedTime {
                jsonMap["updatedTime"] = UInt(updatedTime)
            }
            if hasLatestMsgId {
                jsonMap["latestMsgId"] = UInt(latestMsgId)
            }
            if hasLatestMsgData {
                jsonMap["latestMsgData"] = latestMsgData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasLatestMsgType {
                jsonMap["latestMsgType"] = latestMsgType.toString()
            }
            if hasLatestMsgFromUserId {
                jsonMap["latestMsgFromUserId"] = UInt(latestMsgFromUserId)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.ContactSessionInfo {
            return try Im.BaseDefine.ContactSessionInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.ContactSessionInfo {
            return try Im.BaseDefine.ContactSessionInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            if (hasSessionStatus) {
                output += "\(indent) sessionStatus: \(sessionStatus.description)\n"
            }
            if hasUpdatedTime {
                output += "\(indent) updatedTime: \(updatedTime) \n"
            }
            if hasLatestMsgId {
                output += "\(indent) latestMsgId: \(latestMsgId) \n"
            }
            if hasLatestMsgData {
                output += "\(indent) latestMsgData: \(latestMsgData) \n"
            }
            if (hasLatestMsgType) {
                output += "\(indent) latestMsgType: \(latestMsgType.description)\n"
            }
            if hasLatestMsgFromUserId {
                output += "\(indent) latestMsgFromUserId: \(latestMsgFromUserId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                if hasSessionStatus {
                     hashCode = (hashCode &* 31) &+ sessionStatus.hashValue
                }
                if hasUpdatedTime {
                    hashCode = (hashCode &* 31) &+ updatedTime.hashValue
                }
                if hasLatestMsgId {
                    hashCode = (hashCode &* 31) &+ latestMsgId.hashValue
                }
                if hasLatestMsgData {
                    hashCode = (hashCode &* 31) &+ latestMsgData.hashValue
                }
                if hasLatestMsgType {
                     hashCode = (hashCode &* 31) &+ latestMsgType.hashValue
                }
                if hasLatestMsgFromUserId {
                    hashCode = (hashCode &* 31) &+ latestMsgFromUserId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.ContactSessionInfo"
        }
        override public func className() -> String {
            return "Im.BaseDefine.ContactSessionInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.ContactSessionInfo = Im.BaseDefine.ContactSessionInfo()
            public func getMessage() -> Im.BaseDefine.ContactSessionInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.BaseDefine.ContactSessionInfo.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.BaseDefine.ContactSessionInfo.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.BaseDefine.ContactSessionInfo.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.BaseDefine.ContactSessionInfo.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
                public var sessionStatus:Im.BaseDefine.SessionStatusType {
                    get {
                        return builderResult.sessionStatus
                    }
                    set (value) {
                        builderResult.hasSessionStatus = true
                        builderResult.sessionStatus = value
                    }
                }
                public var hasSessionStatus:Bool{
                    get {
                        return builderResult.hasSessionStatus
                    }
                }
            @discardableResult
                public func setSessionStatus(_ value:Im.BaseDefine.SessionStatusType) -> Im.BaseDefine.ContactSessionInfo.Builder {
                  self.sessionStatus = value
                  return self
                }
            @discardableResult
                public func clearSessionStatus() -> Im.BaseDefine.ContactSessionInfo.Builder {
                   builderResult.hasSessionStatus = false
                   builderResult.sessionStatus = .sessionStatusOk
                   return self
                }
            public var updatedTime:UInt32 {
                get {
                    return builderResult.updatedTime
                }
                set (value) {
                    builderResult.hasUpdatedTime = true
                    builderResult.updatedTime = value
                }
            }
            public var hasUpdatedTime:Bool {
                get {
                    return builderResult.hasUpdatedTime
                }
            }
            @discardableResult
            public func setUpdatedTime(_ value:UInt32) -> Im.BaseDefine.ContactSessionInfo.Builder {
                self.updatedTime = value
                return self
            }
            @discardableResult
            public func clearUpdatedTime() -> Im.BaseDefine.ContactSessionInfo.Builder{
                builderResult.hasUpdatedTime = false
                builderResult.updatedTime = nil
                return self
            }
            public var latestMsgId:UInt32 {
                get {
                    return builderResult.latestMsgId
                }
                set (value) {
                    builderResult.hasLatestMsgId = true
                    builderResult.latestMsgId = value
                }
            }
            public var hasLatestMsgId:Bool {
                get {
                    return builderResult.hasLatestMsgId
                }
            }
            @discardableResult
            public func setLatestMsgId(_ value:UInt32) -> Im.BaseDefine.ContactSessionInfo.Builder {
                self.latestMsgId = value
                return self
            }
            @discardableResult
            public func clearLatestMsgId() -> Im.BaseDefine.ContactSessionInfo.Builder{
                builderResult.hasLatestMsgId = false
                builderResult.latestMsgId = nil
                return self
            }
            public var latestMsgData:Data {
                get {
                    return builderResult.latestMsgData
                }
                set (value) {
                    builderResult.hasLatestMsgData = true
                    builderResult.latestMsgData = value
                }
            }
            public var hasLatestMsgData:Bool {
                get {
                    return builderResult.hasLatestMsgData
                }
            }
            @discardableResult
            public func setLatestMsgData(_ value:Data) -> Im.BaseDefine.ContactSessionInfo.Builder {
                self.latestMsgData = value
                return self
            }
            @discardableResult
            public func clearLatestMsgData() -> Im.BaseDefine.ContactSessionInfo.Builder{
                builderResult.hasLatestMsgData = false
                builderResult.latestMsgData = nil
                return self
            }
                public var latestMsgType:Im.BaseDefine.MsgType {
                    get {
                        return builderResult.latestMsgType
                    }
                    set (value) {
                        builderResult.hasLatestMsgType = true
                        builderResult.latestMsgType = value
                    }
                }
                public var hasLatestMsgType:Bool{
                    get {
                        return builderResult.hasLatestMsgType
                    }
                }
            @discardableResult
                public func setLatestMsgType(_ value:Im.BaseDefine.MsgType) -> Im.BaseDefine.ContactSessionInfo.Builder {
                  self.latestMsgType = value
                  return self
                }
            @discardableResult
                public func clearLatestMsgType() -> Im.BaseDefine.ContactSessionInfo.Builder {
                   builderResult.hasLatestMsgType = false
                   builderResult.latestMsgType = .msgTypeSingleText
                   return self
                }
            public var latestMsgFromUserId:UInt32 {
                get {
                    return builderResult.latestMsgFromUserId
                }
                set (value) {
                    builderResult.hasLatestMsgFromUserId = true
                    builderResult.latestMsgFromUserId = value
                }
            }
            public var hasLatestMsgFromUserId:Bool {
                get {
                    return builderResult.hasLatestMsgFromUserId
                }
            }
            @discardableResult
            public func setLatestMsgFromUserId(_ value:UInt32) -> Im.BaseDefine.ContactSessionInfo.Builder {
                self.latestMsgFromUserId = value
                return self
            }
            @discardableResult
            public func clearLatestMsgFromUserId() -> Im.BaseDefine.ContactSessionInfo.Builder{
                builderResult.hasLatestMsgFromUserId = false
                builderResult.latestMsgFromUserId = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.ContactSessionInfo.Builder {
                builderResult = Im.BaseDefine.ContactSessionInfo()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.ContactSessionInfo.Builder {
                return try Im.BaseDefine.ContactSessionInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.ContactSessionInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.ContactSessionInfo {
                let returnMe:Im.BaseDefine.ContactSessionInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.ContactSessionInfo) throws -> Im.BaseDefine.ContactSessionInfo.Builder {
                if other == Im.BaseDefine.ContactSessionInfo() {
                    return self
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                if other.hasSessionStatus {
                    sessionStatus = other.sessionStatus
                }
                if other.hasUpdatedTime {
                    updatedTime = other.updatedTime
                }
                if other.hasLatestMsgId {
                    latestMsgId = other.latestMsgId
                }
                if other.hasLatestMsgData {
                    latestMsgData = other.latestMsgData
                }
                if other.hasLatestMsgType {
                    latestMsgType = other.latestMsgType
                }
                if other.hasLatestMsgFromUserId {
                    latestMsgFromUserId = other.latestMsgFromUserId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.ContactSessionInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.ContactSessionInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        sessionId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntsessionType))
                        }

                    case 24:
                        let valueIntsessionStatus = try codedInputStream.readEnum()
                        if let enumssessionStatus = Im.BaseDefine.SessionStatusType(rawValue:valueIntsessionStatus){
                            sessionStatus = enumssessionStatus
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntsessionStatus))
                        }

                    case 32:
                        updatedTime = try codedInputStream.readUInt32()

                    case 40:
                        latestMsgId = try codedInputStream.readUInt32()

                    case 50:
                        latestMsgData = try codedInputStream.readData()

                    case 56:
                        let valueIntlatestMsgType = try codedInputStream.readEnum()
                        if let enumslatestMsgType = Im.BaseDefine.MsgType(rawValue:valueIntlatestMsgType){
                            latestMsgType = enumslatestMsgType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 7, value:Int64(valueIntlatestMsgType))
                        }

                    case 64:
                        latestMsgFromUserId = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.ContactSessionInfo.Builder {
                let resultDecodedBuilder = Im.BaseDefine.ContactSessionInfo.Builder()
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                if let jsonValueSessionStatus = jsonMap["sessionStatus"] as? String {
                    resultDecodedBuilder.sessionStatus = try Im.BaseDefine.SessionStatusType.fromString(jsonValueSessionStatus)
                }
                if let jsonValueUpdatedTime = jsonMap["updatedTime"] as? UInt {
                    resultDecodedBuilder.updatedTime = UInt32(jsonValueUpdatedTime)
                } else if let jsonValueUpdatedTime = jsonMap["updatedTime"] as? String {
                    resultDecodedBuilder.updatedTime = UInt32(jsonValueUpdatedTime)!
                }
                if let jsonValueLatestMsgId = jsonMap["latestMsgId"] as? UInt {
                    resultDecodedBuilder.latestMsgId = UInt32(jsonValueLatestMsgId)
                } else if let jsonValueLatestMsgId = jsonMap["latestMsgId"] as? String {
                    resultDecodedBuilder.latestMsgId = UInt32(jsonValueLatestMsgId)!
                }
                if let jsonValueLatestMsgData = jsonMap["latestMsgData"] as? String {
                    resultDecodedBuilder.latestMsgData = Data(base64Encoded:jsonValueLatestMsgData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueLatestMsgType = jsonMap["latestMsgType"] as? String {
                    resultDecodedBuilder.latestMsgType = try Im.BaseDefine.MsgType.fromString(jsonValueLatestMsgType)
                }
                if let jsonValueLatestMsgFromUserId = jsonMap["latestMsgFromUserId"] as? UInt {
                    resultDecodedBuilder.latestMsgFromUserId = UInt32(jsonValueLatestMsgFromUserId)
                } else if let jsonValueLatestMsgFromUserId = jsonMap["latestMsgFromUserId"] as? String {
                    resultDecodedBuilder.latestMsgFromUserId = UInt32(jsonValueLatestMsgFromUserId)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.ContactSessionInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.ContactSessionInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UserStat : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.UserStat.Builder

        public static func == (lhs: Im.BaseDefine.UserStat, rhs: Im.BaseDefine.UserStat) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var status:Im.BaseDefine.UserStatType = Im.BaseDefine.UserStatType.userStatusOnline
        public fileprivate(set) var hasStatus:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasStatus {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasStatus {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:status.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasStatus) {
                serialize_size += status.rawValue.computeEnumSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.UserStat.Builder {
            return Im.BaseDefine.UserStat.classBuilder() as! Im.BaseDefine.UserStat.Builder
        }
        public func getBuilder() -> Im.BaseDefine.UserStat.Builder {
            return classBuilder() as! Im.BaseDefine.UserStat.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.UserStat.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.UserStat.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.UserStat.Builder {
            return try Im.BaseDefine.UserStat.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.UserStat) throws -> Im.BaseDefine.UserStat.Builder {
            return try Im.BaseDefine.UserStat.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasStatus {
                jsonMap["status"] = status.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.UserStat {
            return try Im.BaseDefine.UserStat.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.UserStat {
            return try Im.BaseDefine.UserStat.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasStatus) {
                output += "\(indent) status: \(status.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasStatus {
                     hashCode = (hashCode &* 31) &+ status.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.UserStat"
        }
        override public func className() -> String {
            return "Im.BaseDefine.UserStat"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.UserStat = Im.BaseDefine.UserStat()
            public func getMessage() -> Im.BaseDefine.UserStat {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.BaseDefine.UserStat.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.BaseDefine.UserStat.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var status:Im.BaseDefine.UserStatType {
                    get {
                        return builderResult.status
                    }
                    set (value) {
                        builderResult.hasStatus = true
                        builderResult.status = value
                    }
                }
                public var hasStatus:Bool{
                    get {
                        return builderResult.hasStatus
                    }
                }
            @discardableResult
                public func setStatus(_ value:Im.BaseDefine.UserStatType) -> Im.BaseDefine.UserStat.Builder {
                  self.status = value
                  return self
                }
            @discardableResult
                public func clearStatus() -> Im.BaseDefine.UserStat.Builder {
                   builderResult.hasStatus = false
                   builderResult.status = .userStatusOnline
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.UserStat.Builder {
                builderResult = Im.BaseDefine.UserStat()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.UserStat.Builder {
                return try Im.BaseDefine.UserStat.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.UserStat {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.UserStat {
                let returnMe:Im.BaseDefine.UserStat = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.UserStat) throws -> Im.BaseDefine.UserStat.Builder {
                if other == Im.BaseDefine.UserStat() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasStatus {
                    status = other.status
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.UserStat.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UserStat.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntstatus = try codedInputStream.readEnum()
                        if let enumsstatus = Im.BaseDefine.UserStatType(rawValue:valueIntstatus){
                            status = enumsstatus
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntstatus))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.UserStat.Builder {
                let resultDecodedBuilder = Im.BaseDefine.UserStat.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueStatus = jsonMap["status"] as? String {
                    resultDecodedBuilder.status = try Im.BaseDefine.UserStatType.fromString(jsonValueStatus)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.UserStat.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.UserStat.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ServerUserStat : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.ServerUserStat.Builder

        public static func == (lhs: Im.BaseDefine.ServerUserStat, rhs: Im.BaseDefine.ServerUserStat) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
            fieldCheck = fieldCheck && (lhs.hasClientType == rhs.hasClientType) && (!lhs.hasClientType || lhs.clientType == rhs.clientType)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var status:Im.BaseDefine.UserStatType = Im.BaseDefine.UserStatType.userStatusOnline
        public fileprivate(set) var hasStatus:Bool = false
        public fileprivate(set) var clientType:Im.BaseDefine.ClientType = Im.BaseDefine.ClientType.clientTypeWindows
        public fileprivate(set) var hasClientType:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasStatus {
                return false
            }
            if !hasClientType {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasStatus {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:status.rawValue)
            }
            if hasClientType {
                try codedOutputStream.writeEnum(fieldNumber: 3, value:clientType.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasStatus) {
                serialize_size += status.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if (hasClientType) {
                serialize_size += clientType.rawValue.computeEnumSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.ServerUserStat.Builder {
            return Im.BaseDefine.ServerUserStat.classBuilder() as! Im.BaseDefine.ServerUserStat.Builder
        }
        public func getBuilder() -> Im.BaseDefine.ServerUserStat.Builder {
            return classBuilder() as! Im.BaseDefine.ServerUserStat.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.ServerUserStat.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.ServerUserStat.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.ServerUserStat.Builder {
            return try Im.BaseDefine.ServerUserStat.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.ServerUserStat) throws -> Im.BaseDefine.ServerUserStat.Builder {
            return try Im.BaseDefine.ServerUserStat.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasStatus {
                jsonMap["status"] = status.toString()
            }
            if hasClientType {
                jsonMap["clientType"] = clientType.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.ServerUserStat {
            return try Im.BaseDefine.ServerUserStat.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.ServerUserStat {
            return try Im.BaseDefine.ServerUserStat.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasStatus) {
                output += "\(indent) status: \(status.description)\n"
            }
            if (hasClientType) {
                output += "\(indent) clientType: \(clientType.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasStatus {
                     hashCode = (hashCode &* 31) &+ status.hashValue
                }
                if hasClientType {
                     hashCode = (hashCode &* 31) &+ clientType.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.ServerUserStat"
        }
        override public func className() -> String {
            return "Im.BaseDefine.ServerUserStat"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.ServerUserStat = Im.BaseDefine.ServerUserStat()
            public func getMessage() -> Im.BaseDefine.ServerUserStat {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.BaseDefine.ServerUserStat.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.BaseDefine.ServerUserStat.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var status:Im.BaseDefine.UserStatType {
                    get {
                        return builderResult.status
                    }
                    set (value) {
                        builderResult.hasStatus = true
                        builderResult.status = value
                    }
                }
                public var hasStatus:Bool{
                    get {
                        return builderResult.hasStatus
                    }
                }
            @discardableResult
                public func setStatus(_ value:Im.BaseDefine.UserStatType) -> Im.BaseDefine.ServerUserStat.Builder {
                  self.status = value
                  return self
                }
            @discardableResult
                public func clearStatus() -> Im.BaseDefine.ServerUserStat.Builder {
                   builderResult.hasStatus = false
                   builderResult.status = .userStatusOnline
                   return self
                }
                public var clientType:Im.BaseDefine.ClientType {
                    get {
                        return builderResult.clientType
                    }
                    set (value) {
                        builderResult.hasClientType = true
                        builderResult.clientType = value
                    }
                }
                public var hasClientType:Bool{
                    get {
                        return builderResult.hasClientType
                    }
                }
            @discardableResult
                public func setClientType(_ value:Im.BaseDefine.ClientType) -> Im.BaseDefine.ServerUserStat.Builder {
                  self.clientType = value
                  return self
                }
            @discardableResult
                public func clearClientType() -> Im.BaseDefine.ServerUserStat.Builder {
                   builderResult.hasClientType = false
                   builderResult.clientType = .clientTypeWindows
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.ServerUserStat.Builder {
                builderResult = Im.BaseDefine.ServerUserStat()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.ServerUserStat.Builder {
                return try Im.BaseDefine.ServerUserStat.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.ServerUserStat {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.ServerUserStat {
                let returnMe:Im.BaseDefine.ServerUserStat = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.ServerUserStat) throws -> Im.BaseDefine.ServerUserStat.Builder {
                if other == Im.BaseDefine.ServerUserStat() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasStatus {
                    status = other.status
                }
                if other.hasClientType {
                    clientType = other.clientType
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.ServerUserStat.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.ServerUserStat.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntstatus = try codedInputStream.readEnum()
                        if let enumsstatus = Im.BaseDefine.UserStatType(rawValue:valueIntstatus){
                            status = enumsstatus
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntstatus))
                        }

                    case 24:
                        let valueIntclientType = try codedInputStream.readEnum()
                        if let enumsclientType = Im.BaseDefine.ClientType(rawValue:valueIntclientType){
                            clientType = enumsclientType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntclientType))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.ServerUserStat.Builder {
                let resultDecodedBuilder = Im.BaseDefine.ServerUserStat.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueStatus = jsonMap["status"] as? String {
                    resultDecodedBuilder.status = try Im.BaseDefine.UserStatType.fromString(jsonValueStatus)
                }
                if let jsonValueClientType = jsonMap["clientType"] as? String {
                    resultDecodedBuilder.clientType = try Im.BaseDefine.ClientType.fromString(jsonValueClientType)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.ServerUserStat.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.ServerUserStat.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UnreadInfo : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.UnreadInfo.Builder

        public static func == (lhs: Im.BaseDefine.UnreadInfo, rhs: Im.BaseDefine.UnreadInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
            fieldCheck = fieldCheck && (lhs.hasSessionType == rhs.hasSessionType) && (!lhs.hasSessionType || lhs.sessionType == rhs.sessionType)
            fieldCheck = fieldCheck && (lhs.hasUnreadCnt == rhs.hasUnreadCnt) && (!lhs.hasUnreadCnt || lhs.unreadCnt == rhs.unreadCnt)
            fieldCheck = fieldCheck && (lhs.hasLatestMsgId == rhs.hasLatestMsgId) && (!lhs.hasLatestMsgId || lhs.latestMsgId == rhs.latestMsgId)
            fieldCheck = fieldCheck && (lhs.hasLatestMsgData == rhs.hasLatestMsgData) && (!lhs.hasLatestMsgData || lhs.latestMsgData == rhs.latestMsgData)
            fieldCheck = fieldCheck && (lhs.hasLatestMsgType == rhs.hasLatestMsgType) && (!lhs.hasLatestMsgType || lhs.latestMsgType == rhs.latestMsgType)
            fieldCheck = fieldCheck && (lhs.hasLatestMsgFromUserId == rhs.hasLatestMsgFromUserId) && (!lhs.hasLatestMsgFromUserId || lhs.latestMsgFromUserId == rhs.latestMsgFromUserId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var sessionId:UInt32! = nil
        public fileprivate(set) var hasSessionId:Bool = false

        public fileprivate(set) var sessionType:Im.BaseDefine.SessionType = Im.BaseDefine.SessionType.sessionTypeSingle
        public fileprivate(set) var hasSessionType:Bool = false
        public fileprivate(set) var unreadCnt:UInt32! = nil
        public fileprivate(set) var hasUnreadCnt:Bool = false

        public fileprivate(set) var latestMsgId:UInt32! = nil
        public fileprivate(set) var hasLatestMsgId:Bool = false

        public fileprivate(set) var latestMsgData:Data! = nil
        public fileprivate(set) var hasLatestMsgData:Bool = false

        public fileprivate(set) var latestMsgType:Im.BaseDefine.MsgType = Im.BaseDefine.MsgType.msgTypeSingleText
        public fileprivate(set) var hasLatestMsgType:Bool = false
        ///发送得用户id
        public fileprivate(set) var latestMsgFromUserId:UInt32! = nil
        public fileprivate(set) var hasLatestMsgFromUserId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasSessionId {
                return false
            }
            if !hasSessionType {
                return false
            }
            if !hasUnreadCnt {
                return false
            }
            if !hasLatestMsgId {
                return false
            }
            if !hasLatestMsgData {
                return false
            }
            if !hasLatestMsgType {
                return false
            }
            if !hasLatestMsgFromUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:sessionId)
            }
            if hasSessionType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:sessionType.rawValue)
            }
            if hasUnreadCnt {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:unreadCnt)
            }
            if hasLatestMsgId {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:latestMsgId)
            }
            if hasLatestMsgData {
                try codedOutputStream.writeData(fieldNumber: 5, value:latestMsgData)
            }
            if hasLatestMsgType {
                try codedOutputStream.writeEnum(fieldNumber: 6, value:latestMsgType.rawValue)
            }
            if hasLatestMsgFromUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 7, value:latestMsgFromUserId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasSessionId {
                serialize_size += sessionId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasSessionType) {
                serialize_size += sessionType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasUnreadCnt {
                serialize_size += unreadCnt.computeUInt32Size(fieldNumber: 3)
            }
            if hasLatestMsgId {
                serialize_size += latestMsgId.computeUInt32Size(fieldNumber: 4)
            }
            if hasLatestMsgData {
                serialize_size += latestMsgData.computeDataSize(fieldNumber: 5)
            }
            if (hasLatestMsgType) {
                serialize_size += latestMsgType.rawValue.computeEnumSize(fieldNumber: 6)
            }
            if hasLatestMsgFromUserId {
                serialize_size += latestMsgFromUserId.computeUInt32Size(fieldNumber: 7)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.UnreadInfo.Builder {
            return Im.BaseDefine.UnreadInfo.classBuilder() as! Im.BaseDefine.UnreadInfo.Builder
        }
        public func getBuilder() -> Im.BaseDefine.UnreadInfo.Builder {
            return classBuilder() as! Im.BaseDefine.UnreadInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.UnreadInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.UnreadInfo.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.UnreadInfo.Builder {
            return try Im.BaseDefine.UnreadInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.UnreadInfo) throws -> Im.BaseDefine.UnreadInfo.Builder {
            return try Im.BaseDefine.UnreadInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasSessionId {
                jsonMap["sessionId"] = UInt(sessionId)
            }
            if hasSessionType {
                jsonMap["sessionType"] = sessionType.toString()
            }
            if hasUnreadCnt {
                jsonMap["unreadCnt"] = UInt(unreadCnt)
            }
            if hasLatestMsgId {
                jsonMap["latestMsgId"] = UInt(latestMsgId)
            }
            if hasLatestMsgData {
                jsonMap["latestMsgData"] = latestMsgData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            if hasLatestMsgType {
                jsonMap["latestMsgType"] = latestMsgType.toString()
            }
            if hasLatestMsgFromUserId {
                jsonMap["latestMsgFromUserId"] = UInt(latestMsgFromUserId)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.UnreadInfo {
            return try Im.BaseDefine.UnreadInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.UnreadInfo {
            return try Im.BaseDefine.UnreadInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasSessionId {
                output += "\(indent) sessionId: \(sessionId) \n"
            }
            if (hasSessionType) {
                output += "\(indent) sessionType: \(sessionType.description)\n"
            }
            if hasUnreadCnt {
                output += "\(indent) unreadCnt: \(unreadCnt) \n"
            }
            if hasLatestMsgId {
                output += "\(indent) latestMsgId: \(latestMsgId) \n"
            }
            if hasLatestMsgData {
                output += "\(indent) latestMsgData: \(latestMsgData) \n"
            }
            if (hasLatestMsgType) {
                output += "\(indent) latestMsgType: \(latestMsgType.description)\n"
            }
            if hasLatestMsgFromUserId {
                output += "\(indent) latestMsgFromUserId: \(latestMsgFromUserId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasSessionId {
                    hashCode = (hashCode &* 31) &+ sessionId.hashValue
                }
                if hasSessionType {
                     hashCode = (hashCode &* 31) &+ sessionType.hashValue
                }
                if hasUnreadCnt {
                    hashCode = (hashCode &* 31) &+ unreadCnt.hashValue
                }
                if hasLatestMsgId {
                    hashCode = (hashCode &* 31) &+ latestMsgId.hashValue
                }
                if hasLatestMsgData {
                    hashCode = (hashCode &* 31) &+ latestMsgData.hashValue
                }
                if hasLatestMsgType {
                     hashCode = (hashCode &* 31) &+ latestMsgType.hashValue
                }
                if hasLatestMsgFromUserId {
                    hashCode = (hashCode &* 31) &+ latestMsgFromUserId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.UnreadInfo"
        }
        override public func className() -> String {
            return "Im.BaseDefine.UnreadInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.UnreadInfo = Im.BaseDefine.UnreadInfo()
            public func getMessage() -> Im.BaseDefine.UnreadInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var sessionId:UInt32 {
                get {
                    return builderResult.sessionId
                }
                set (value) {
                    builderResult.hasSessionId = true
                    builderResult.sessionId = value
                }
            }
            public var hasSessionId:Bool {
                get {
                    return builderResult.hasSessionId
                }
            }
            @discardableResult
            public func setSessionId(_ value:UInt32) -> Im.BaseDefine.UnreadInfo.Builder {
                self.sessionId = value
                return self
            }
            @discardableResult
            public func clearSessionId() -> Im.BaseDefine.UnreadInfo.Builder{
                builderResult.hasSessionId = false
                builderResult.sessionId = nil
                return self
            }
                public var sessionType:Im.BaseDefine.SessionType {
                    get {
                        return builderResult.sessionType
                    }
                    set (value) {
                        builderResult.hasSessionType = true
                        builderResult.sessionType = value
                    }
                }
                public var hasSessionType:Bool{
                    get {
                        return builderResult.hasSessionType
                    }
                }
            @discardableResult
                public func setSessionType(_ value:Im.BaseDefine.SessionType) -> Im.BaseDefine.UnreadInfo.Builder {
                  self.sessionType = value
                  return self
                }
            @discardableResult
                public func clearSessionType() -> Im.BaseDefine.UnreadInfo.Builder {
                   builderResult.hasSessionType = false
                   builderResult.sessionType = .sessionTypeSingle
                   return self
                }
            public var unreadCnt:UInt32 {
                get {
                    return builderResult.unreadCnt
                }
                set (value) {
                    builderResult.hasUnreadCnt = true
                    builderResult.unreadCnt = value
                }
            }
            public var hasUnreadCnt:Bool {
                get {
                    return builderResult.hasUnreadCnt
                }
            }
            @discardableResult
            public func setUnreadCnt(_ value:UInt32) -> Im.BaseDefine.UnreadInfo.Builder {
                self.unreadCnt = value
                return self
            }
            @discardableResult
            public func clearUnreadCnt() -> Im.BaseDefine.UnreadInfo.Builder{
                builderResult.hasUnreadCnt = false
                builderResult.unreadCnt = nil
                return self
            }
            public var latestMsgId:UInt32 {
                get {
                    return builderResult.latestMsgId
                }
                set (value) {
                    builderResult.hasLatestMsgId = true
                    builderResult.latestMsgId = value
                }
            }
            public var hasLatestMsgId:Bool {
                get {
                    return builderResult.hasLatestMsgId
                }
            }
            @discardableResult
            public func setLatestMsgId(_ value:UInt32) -> Im.BaseDefine.UnreadInfo.Builder {
                self.latestMsgId = value
                return self
            }
            @discardableResult
            public func clearLatestMsgId() -> Im.BaseDefine.UnreadInfo.Builder{
                builderResult.hasLatestMsgId = false
                builderResult.latestMsgId = nil
                return self
            }
            public var latestMsgData:Data {
                get {
                    return builderResult.latestMsgData
                }
                set (value) {
                    builderResult.hasLatestMsgData = true
                    builderResult.latestMsgData = value
                }
            }
            public var hasLatestMsgData:Bool {
                get {
                    return builderResult.hasLatestMsgData
                }
            }
            @discardableResult
            public func setLatestMsgData(_ value:Data) -> Im.BaseDefine.UnreadInfo.Builder {
                self.latestMsgData = value
                return self
            }
            @discardableResult
            public func clearLatestMsgData() -> Im.BaseDefine.UnreadInfo.Builder{
                builderResult.hasLatestMsgData = false
                builderResult.latestMsgData = nil
                return self
            }
                public var latestMsgType:Im.BaseDefine.MsgType {
                    get {
                        return builderResult.latestMsgType
                    }
                    set (value) {
                        builderResult.hasLatestMsgType = true
                        builderResult.latestMsgType = value
                    }
                }
                public var hasLatestMsgType:Bool{
                    get {
                        return builderResult.hasLatestMsgType
                    }
                }
            @discardableResult
                public func setLatestMsgType(_ value:Im.BaseDefine.MsgType) -> Im.BaseDefine.UnreadInfo.Builder {
                  self.latestMsgType = value
                  return self
                }
            @discardableResult
                public func clearLatestMsgType() -> Im.BaseDefine.UnreadInfo.Builder {
                   builderResult.hasLatestMsgType = false
                   builderResult.latestMsgType = .msgTypeSingleText
                   return self
                }
            ///发送得用户id
            public var latestMsgFromUserId:UInt32 {
                get {
                    return builderResult.latestMsgFromUserId
                }
                set (value) {
                    builderResult.hasLatestMsgFromUserId = true
                    builderResult.latestMsgFromUserId = value
                }
            }
            public var hasLatestMsgFromUserId:Bool {
                get {
                    return builderResult.hasLatestMsgFromUserId
                }
            }
            @discardableResult
            public func setLatestMsgFromUserId(_ value:UInt32) -> Im.BaseDefine.UnreadInfo.Builder {
                self.latestMsgFromUserId = value
                return self
            }
            @discardableResult
            public func clearLatestMsgFromUserId() -> Im.BaseDefine.UnreadInfo.Builder{
                builderResult.hasLatestMsgFromUserId = false
                builderResult.latestMsgFromUserId = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.UnreadInfo.Builder {
                builderResult = Im.BaseDefine.UnreadInfo()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.UnreadInfo.Builder {
                return try Im.BaseDefine.UnreadInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.UnreadInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.UnreadInfo {
                let returnMe:Im.BaseDefine.UnreadInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.UnreadInfo) throws -> Im.BaseDefine.UnreadInfo.Builder {
                if other == Im.BaseDefine.UnreadInfo() {
                    return self
                }
                if other.hasSessionId {
                    sessionId = other.sessionId
                }
                if other.hasSessionType {
                    sessionType = other.sessionType
                }
                if other.hasUnreadCnt {
                    unreadCnt = other.unreadCnt
                }
                if other.hasLatestMsgId {
                    latestMsgId = other.latestMsgId
                }
                if other.hasLatestMsgData {
                    latestMsgData = other.latestMsgData
                }
                if other.hasLatestMsgType {
                    latestMsgType = other.latestMsgType
                }
                if other.hasLatestMsgFromUserId {
                    latestMsgFromUserId = other.latestMsgFromUserId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.UnreadInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UnreadInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        sessionId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntsessionType = try codedInputStream.readEnum()
                        if let enumssessionType = Im.BaseDefine.SessionType(rawValue:valueIntsessionType){
                            sessionType = enumssessionType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntsessionType))
                        }

                    case 24:
                        unreadCnt = try codedInputStream.readUInt32()

                    case 32:
                        latestMsgId = try codedInputStream.readUInt32()

                    case 42:
                        latestMsgData = try codedInputStream.readData()

                    case 48:
                        let valueIntlatestMsgType = try codedInputStream.readEnum()
                        if let enumslatestMsgType = Im.BaseDefine.MsgType(rawValue:valueIntlatestMsgType){
                            latestMsgType = enumslatestMsgType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 6, value:Int64(valueIntlatestMsgType))
                        }

                    case 56:
                        latestMsgFromUserId = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.UnreadInfo.Builder {
                let resultDecodedBuilder = Im.BaseDefine.UnreadInfo.Builder()
                if let jsonValueSessionId = jsonMap["sessionId"] as? UInt {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)
                } else if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                    resultDecodedBuilder.sessionId = UInt32(jsonValueSessionId)!
                }
                if let jsonValueSessionType = jsonMap["sessionType"] as? String {
                    resultDecodedBuilder.sessionType = try Im.BaseDefine.SessionType.fromString(jsonValueSessionType)
                }
                if let jsonValueUnreadCnt = jsonMap["unreadCnt"] as? UInt {
                    resultDecodedBuilder.unreadCnt = UInt32(jsonValueUnreadCnt)
                } else if let jsonValueUnreadCnt = jsonMap["unreadCnt"] as? String {
                    resultDecodedBuilder.unreadCnt = UInt32(jsonValueUnreadCnt)!
                }
                if let jsonValueLatestMsgId = jsonMap["latestMsgId"] as? UInt {
                    resultDecodedBuilder.latestMsgId = UInt32(jsonValueLatestMsgId)
                } else if let jsonValueLatestMsgId = jsonMap["latestMsgId"] as? String {
                    resultDecodedBuilder.latestMsgId = UInt32(jsonValueLatestMsgId)!
                }
                if let jsonValueLatestMsgData = jsonMap["latestMsgData"] as? String {
                    resultDecodedBuilder.latestMsgData = Data(base64Encoded:jsonValueLatestMsgData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                if let jsonValueLatestMsgType = jsonMap["latestMsgType"] as? String {
                    resultDecodedBuilder.latestMsgType = try Im.BaseDefine.MsgType.fromString(jsonValueLatestMsgType)
                }
                if let jsonValueLatestMsgFromUserId = jsonMap["latestMsgFromUserId"] as? UInt {
                    resultDecodedBuilder.latestMsgFromUserId = UInt32(jsonValueLatestMsgFromUserId)
                } else if let jsonValueLatestMsgFromUserId = jsonMap["latestMsgFromUserId"] as? String {
                    resultDecodedBuilder.latestMsgFromUserId = UInt32(jsonValueLatestMsgFromUserId)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.UnreadInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.UnreadInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class MsgInfo : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.MsgInfo.Builder

        public static func == (lhs: Im.BaseDefine.MsgInfo, rhs: Im.BaseDefine.MsgInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasMsgId == rhs.hasMsgId) && (!lhs.hasMsgId || lhs.msgId == rhs.msgId)
            fieldCheck = fieldCheck && (lhs.hasFromSessionId == rhs.hasFromSessionId) && (!lhs.hasFromSessionId || lhs.fromSessionId == rhs.fromSessionId)
            fieldCheck = fieldCheck && (lhs.hasCreateTime == rhs.hasCreateTime) && (!lhs.hasCreateTime || lhs.createTime == rhs.createTime)
            fieldCheck = fieldCheck && (lhs.hasMsgType == rhs.hasMsgType) && (!lhs.hasMsgType || lhs.msgType == rhs.msgType)
            fieldCheck = fieldCheck && (lhs.hasMsgData == rhs.hasMsgData) && (!lhs.hasMsgData || lhs.msgData == rhs.msgData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var msgId:UInt32! = nil
        public fileprivate(set) var hasMsgId:Bool = false

        ///发送的用户id
        public fileprivate(set) var fromSessionId:UInt32! = nil
        public fileprivate(set) var hasFromSessionId:Bool = false

        public fileprivate(set) var createTime:UInt32! = nil
        public fileprivate(set) var hasCreateTime:Bool = false

        public fileprivate(set) var msgType:Im.BaseDefine.MsgType = Im.BaseDefine.MsgType.msgTypeSingleText
        public fileprivate(set) var hasMsgType:Bool = false
        public fileprivate(set) var msgData:Data! = nil
        public fileprivate(set) var hasMsgData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasMsgId {
                return false
            }
            if !hasFromSessionId {
                return false
            }
            if !hasCreateTime {
                return false
            }
            if !hasMsgType {
                return false
            }
            if !hasMsgData {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasMsgId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:msgId)
            }
            if hasFromSessionId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:fromSessionId)
            }
            if hasCreateTime {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:createTime)
            }
            if hasMsgType {
                try codedOutputStream.writeEnum(fieldNumber: 4, value:msgType.rawValue)
            }
            if hasMsgData {
                try codedOutputStream.writeData(fieldNumber: 5, value:msgData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasMsgId {
                serialize_size += msgId.computeUInt32Size(fieldNumber: 1)
            }
            if hasFromSessionId {
                serialize_size += fromSessionId.computeUInt32Size(fieldNumber: 2)
            }
            if hasCreateTime {
                serialize_size += createTime.computeUInt32Size(fieldNumber: 3)
            }
            if (hasMsgType) {
                serialize_size += msgType.rawValue.computeEnumSize(fieldNumber: 4)
            }
            if hasMsgData {
                serialize_size += msgData.computeDataSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.MsgInfo.Builder {
            return Im.BaseDefine.MsgInfo.classBuilder() as! Im.BaseDefine.MsgInfo.Builder
        }
        public func getBuilder() -> Im.BaseDefine.MsgInfo.Builder {
            return classBuilder() as! Im.BaseDefine.MsgInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.MsgInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.MsgInfo.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.MsgInfo.Builder {
            return try Im.BaseDefine.MsgInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.MsgInfo) throws -> Im.BaseDefine.MsgInfo.Builder {
            return try Im.BaseDefine.MsgInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasMsgId {
                jsonMap["msgId"] = UInt(msgId)
            }
            if hasFromSessionId {
                jsonMap["fromSessionId"] = UInt(fromSessionId)
            }
            if hasCreateTime {
                jsonMap["createTime"] = UInt(createTime)
            }
            if hasMsgType {
                jsonMap["msgType"] = msgType.toString()
            }
            if hasMsgData {
                jsonMap["msgData"] = msgData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.MsgInfo {
            return try Im.BaseDefine.MsgInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.MsgInfo {
            return try Im.BaseDefine.MsgInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasMsgId {
                output += "\(indent) msgId: \(msgId) \n"
            }
            if hasFromSessionId {
                output += "\(indent) fromSessionId: \(fromSessionId) \n"
            }
            if hasCreateTime {
                output += "\(indent) createTime: \(createTime) \n"
            }
            if (hasMsgType) {
                output += "\(indent) msgType: \(msgType.description)\n"
            }
            if hasMsgData {
                output += "\(indent) msgData: \(msgData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasMsgId {
                    hashCode = (hashCode &* 31) &+ msgId.hashValue
                }
                if hasFromSessionId {
                    hashCode = (hashCode &* 31) &+ fromSessionId.hashValue
                }
                if hasCreateTime {
                    hashCode = (hashCode &* 31) &+ createTime.hashValue
                }
                if hasMsgType {
                     hashCode = (hashCode &* 31) &+ msgType.hashValue
                }
                if hasMsgData {
                    hashCode = (hashCode &* 31) &+ msgData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.MsgInfo"
        }
        override public func className() -> String {
            return "Im.BaseDefine.MsgInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.MsgInfo = Im.BaseDefine.MsgInfo()
            public func getMessage() -> Im.BaseDefine.MsgInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var msgId:UInt32 {
                get {
                    return builderResult.msgId
                }
                set (value) {
                    builderResult.hasMsgId = true
                    builderResult.msgId = value
                }
            }
            public var hasMsgId:Bool {
                get {
                    return builderResult.hasMsgId
                }
            }
            @discardableResult
            public func setMsgId(_ value:UInt32) -> Im.BaseDefine.MsgInfo.Builder {
                self.msgId = value
                return self
            }
            @discardableResult
            public func clearMsgId() -> Im.BaseDefine.MsgInfo.Builder{
                builderResult.hasMsgId = false
                builderResult.msgId = nil
                return self
            }
            ///发送的用户id
            public var fromSessionId:UInt32 {
                get {
                    return builderResult.fromSessionId
                }
                set (value) {
                    builderResult.hasFromSessionId = true
                    builderResult.fromSessionId = value
                }
            }
            public var hasFromSessionId:Bool {
                get {
                    return builderResult.hasFromSessionId
                }
            }
            @discardableResult
            public func setFromSessionId(_ value:UInt32) -> Im.BaseDefine.MsgInfo.Builder {
                self.fromSessionId = value
                return self
            }
            @discardableResult
            public func clearFromSessionId() -> Im.BaseDefine.MsgInfo.Builder{
                builderResult.hasFromSessionId = false
                builderResult.fromSessionId = nil
                return self
            }
            public var createTime:UInt32 {
                get {
                    return builderResult.createTime
                }
                set (value) {
                    builderResult.hasCreateTime = true
                    builderResult.createTime = value
                }
            }
            public var hasCreateTime:Bool {
                get {
                    return builderResult.hasCreateTime
                }
            }
            @discardableResult
            public func setCreateTime(_ value:UInt32) -> Im.BaseDefine.MsgInfo.Builder {
                self.createTime = value
                return self
            }
            @discardableResult
            public func clearCreateTime() -> Im.BaseDefine.MsgInfo.Builder{
                builderResult.hasCreateTime = false
                builderResult.createTime = nil
                return self
            }
                public var msgType:Im.BaseDefine.MsgType {
                    get {
                        return builderResult.msgType
                    }
                    set (value) {
                        builderResult.hasMsgType = true
                        builderResult.msgType = value
                    }
                }
                public var hasMsgType:Bool{
                    get {
                        return builderResult.hasMsgType
                    }
                }
            @discardableResult
                public func setMsgType(_ value:Im.BaseDefine.MsgType) -> Im.BaseDefine.MsgInfo.Builder {
                  self.msgType = value
                  return self
                }
            @discardableResult
                public func clearMsgType() -> Im.BaseDefine.MsgInfo.Builder {
                   builderResult.hasMsgType = false
                   builderResult.msgType = .msgTypeSingleText
                   return self
                }
            public var msgData:Data {
                get {
                    return builderResult.msgData
                }
                set (value) {
                    builderResult.hasMsgData = true
                    builderResult.msgData = value
                }
            }
            public var hasMsgData:Bool {
                get {
                    return builderResult.hasMsgData
                }
            }
            @discardableResult
            public func setMsgData(_ value:Data) -> Im.BaseDefine.MsgInfo.Builder {
                self.msgData = value
                return self
            }
            @discardableResult
            public func clearMsgData() -> Im.BaseDefine.MsgInfo.Builder{
                builderResult.hasMsgData = false
                builderResult.msgData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.MsgInfo.Builder {
                builderResult = Im.BaseDefine.MsgInfo()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.MsgInfo.Builder {
                return try Im.BaseDefine.MsgInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.MsgInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.MsgInfo {
                let returnMe:Im.BaseDefine.MsgInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.MsgInfo) throws -> Im.BaseDefine.MsgInfo.Builder {
                if other == Im.BaseDefine.MsgInfo() {
                    return self
                }
                if other.hasMsgId {
                    msgId = other.msgId
                }
                if other.hasFromSessionId {
                    fromSessionId = other.fromSessionId
                }
                if other.hasCreateTime {
                    createTime = other.createTime
                }
                if other.hasMsgType {
                    msgType = other.msgType
                }
                if other.hasMsgData {
                    msgData = other.msgData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.MsgInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.MsgInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        msgId = try codedInputStream.readUInt32()

                    case 16:
                        fromSessionId = try codedInputStream.readUInt32()

                    case 24:
                        createTime = try codedInputStream.readUInt32()

                    case 32:
                        let valueIntmsgType = try codedInputStream.readEnum()
                        if let enumsmsgType = Im.BaseDefine.MsgType(rawValue:valueIntmsgType){
                            msgType = enumsmsgType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntmsgType))
                        }

                    case 42:
                        msgData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.MsgInfo.Builder {
                let resultDecodedBuilder = Im.BaseDefine.MsgInfo.Builder()
                if let jsonValueMsgId = jsonMap["msgId"] as? UInt {
                    resultDecodedBuilder.msgId = UInt32(jsonValueMsgId)
                } else if let jsonValueMsgId = jsonMap["msgId"] as? String {
                    resultDecodedBuilder.msgId = UInt32(jsonValueMsgId)!
                }
                if let jsonValueFromSessionId = jsonMap["fromSessionId"] as? UInt {
                    resultDecodedBuilder.fromSessionId = UInt32(jsonValueFromSessionId)
                } else if let jsonValueFromSessionId = jsonMap["fromSessionId"] as? String {
                    resultDecodedBuilder.fromSessionId = UInt32(jsonValueFromSessionId)!
                }
                if let jsonValueCreateTime = jsonMap["createTime"] as? UInt {
                    resultDecodedBuilder.createTime = UInt32(jsonValueCreateTime)
                } else if let jsonValueCreateTime = jsonMap["createTime"] as? String {
                    resultDecodedBuilder.createTime = UInt32(jsonValueCreateTime)!
                }
                if let jsonValueMsgType = jsonMap["msgType"] as? String {
                    resultDecodedBuilder.msgType = try Im.BaseDefine.MsgType.fromString(jsonValueMsgType)
                }
                if let jsonValueMsgData = jsonMap["msgData"] as? String {
                    resultDecodedBuilder.msgData = Data(base64Encoded:jsonValueMsgData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.MsgInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.MsgInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GroupVersionInfo : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.GroupVersionInfo.Builder

        public static func == (lhs: Im.BaseDefine.GroupVersionInfo, rhs: Im.BaseDefine.GroupVersionInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:UInt32! = nil
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var version:UInt32! = nil
        public fileprivate(set) var hasVersion:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            if !hasVersion {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:groupId)
            }
            if hasVersion {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:version)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeUInt32Size(fieldNumber: 1)
            }
            if hasVersion {
                serialize_size += version.computeUInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.GroupVersionInfo.Builder {
            return Im.BaseDefine.GroupVersionInfo.classBuilder() as! Im.BaseDefine.GroupVersionInfo.Builder
        }
        public func getBuilder() -> Im.BaseDefine.GroupVersionInfo.Builder {
            return classBuilder() as! Im.BaseDefine.GroupVersionInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.GroupVersionInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.GroupVersionInfo.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.GroupVersionInfo.Builder {
            return try Im.BaseDefine.GroupVersionInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.GroupVersionInfo) throws -> Im.BaseDefine.GroupVersionInfo.Builder {
            return try Im.BaseDefine.GroupVersionInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = UInt(groupId)
            }
            if hasVersion {
                jsonMap["version"] = UInt(version)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.GroupVersionInfo {
            return try Im.BaseDefine.GroupVersionInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.GroupVersionInfo {
            return try Im.BaseDefine.GroupVersionInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if hasVersion {
                output += "\(indent) version: \(version) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasVersion {
                    hashCode = (hashCode &* 31) &+ version.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.GroupVersionInfo"
        }
        override public func className() -> String {
            return "Im.BaseDefine.GroupVersionInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.GroupVersionInfo = Im.BaseDefine.GroupVersionInfo()
            public func getMessage() -> Im.BaseDefine.GroupVersionInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:UInt32 {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:UInt32) -> Im.BaseDefine.GroupVersionInfo.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Im.BaseDefine.GroupVersionInfo.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = nil
                return self
            }
            public var version:UInt32 {
                get {
                    return builderResult.version
                }
                set (value) {
                    builderResult.hasVersion = true
                    builderResult.version = value
                }
            }
            public var hasVersion:Bool {
                get {
                    return builderResult.hasVersion
                }
            }
            @discardableResult
            public func setVersion(_ value:UInt32) -> Im.BaseDefine.GroupVersionInfo.Builder {
                self.version = value
                return self
            }
            @discardableResult
            public func clearVersion() -> Im.BaseDefine.GroupVersionInfo.Builder{
                builderResult.hasVersion = false
                builderResult.version = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.GroupVersionInfo.Builder {
                builderResult = Im.BaseDefine.GroupVersionInfo()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.GroupVersionInfo.Builder {
                return try Im.BaseDefine.GroupVersionInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.GroupVersionInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.GroupVersionInfo {
                let returnMe:Im.BaseDefine.GroupVersionInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.GroupVersionInfo) throws -> Im.BaseDefine.GroupVersionInfo.Builder {
                if other == Im.BaseDefine.GroupVersionInfo() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if other.hasVersion {
                    version = other.version
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.GroupVersionInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.GroupVersionInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        groupId = try codedInputStream.readUInt32()

                    case 16:
                        version = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.GroupVersionInfo.Builder {
                let resultDecodedBuilder = Im.BaseDefine.GroupVersionInfo.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? UInt {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)
                } else if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)!
                }
                if let jsonValueVersion = jsonMap["version"] as? UInt {
                    resultDecodedBuilder.version = UInt32(jsonValueVersion)
                } else if let jsonValueVersion = jsonMap["version"] as? String {
                    resultDecodedBuilder.version = UInt32(jsonValueVersion)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.GroupVersionInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.GroupVersionInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class GroupInfo : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.GroupInfo.Builder

        public static func == (lhs: Im.BaseDefine.GroupInfo, rhs: Im.BaseDefine.GroupInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
            fieldCheck = fieldCheck && (lhs.hasGroupName == rhs.hasGroupName) && (!lhs.hasGroupName || lhs.groupName == rhs.groupName)
            fieldCheck = fieldCheck && (lhs.hasGroupAvatar == rhs.hasGroupAvatar) && (!lhs.hasGroupAvatar || lhs.groupAvatar == rhs.groupAvatar)
            fieldCheck = fieldCheck && (lhs.hasGroupCreatorId == rhs.hasGroupCreatorId) && (!lhs.hasGroupCreatorId || lhs.groupCreatorId == rhs.groupCreatorId)
            fieldCheck = fieldCheck && (lhs.hasGroupType == rhs.hasGroupType) && (!lhs.hasGroupType || lhs.groupType == rhs.groupType)
            fieldCheck = fieldCheck && (lhs.hasShieldStatus == rhs.hasShieldStatus) && (!lhs.hasShieldStatus || lhs.shieldStatus == rhs.shieldStatus)
            fieldCheck = fieldCheck && (lhs.groupMemberList == rhs.groupMemberList)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var groupId:UInt32! = nil
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var version:UInt32! = nil
        public fileprivate(set) var hasVersion:Bool = false

        public fileprivate(set) var groupName:String! = nil
        public fileprivate(set) var hasGroupName:Bool = false

        public fileprivate(set) var groupAvatar:String! = nil
        public fileprivate(set) var hasGroupAvatar:Bool = false

        public fileprivate(set) var groupCreatorId:UInt32! = nil
        public fileprivate(set) var hasGroupCreatorId:Bool = false

        public fileprivate(set) var groupType:Im.BaseDefine.GroupType = Im.BaseDefine.GroupType.groupTypeNormal
        public fileprivate(set) var hasGroupType:Bool = false
        ///1: shield  0: not shield 
        public fileprivate(set) var shieldStatus:UInt32! = nil
        public fileprivate(set) var hasShieldStatus:Bool = false

        public fileprivate(set) var groupMemberList:Array<UInt32> = Array<UInt32>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasGroupId {
                return false
            }
            if !hasVersion {
                return false
            }
            if !hasGroupName {
                return false
            }
            if !hasGroupAvatar {
                return false
            }
            if !hasGroupCreatorId {
                return false
            }
            if !hasGroupType {
                return false
            }
            if !hasShieldStatus {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasGroupId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:groupId)
            }
            if hasVersion {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:version)
            }
            if hasGroupName {
                try codedOutputStream.writeString(fieldNumber: 3, value:groupName)
            }
            if hasGroupAvatar {
                try codedOutputStream.writeString(fieldNumber: 4, value:groupAvatar)
            }
            if hasGroupCreatorId {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:groupCreatorId)
            }
            if hasGroupType {
                try codedOutputStream.writeEnum(fieldNumber: 6, value:groupType.rawValue)
            }
            if hasShieldStatus {
                try codedOutputStream.writeUInt32(fieldNumber: 7, value:shieldStatus)
            }
            if !groupMemberList.isEmpty {
                for oneValuegroupMemberList in groupMemberList {
                    try codedOutputStream.writeUInt32(fieldNumber: 8, value:oneValuegroupMemberList)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasGroupId {
                serialize_size += groupId.computeUInt32Size(fieldNumber: 1)
            }
            if hasVersion {
                serialize_size += version.computeUInt32Size(fieldNumber: 2)
            }
            if hasGroupName {
                serialize_size += groupName.computeStringSize(fieldNumber: 3)
            }
            if hasGroupAvatar {
                serialize_size += groupAvatar.computeStringSize(fieldNumber: 4)
            }
            if hasGroupCreatorId {
                serialize_size += groupCreatorId.computeUInt32Size(fieldNumber: 5)
            }
            if (hasGroupType) {
                serialize_size += groupType.rawValue.computeEnumSize(fieldNumber: 6)
            }
            if hasShieldStatus {
                serialize_size += shieldStatus.computeUInt32Size(fieldNumber: 7)
            }
            var dataSizeGroupMemberList:Int32 = 0
            for oneValuegroupMemberList in groupMemberList {
                dataSizeGroupMemberList += oneValuegroupMemberList.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeGroupMemberList
            serialize_size += 1 * Int32(groupMemberList.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.GroupInfo.Builder {
            return Im.BaseDefine.GroupInfo.classBuilder() as! Im.BaseDefine.GroupInfo.Builder
        }
        public func getBuilder() -> Im.BaseDefine.GroupInfo.Builder {
            return classBuilder() as! Im.BaseDefine.GroupInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.GroupInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.GroupInfo.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.GroupInfo.Builder {
            return try Im.BaseDefine.GroupInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.GroupInfo) throws -> Im.BaseDefine.GroupInfo.Builder {
            return try Im.BaseDefine.GroupInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasGroupId {
                jsonMap["groupId"] = UInt(groupId)
            }
            if hasVersion {
                jsonMap["version"] = UInt(version)
            }
            if hasGroupName {
                jsonMap["groupName"] = groupName
            }
            if hasGroupAvatar {
                jsonMap["groupAvatar"] = groupAvatar
            }
            if hasGroupCreatorId {
                jsonMap["groupCreatorId"] = UInt(groupCreatorId)
            }
            if hasGroupType {
                jsonMap["groupType"] = groupType.toString()
            }
            if hasShieldStatus {
                jsonMap["shieldStatus"] = UInt(shieldStatus)
            }
            if !groupMemberList.isEmpty {
                var jsonArrayGroupMemberList:Array<UInt> = []
                for oneValueGroupMemberList in groupMemberList {
                    jsonArrayGroupMemberList.append(UInt(oneValueGroupMemberList))
                }
                jsonMap["groupMemberList"] = jsonArrayGroupMemberList
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.GroupInfo {
            return try Im.BaseDefine.GroupInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.GroupInfo {
            return try Im.BaseDefine.GroupInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if hasVersion {
                output += "\(indent) version: \(version) \n"
            }
            if hasGroupName {
                output += "\(indent) groupName: \(groupName) \n"
            }
            if hasGroupAvatar {
                output += "\(indent) groupAvatar: \(groupAvatar) \n"
            }
            if hasGroupCreatorId {
                output += "\(indent) groupCreatorId: \(groupCreatorId) \n"
            }
            if (hasGroupType) {
                output += "\(indent) groupType: \(groupType.description)\n"
            }
            if hasShieldStatus {
                output += "\(indent) shieldStatus: \(shieldStatus) \n"
            }
            var groupMemberListElementIndex:Int = 0
            for oneValueGroupMemberList in groupMemberList  {
                output += "\(indent) groupMemberList[\(groupMemberListElementIndex)]: \(oneValueGroupMemberList)\n"
                groupMemberListElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasVersion {
                    hashCode = (hashCode &* 31) &+ version.hashValue
                }
                if hasGroupName {
                    hashCode = (hashCode &* 31) &+ groupName.hashValue
                }
                if hasGroupAvatar {
                    hashCode = (hashCode &* 31) &+ groupAvatar.hashValue
                }
                if hasGroupCreatorId {
                    hashCode = (hashCode &* 31) &+ groupCreatorId.hashValue
                }
                if hasGroupType {
                     hashCode = (hashCode &* 31) &+ groupType.hashValue
                }
                if hasShieldStatus {
                    hashCode = (hashCode &* 31) &+ shieldStatus.hashValue
                }
                for oneValueGroupMemberList in groupMemberList {
                    hashCode = (hashCode &* 31) &+ oneValueGroupMemberList.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.GroupInfo"
        }
        override public func className() -> String {
            return "Im.BaseDefine.GroupInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.GroupInfo = Im.BaseDefine.GroupInfo()
            public func getMessage() -> Im.BaseDefine.GroupInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var groupId:UInt32 {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:UInt32) -> Im.BaseDefine.GroupInfo.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Im.BaseDefine.GroupInfo.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = nil
                return self
            }
            public var version:UInt32 {
                get {
                    return builderResult.version
                }
                set (value) {
                    builderResult.hasVersion = true
                    builderResult.version = value
                }
            }
            public var hasVersion:Bool {
                get {
                    return builderResult.hasVersion
                }
            }
            @discardableResult
            public func setVersion(_ value:UInt32) -> Im.BaseDefine.GroupInfo.Builder {
                self.version = value
                return self
            }
            @discardableResult
            public func clearVersion() -> Im.BaseDefine.GroupInfo.Builder{
                builderResult.hasVersion = false
                builderResult.version = nil
                return self
            }
            public var groupName:String {
                get {
                    return builderResult.groupName
                }
                set (value) {
                    builderResult.hasGroupName = true
                    builderResult.groupName = value
                }
            }
            public var hasGroupName:Bool {
                get {
                    return builderResult.hasGroupName
                }
            }
            @discardableResult
            public func setGroupName(_ value:String) -> Im.BaseDefine.GroupInfo.Builder {
                self.groupName = value
                return self
            }
            @discardableResult
            public func clearGroupName() -> Im.BaseDefine.GroupInfo.Builder{
                builderResult.hasGroupName = false
                builderResult.groupName = nil
                return self
            }
            public var groupAvatar:String {
                get {
                    return builderResult.groupAvatar
                }
                set (value) {
                    builderResult.hasGroupAvatar = true
                    builderResult.groupAvatar = value
                }
            }
            public var hasGroupAvatar:Bool {
                get {
                    return builderResult.hasGroupAvatar
                }
            }
            @discardableResult
            public func setGroupAvatar(_ value:String) -> Im.BaseDefine.GroupInfo.Builder {
                self.groupAvatar = value
                return self
            }
            @discardableResult
            public func clearGroupAvatar() -> Im.BaseDefine.GroupInfo.Builder{
                builderResult.hasGroupAvatar = false
                builderResult.groupAvatar = nil
                return self
            }
            public var groupCreatorId:UInt32 {
                get {
                    return builderResult.groupCreatorId
                }
                set (value) {
                    builderResult.hasGroupCreatorId = true
                    builderResult.groupCreatorId = value
                }
            }
            public var hasGroupCreatorId:Bool {
                get {
                    return builderResult.hasGroupCreatorId
                }
            }
            @discardableResult
            public func setGroupCreatorId(_ value:UInt32) -> Im.BaseDefine.GroupInfo.Builder {
                self.groupCreatorId = value
                return self
            }
            @discardableResult
            public func clearGroupCreatorId() -> Im.BaseDefine.GroupInfo.Builder{
                builderResult.hasGroupCreatorId = false
                builderResult.groupCreatorId = nil
                return self
            }
                public var groupType:Im.BaseDefine.GroupType {
                    get {
                        return builderResult.groupType
                    }
                    set (value) {
                        builderResult.hasGroupType = true
                        builderResult.groupType = value
                    }
                }
                public var hasGroupType:Bool{
                    get {
                        return builderResult.hasGroupType
                    }
                }
            @discardableResult
                public func setGroupType(_ value:Im.BaseDefine.GroupType) -> Im.BaseDefine.GroupInfo.Builder {
                  self.groupType = value
                  return self
                }
            @discardableResult
                public func clearGroupType() -> Im.BaseDefine.GroupInfo.Builder {
                   builderResult.hasGroupType = false
                   builderResult.groupType = .groupTypeNormal
                   return self
                }
            ///1: shield  0: not shield 
            public var shieldStatus:UInt32 {
                get {
                    return builderResult.shieldStatus
                }
                set (value) {
                    builderResult.hasShieldStatus = true
                    builderResult.shieldStatus = value
                }
            }
            public var hasShieldStatus:Bool {
                get {
                    return builderResult.hasShieldStatus
                }
            }
            @discardableResult
            public func setShieldStatus(_ value:UInt32) -> Im.BaseDefine.GroupInfo.Builder {
                self.shieldStatus = value
                return self
            }
            @discardableResult
            public func clearShieldStatus() -> Im.BaseDefine.GroupInfo.Builder{
                builderResult.hasShieldStatus = false
                builderResult.shieldStatus = nil
                return self
            }
            public var groupMemberList:Array<UInt32> {
                get {
                    return builderResult.groupMemberList
                }
                set (array) {
                    builderResult.groupMemberList = array
                }
            }
            @discardableResult
            public func setGroupMemberList(_ value:Array<UInt32>) -> Im.BaseDefine.GroupInfo.Builder {
                self.groupMemberList = value
                return self
            }
            @discardableResult
            public func clearGroupMemberList() -> Im.BaseDefine.GroupInfo.Builder {
                builderResult.groupMemberList.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.GroupInfo.Builder {
                builderResult = Im.BaseDefine.GroupInfo()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.GroupInfo.Builder {
                return try Im.BaseDefine.GroupInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.GroupInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.GroupInfo {
                let returnMe:Im.BaseDefine.GroupInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.GroupInfo) throws -> Im.BaseDefine.GroupInfo.Builder {
                if other == Im.BaseDefine.GroupInfo() {
                    return self
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if other.hasVersion {
                    version = other.version
                }
                if other.hasGroupName {
                    groupName = other.groupName
                }
                if other.hasGroupAvatar {
                    groupAvatar = other.groupAvatar
                }
                if other.hasGroupCreatorId {
                    groupCreatorId = other.groupCreatorId
                }
                if other.hasGroupType {
                    groupType = other.groupType
                }
                if other.hasShieldStatus {
                    shieldStatus = other.shieldStatus
                }
                if !other.groupMemberList.isEmpty {
                    builderResult.groupMemberList += other.groupMemberList
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.GroupInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.GroupInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        groupId = try codedInputStream.readUInt32()

                    case 16:
                        version = try codedInputStream.readUInt32()

                    case 26:
                        groupName = try codedInputStream.readString()

                    case 34:
                        groupAvatar = try codedInputStream.readString()

                    case 40:
                        groupCreatorId = try codedInputStream.readUInt32()

                    case 48:
                        let valueIntgroupType = try codedInputStream.readEnum()
                        if let enumsgroupType = Im.BaseDefine.GroupType(rawValue:valueIntgroupType){
                            groupType = enumsgroupType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 6, value:Int64(valueIntgroupType))
                        }

                    case 56:
                        shieldStatus = try codedInputStream.readUInt32()

                    case 64:
                        groupMemberList += [try codedInputStream.readUInt32()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.GroupInfo.Builder {
                let resultDecodedBuilder = Im.BaseDefine.GroupInfo.Builder()
                if let jsonValueGroupId = jsonMap["groupId"] as? UInt {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)
                } else if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)!
                }
                if let jsonValueVersion = jsonMap["version"] as? UInt {
                    resultDecodedBuilder.version = UInt32(jsonValueVersion)
                } else if let jsonValueVersion = jsonMap["version"] as? String {
                    resultDecodedBuilder.version = UInt32(jsonValueVersion)!
                }
                if let jsonValueGroupName = jsonMap["groupName"] as? String {
                    resultDecodedBuilder.groupName = jsonValueGroupName
                }
                if let jsonValueGroupAvatar = jsonMap["groupAvatar"] as? String {
                    resultDecodedBuilder.groupAvatar = jsonValueGroupAvatar
                }
                if let jsonValueGroupCreatorId = jsonMap["groupCreatorId"] as? UInt {
                    resultDecodedBuilder.groupCreatorId = UInt32(jsonValueGroupCreatorId)
                } else if let jsonValueGroupCreatorId = jsonMap["groupCreatorId"] as? String {
                    resultDecodedBuilder.groupCreatorId = UInt32(jsonValueGroupCreatorId)!
                }
                if let jsonValueGroupType = jsonMap["groupType"] as? String {
                    resultDecodedBuilder.groupType = try Im.BaseDefine.GroupType.fromString(jsonValueGroupType)
                }
                if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? UInt {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)
                } else if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? String {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)!
                }
                if let jsonValueGroupMemberList = jsonMap["groupMemberList"] as? Array<UInt> {
                    var jsonArrayGroupMemberList:Array<UInt32> = []
                    for oneValueGroupMemberList in jsonValueGroupMemberList {
                        jsonArrayGroupMemberList.append(UInt32(oneValueGroupMemberList))
                    }
                    resultDecodedBuilder.groupMemberList = jsonArrayGroupMemberList
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.GroupInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.GroupInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class UserTokenInfo : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.UserTokenInfo.Builder

        public static func == (lhs: Im.BaseDefine.UserTokenInfo, rhs: Im.BaseDefine.UserTokenInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasUserType == rhs.hasUserType) && (!lhs.hasUserType || lhs.userType == rhs.userType)
            fieldCheck = fieldCheck && (lhs.hasToken == rhs.hasToken) && (!lhs.hasToken || lhs.token == rhs.token)
            fieldCheck = fieldCheck && (lhs.hasPushCount == rhs.hasPushCount) && (!lhs.hasPushCount || lhs.pushCount == rhs.pushCount)
            fieldCheck = fieldCheck && (lhs.hasPushType == rhs.hasPushType) && (!lhs.hasPushType || lhs.pushType == rhs.pushType)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var userType:Im.BaseDefine.ClientType = Im.BaseDefine.ClientType.clientTypeWindows
        public fileprivate(set) var hasUserType:Bool = false
        public fileprivate(set) var token:String! = nil
        public fileprivate(set) var hasToken:Bool = false

        public fileprivate(set) var pushCount:UInt32! = nil
        public fileprivate(set) var hasPushCount:Bool = false

        ///1: 正常推送   2:无打扰式推送
        public fileprivate(set) var pushType:UInt32! = nil
        public fileprivate(set) var hasPushType:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasUserType {
                return false
            }
            if !hasToken {
                return false
            }
            if !hasPushCount {
                return false
            }
            if !hasPushType {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasUserType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:userType.rawValue)
            }
            if hasToken {
                try codedOutputStream.writeString(fieldNumber: 3, value:token)
            }
            if hasPushCount {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:pushCount)
            }
            if hasPushType {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:pushType)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasUserType) {
                serialize_size += userType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasToken {
                serialize_size += token.computeStringSize(fieldNumber: 3)
            }
            if hasPushCount {
                serialize_size += pushCount.computeUInt32Size(fieldNumber: 4)
            }
            if hasPushType {
                serialize_size += pushType.computeUInt32Size(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.UserTokenInfo.Builder {
            return Im.BaseDefine.UserTokenInfo.classBuilder() as! Im.BaseDefine.UserTokenInfo.Builder
        }
        public func getBuilder() -> Im.BaseDefine.UserTokenInfo.Builder {
            return classBuilder() as! Im.BaseDefine.UserTokenInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.UserTokenInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.UserTokenInfo.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.UserTokenInfo.Builder {
            return try Im.BaseDefine.UserTokenInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.UserTokenInfo) throws -> Im.BaseDefine.UserTokenInfo.Builder {
            return try Im.BaseDefine.UserTokenInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasUserType {
                jsonMap["userType"] = userType.toString()
            }
            if hasToken {
                jsonMap["token"] = token
            }
            if hasPushCount {
                jsonMap["pushCount"] = UInt(pushCount)
            }
            if hasPushType {
                jsonMap["pushType"] = UInt(pushType)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.UserTokenInfo {
            return try Im.BaseDefine.UserTokenInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.UserTokenInfo {
            return try Im.BaseDefine.UserTokenInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasUserType) {
                output += "\(indent) userType: \(userType.description)\n"
            }
            if hasToken {
                output += "\(indent) token: \(token) \n"
            }
            if hasPushCount {
                output += "\(indent) pushCount: \(pushCount) \n"
            }
            if hasPushType {
                output += "\(indent) pushType: \(pushType) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasUserType {
                     hashCode = (hashCode &* 31) &+ userType.hashValue
                }
                if hasToken {
                    hashCode = (hashCode &* 31) &+ token.hashValue
                }
                if hasPushCount {
                    hashCode = (hashCode &* 31) &+ pushCount.hashValue
                }
                if hasPushType {
                    hashCode = (hashCode &* 31) &+ pushType.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.UserTokenInfo"
        }
        override public func className() -> String {
            return "Im.BaseDefine.UserTokenInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.UserTokenInfo = Im.BaseDefine.UserTokenInfo()
            public func getMessage() -> Im.BaseDefine.UserTokenInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.BaseDefine.UserTokenInfo.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.BaseDefine.UserTokenInfo.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var userType:Im.BaseDefine.ClientType {
                    get {
                        return builderResult.userType
                    }
                    set (value) {
                        builderResult.hasUserType = true
                        builderResult.userType = value
                    }
                }
                public var hasUserType:Bool{
                    get {
                        return builderResult.hasUserType
                    }
                }
            @discardableResult
                public func setUserType(_ value:Im.BaseDefine.ClientType) -> Im.BaseDefine.UserTokenInfo.Builder {
                  self.userType = value
                  return self
                }
            @discardableResult
                public func clearUserType() -> Im.BaseDefine.UserTokenInfo.Builder {
                   builderResult.hasUserType = false
                   builderResult.userType = .clientTypeWindows
                   return self
                }
            public var token:String {
                get {
                    return builderResult.token
                }
                set (value) {
                    builderResult.hasToken = true
                    builderResult.token = value
                }
            }
            public var hasToken:Bool {
                get {
                    return builderResult.hasToken
                }
            }
            @discardableResult
            public func setToken(_ value:String) -> Im.BaseDefine.UserTokenInfo.Builder {
                self.token = value
                return self
            }
            @discardableResult
            public func clearToken() -> Im.BaseDefine.UserTokenInfo.Builder{
                builderResult.hasToken = false
                builderResult.token = nil
                return self
            }
            public var pushCount:UInt32 {
                get {
                    return builderResult.pushCount
                }
                set (value) {
                    builderResult.hasPushCount = true
                    builderResult.pushCount = value
                }
            }
            public var hasPushCount:Bool {
                get {
                    return builderResult.hasPushCount
                }
            }
            @discardableResult
            public func setPushCount(_ value:UInt32) -> Im.BaseDefine.UserTokenInfo.Builder {
                self.pushCount = value
                return self
            }
            @discardableResult
            public func clearPushCount() -> Im.BaseDefine.UserTokenInfo.Builder{
                builderResult.hasPushCount = false
                builderResult.pushCount = nil
                return self
            }
            ///1: 正常推送   2:无打扰式推送
            public var pushType:UInt32 {
                get {
                    return builderResult.pushType
                }
                set (value) {
                    builderResult.hasPushType = true
                    builderResult.pushType = value
                }
            }
            public var hasPushType:Bool {
                get {
                    return builderResult.hasPushType
                }
            }
            @discardableResult
            public func setPushType(_ value:UInt32) -> Im.BaseDefine.UserTokenInfo.Builder {
                self.pushType = value
                return self
            }
            @discardableResult
            public func clearPushType() -> Im.BaseDefine.UserTokenInfo.Builder{
                builderResult.hasPushType = false
                builderResult.pushType = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.UserTokenInfo.Builder {
                builderResult = Im.BaseDefine.UserTokenInfo()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.UserTokenInfo.Builder {
                return try Im.BaseDefine.UserTokenInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.UserTokenInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.UserTokenInfo {
                let returnMe:Im.BaseDefine.UserTokenInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.UserTokenInfo) throws -> Im.BaseDefine.UserTokenInfo.Builder {
                if other == Im.BaseDefine.UserTokenInfo() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasUserType {
                    userType = other.userType
                }
                if other.hasToken {
                    token = other.token
                }
                if other.hasPushCount {
                    pushCount = other.pushCount
                }
                if other.hasPushType {
                    pushType = other.pushType
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.UserTokenInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UserTokenInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntuserType = try codedInputStream.readEnum()
                        if let enumsuserType = Im.BaseDefine.ClientType(rawValue:valueIntuserType){
                            userType = enumsuserType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntuserType))
                        }

                    case 26:
                        token = try codedInputStream.readString()

                    case 32:
                        pushCount = try codedInputStream.readUInt32()

                    case 40:
                        pushType = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.UserTokenInfo.Builder {
                let resultDecodedBuilder = Im.BaseDefine.UserTokenInfo.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueUserType = jsonMap["userType"] as? String {
                    resultDecodedBuilder.userType = try Im.BaseDefine.ClientType.fromString(jsonValueUserType)
                }
                if let jsonValueToken = jsonMap["token"] as? String {
                    resultDecodedBuilder.token = jsonValueToken
                }
                if let jsonValuePushCount = jsonMap["pushCount"] as? UInt {
                    resultDecodedBuilder.pushCount = UInt32(jsonValuePushCount)
                } else if let jsonValuePushCount = jsonMap["pushCount"] as? String {
                    resultDecodedBuilder.pushCount = UInt32(jsonValuePushCount)!
                }
                if let jsonValuePushType = jsonMap["pushType"] as? UInt {
                    resultDecodedBuilder.pushType = UInt32(jsonValuePushType)
                } else if let jsonValuePushType = jsonMap["pushType"] as? String {
                    resultDecodedBuilder.pushType = UInt32(jsonValuePushType)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.UserTokenInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.UserTokenInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PushResult : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.PushResult.Builder

        public static func == (lhs: Im.BaseDefine.PushResult, rhs: Im.BaseDefine.PushResult) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserToken == rhs.hasUserToken) && (!lhs.hasUserToken || lhs.userToken == rhs.userToken)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userToken:String! = nil
        public fileprivate(set) var hasUserToken:Bool = false

        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserToken {
                return false
            }
            if !hasResultCode {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserToken {
                try codedOutputStream.writeString(fieldNumber: 1, value:userToken)
            }
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:resultCode)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserToken {
                serialize_size += userToken.computeStringSize(fieldNumber: 1)
            }
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.PushResult.Builder {
            return Im.BaseDefine.PushResult.classBuilder() as! Im.BaseDefine.PushResult.Builder
        }
        public func getBuilder() -> Im.BaseDefine.PushResult.Builder {
            return classBuilder() as! Im.BaseDefine.PushResult.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.PushResult.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.PushResult.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.PushResult.Builder {
            return try Im.BaseDefine.PushResult.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.PushResult) throws -> Im.BaseDefine.PushResult.Builder {
            return try Im.BaseDefine.PushResult.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserToken {
                jsonMap["userToken"] = userToken
            }
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.PushResult {
            return try Im.BaseDefine.PushResult.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.PushResult {
            return try Im.BaseDefine.PushResult.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserToken {
                output += "\(indent) userToken: \(userToken) \n"
            }
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserToken {
                    hashCode = (hashCode &* 31) &+ userToken.hashValue
                }
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.PushResult"
        }
        override public func className() -> String {
            return "Im.BaseDefine.PushResult"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.PushResult = Im.BaseDefine.PushResult()
            public func getMessage() -> Im.BaseDefine.PushResult {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userToken:String {
                get {
                    return builderResult.userToken
                }
                set (value) {
                    builderResult.hasUserToken = true
                    builderResult.userToken = value
                }
            }
            public var hasUserToken:Bool {
                get {
                    return builderResult.hasUserToken
                }
            }
            @discardableResult
            public func setUserToken(_ value:String) -> Im.BaseDefine.PushResult.Builder {
                self.userToken = value
                return self
            }
            @discardableResult
            public func clearUserToken() -> Im.BaseDefine.PushResult.Builder{
                builderResult.hasUserToken = false
                builderResult.userToken = nil
                return self
            }
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.BaseDefine.PushResult.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.BaseDefine.PushResult.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.PushResult.Builder {
                builderResult = Im.BaseDefine.PushResult()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.PushResult.Builder {
                return try Im.BaseDefine.PushResult.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.PushResult {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.PushResult {
                let returnMe:Im.BaseDefine.PushResult = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.PushResult) throws -> Im.BaseDefine.PushResult.Builder {
                if other == Im.BaseDefine.PushResult() {
                    return self
                }
                if other.hasUserToken {
                    userToken = other.userToken
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.PushResult.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.PushResult.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        userToken = try codedInputStream.readString()

                    case 16:
                        resultCode = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.PushResult.Builder {
                let resultDecodedBuilder = Im.BaseDefine.PushResult.Builder()
                if let jsonValueUserToken = jsonMap["userToken"] as? String {
                    resultDecodedBuilder.userToken = jsonValueUserToken
                }
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.PushResult.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.PushResult.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ShieldStatus : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.ShieldStatus.Builder

        public static func == (lhs: Im.BaseDefine.ShieldStatus, rhs: Im.BaseDefine.ShieldStatus) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasShieldStatus == rhs.hasShieldStatus) && (!lhs.hasShieldStatus || lhs.shieldStatus == rhs.shieldStatus)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var groupId:UInt32! = nil
        public fileprivate(set) var hasGroupId:Bool = false

        ///1: shield  0: not shield 
        public fileprivate(set) var shieldStatus:UInt32! = nil
        public fileprivate(set) var hasShieldStatus:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasGroupId {
                return false
            }
            if !hasShieldStatus {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasGroupId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:groupId)
            }
            if hasShieldStatus {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:shieldStatus)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasGroupId {
                serialize_size += groupId.computeUInt32Size(fieldNumber: 2)
            }
            if hasShieldStatus {
                serialize_size += shieldStatus.computeUInt32Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.ShieldStatus.Builder {
            return Im.BaseDefine.ShieldStatus.classBuilder() as! Im.BaseDefine.ShieldStatus.Builder
        }
        public func getBuilder() -> Im.BaseDefine.ShieldStatus.Builder {
            return classBuilder() as! Im.BaseDefine.ShieldStatus.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.ShieldStatus.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.ShieldStatus.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.ShieldStatus.Builder {
            return try Im.BaseDefine.ShieldStatus.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.ShieldStatus) throws -> Im.BaseDefine.ShieldStatus.Builder {
            return try Im.BaseDefine.ShieldStatus.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasGroupId {
                jsonMap["groupId"] = UInt(groupId)
            }
            if hasShieldStatus {
                jsonMap["shieldStatus"] = UInt(shieldStatus)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.ShieldStatus {
            return try Im.BaseDefine.ShieldStatus.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.ShieldStatus {
            return try Im.BaseDefine.ShieldStatus.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if hasShieldStatus {
                output += "\(indent) shieldStatus: \(shieldStatus) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasShieldStatus {
                    hashCode = (hashCode &* 31) &+ shieldStatus.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.ShieldStatus"
        }
        override public func className() -> String {
            return "Im.BaseDefine.ShieldStatus"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.ShieldStatus = Im.BaseDefine.ShieldStatus()
            public func getMessage() -> Im.BaseDefine.ShieldStatus {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.BaseDefine.ShieldStatus.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.BaseDefine.ShieldStatus.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var groupId:UInt32 {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:UInt32) -> Im.BaseDefine.ShieldStatus.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Im.BaseDefine.ShieldStatus.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = nil
                return self
            }
            ///1: shield  0: not shield 
            public var shieldStatus:UInt32 {
                get {
                    return builderResult.shieldStatus
                }
                set (value) {
                    builderResult.hasShieldStatus = true
                    builderResult.shieldStatus = value
                }
            }
            public var hasShieldStatus:Bool {
                get {
                    return builderResult.hasShieldStatus
                }
            }
            @discardableResult
            public func setShieldStatus(_ value:UInt32) -> Im.BaseDefine.ShieldStatus.Builder {
                self.shieldStatus = value
                return self
            }
            @discardableResult
            public func clearShieldStatus() -> Im.BaseDefine.ShieldStatus.Builder{
                builderResult.hasShieldStatus = false
                builderResult.shieldStatus = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.ShieldStatus.Builder {
                builderResult = Im.BaseDefine.ShieldStatus()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.ShieldStatus.Builder {
                return try Im.BaseDefine.ShieldStatus.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.ShieldStatus {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.ShieldStatus {
                let returnMe:Im.BaseDefine.ShieldStatus = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.ShieldStatus) throws -> Im.BaseDefine.ShieldStatus.Builder {
                if other == Im.BaseDefine.ShieldStatus() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if other.hasShieldStatus {
                    shieldStatus = other.shieldStatus
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.ShieldStatus.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.ShieldStatus.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        groupId = try codedInputStream.readUInt32()

                    case 24:
                        shieldStatus = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.ShieldStatus.Builder {
                let resultDecodedBuilder = Im.BaseDefine.ShieldStatus.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueGroupId = jsonMap["groupId"] as? UInt {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)
                } else if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)!
                }
                if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? UInt {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)
                } else if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? String {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.ShieldStatus.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.ShieldStatus.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class OfflineFileInfo : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.OfflineFileInfo.Builder

        public static func == (lhs: Im.BaseDefine.OfflineFileInfo, rhs: Im.BaseDefine.OfflineFileInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFromUserId == rhs.hasFromUserId) && (!lhs.hasFromUserId || lhs.fromUserId == rhs.fromUserId)
            fieldCheck = fieldCheck && (lhs.hasTaskId == rhs.hasTaskId) && (!lhs.hasTaskId || lhs.taskId == rhs.taskId)
            fieldCheck = fieldCheck && (lhs.hasFileName == rhs.hasFileName) && (!lhs.hasFileName || lhs.fileName == rhs.fileName)
            fieldCheck = fieldCheck && (lhs.hasFileSize == rhs.hasFileSize) && (!lhs.hasFileSize || lhs.fileSize == rhs.fileSize)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var fromUserId:UInt32! = nil
        public fileprivate(set) var hasFromUserId:Bool = false

        public fileprivate(set) var taskId:String! = nil
        public fileprivate(set) var hasTaskId:Bool = false

        public fileprivate(set) var fileName:String! = nil
        public fileprivate(set) var hasFileName:Bool = false

        public fileprivate(set) var fileSize:UInt32! = nil
        public fileprivate(set) var hasFileSize:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasFromUserId {
                return false
            }
            if !hasTaskId {
                return false
            }
            if !hasFileName {
                return false
            }
            if !hasFileSize {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFromUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:fromUserId)
            }
            if hasTaskId {
                try codedOutputStream.writeString(fieldNumber: 2, value:taskId)
            }
            if hasFileName {
                try codedOutputStream.writeString(fieldNumber: 3, value:fileName)
            }
            if hasFileSize {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:fileSize)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFromUserId {
                serialize_size += fromUserId.computeUInt32Size(fieldNumber: 1)
            }
            if hasTaskId {
                serialize_size += taskId.computeStringSize(fieldNumber: 2)
            }
            if hasFileName {
                serialize_size += fileName.computeStringSize(fieldNumber: 3)
            }
            if hasFileSize {
                serialize_size += fileSize.computeUInt32Size(fieldNumber: 4)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.OfflineFileInfo.Builder {
            return Im.BaseDefine.OfflineFileInfo.classBuilder() as! Im.BaseDefine.OfflineFileInfo.Builder
        }
        public func getBuilder() -> Im.BaseDefine.OfflineFileInfo.Builder {
            return classBuilder() as! Im.BaseDefine.OfflineFileInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.OfflineFileInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.OfflineFileInfo.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.OfflineFileInfo.Builder {
            return try Im.BaseDefine.OfflineFileInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.OfflineFileInfo) throws -> Im.BaseDefine.OfflineFileInfo.Builder {
            return try Im.BaseDefine.OfflineFileInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFromUserId {
                jsonMap["fromUserId"] = UInt(fromUserId)
            }
            if hasTaskId {
                jsonMap["taskId"] = taskId
            }
            if hasFileName {
                jsonMap["fileName"] = fileName
            }
            if hasFileSize {
                jsonMap["fileSize"] = UInt(fileSize)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.OfflineFileInfo {
            return try Im.BaseDefine.OfflineFileInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.OfflineFileInfo {
            return try Im.BaseDefine.OfflineFileInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFromUserId {
                output += "\(indent) fromUserId: \(fromUserId) \n"
            }
            if hasTaskId {
                output += "\(indent) taskId: \(taskId) \n"
            }
            if hasFileName {
                output += "\(indent) fileName: \(fileName) \n"
            }
            if hasFileSize {
                output += "\(indent) fileSize: \(fileSize) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFromUserId {
                    hashCode = (hashCode &* 31) &+ fromUserId.hashValue
                }
                if hasTaskId {
                    hashCode = (hashCode &* 31) &+ taskId.hashValue
                }
                if hasFileName {
                    hashCode = (hashCode &* 31) &+ fileName.hashValue
                }
                if hasFileSize {
                    hashCode = (hashCode &* 31) &+ fileSize.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.OfflineFileInfo"
        }
        override public func className() -> String {
            return "Im.BaseDefine.OfflineFileInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.OfflineFileInfo = Im.BaseDefine.OfflineFileInfo()
            public func getMessage() -> Im.BaseDefine.OfflineFileInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var fromUserId:UInt32 {
                get {
                    return builderResult.fromUserId
                }
                set (value) {
                    builderResult.hasFromUserId = true
                    builderResult.fromUserId = value
                }
            }
            public var hasFromUserId:Bool {
                get {
                    return builderResult.hasFromUserId
                }
            }
            @discardableResult
            public func setFromUserId(_ value:UInt32) -> Im.BaseDefine.OfflineFileInfo.Builder {
                self.fromUserId = value
                return self
            }
            @discardableResult
            public func clearFromUserId() -> Im.BaseDefine.OfflineFileInfo.Builder{
                builderResult.hasFromUserId = false
                builderResult.fromUserId = nil
                return self
            }
            public var taskId:String {
                get {
                    return builderResult.taskId
                }
                set (value) {
                    builderResult.hasTaskId = true
                    builderResult.taskId = value
                }
            }
            public var hasTaskId:Bool {
                get {
                    return builderResult.hasTaskId
                }
            }
            @discardableResult
            public func setTaskId(_ value:String) -> Im.BaseDefine.OfflineFileInfo.Builder {
                self.taskId = value
                return self
            }
            @discardableResult
            public func clearTaskId() -> Im.BaseDefine.OfflineFileInfo.Builder{
                builderResult.hasTaskId = false
                builderResult.taskId = nil
                return self
            }
            public var fileName:String {
                get {
                    return builderResult.fileName
                }
                set (value) {
                    builderResult.hasFileName = true
                    builderResult.fileName = value
                }
            }
            public var hasFileName:Bool {
                get {
                    return builderResult.hasFileName
                }
            }
            @discardableResult
            public func setFileName(_ value:String) -> Im.BaseDefine.OfflineFileInfo.Builder {
                self.fileName = value
                return self
            }
            @discardableResult
            public func clearFileName() -> Im.BaseDefine.OfflineFileInfo.Builder{
                builderResult.hasFileName = false
                builderResult.fileName = nil
                return self
            }
            public var fileSize:UInt32 {
                get {
                    return builderResult.fileSize
                }
                set (value) {
                    builderResult.hasFileSize = true
                    builderResult.fileSize = value
                }
            }
            public var hasFileSize:Bool {
                get {
                    return builderResult.hasFileSize
                }
            }
            @discardableResult
            public func setFileSize(_ value:UInt32) -> Im.BaseDefine.OfflineFileInfo.Builder {
                self.fileSize = value
                return self
            }
            @discardableResult
            public func clearFileSize() -> Im.BaseDefine.OfflineFileInfo.Builder{
                builderResult.hasFileSize = false
                builderResult.fileSize = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.OfflineFileInfo.Builder {
                builderResult = Im.BaseDefine.OfflineFileInfo()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.OfflineFileInfo.Builder {
                return try Im.BaseDefine.OfflineFileInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.OfflineFileInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.OfflineFileInfo {
                let returnMe:Im.BaseDefine.OfflineFileInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.OfflineFileInfo) throws -> Im.BaseDefine.OfflineFileInfo.Builder {
                if other == Im.BaseDefine.OfflineFileInfo() {
                    return self
                }
                if other.hasFromUserId {
                    fromUserId = other.fromUserId
                }
                if other.hasTaskId {
                    taskId = other.taskId
                }
                if other.hasFileName {
                    fileName = other.fileName
                }
                if other.hasFileSize {
                    fileSize = other.fileSize
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.OfflineFileInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.OfflineFileInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        fromUserId = try codedInputStream.readUInt32()

                    case 18:
                        taskId = try codedInputStream.readString()

                    case 26:
                        fileName = try codedInputStream.readString()

                    case 32:
                        fileSize = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.OfflineFileInfo.Builder {
                let resultDecodedBuilder = Im.BaseDefine.OfflineFileInfo.Builder()
                if let jsonValueFromUserId = jsonMap["fromUserId"] as? UInt {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)
                } else if let jsonValueFromUserId = jsonMap["fromUserId"] as? String {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)!
                }
                if let jsonValueTaskId = jsonMap["taskId"] as? String {
                    resultDecodedBuilder.taskId = jsonValueTaskId
                }
                if let jsonValueFileName = jsonMap["fileName"] as? String {
                    resultDecodedBuilder.fileName = jsonValueFileName
                }
                if let jsonValueFileSize = jsonMap["fileSize"] as? UInt {
                    resultDecodedBuilder.fileSize = UInt32(jsonValueFileSize)
                } else if let jsonValueFileSize = jsonMap["fileSize"] as? String {
                    resultDecodedBuilder.fileSize = UInt32(jsonValueFileSize)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.OfflineFileInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.OfflineFileInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class DepartInfo : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.DepartInfo.Builder

        public static func == (lhs: Im.BaseDefine.DepartInfo, rhs: Im.BaseDefine.DepartInfo) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasDeptId == rhs.hasDeptId) && (!lhs.hasDeptId || lhs.deptId == rhs.deptId)
            fieldCheck = fieldCheck && (lhs.hasPriority == rhs.hasPriority) && (!lhs.hasPriority || lhs.priority == rhs.priority)
            fieldCheck = fieldCheck && (lhs.hasDeptName == rhs.hasDeptName) && (!lhs.hasDeptName || lhs.deptName == rhs.deptName)
            fieldCheck = fieldCheck && (lhs.hasParentDeptId == rhs.hasParentDeptId) && (!lhs.hasParentDeptId || lhs.parentDeptId == rhs.parentDeptId)
            fieldCheck = fieldCheck && (lhs.hasDeptStatus == rhs.hasDeptStatus) && (!lhs.hasDeptStatus || lhs.deptStatus == rhs.deptStatus)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var deptId:UInt32! = nil
        public fileprivate(set) var hasDeptId:Bool = false

        public fileprivate(set) var priority:UInt32! = nil
        public fileprivate(set) var hasPriority:Bool = false

        public fileprivate(set) var deptName:String! = nil
        public fileprivate(set) var hasDeptName:Bool = false

        public fileprivate(set) var parentDeptId:UInt32! = nil
        public fileprivate(set) var hasParentDeptId:Bool = false

        public fileprivate(set) var deptStatus:Im.BaseDefine.DepartmentStatusType = Im.BaseDefine.DepartmentStatusType.deptStatusOk
        public fileprivate(set) var hasDeptStatus:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasDeptId {
                return false
            }
            if !hasPriority {
                return false
            }
            if !hasDeptName {
                return false
            }
            if !hasParentDeptId {
                return false
            }
            if !hasDeptStatus {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasDeptId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:deptId)
            }
            if hasPriority {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:priority)
            }
            if hasDeptName {
                try codedOutputStream.writeString(fieldNumber: 3, value:deptName)
            }
            if hasParentDeptId {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:parentDeptId)
            }
            if hasDeptStatus {
                try codedOutputStream.writeEnum(fieldNumber: 5, value:deptStatus.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasDeptId {
                serialize_size += deptId.computeUInt32Size(fieldNumber: 1)
            }
            if hasPriority {
                serialize_size += priority.computeUInt32Size(fieldNumber: 2)
            }
            if hasDeptName {
                serialize_size += deptName.computeStringSize(fieldNumber: 3)
            }
            if hasParentDeptId {
                serialize_size += parentDeptId.computeUInt32Size(fieldNumber: 4)
            }
            if (hasDeptStatus) {
                serialize_size += deptStatus.rawValue.computeEnumSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.DepartInfo.Builder {
            return Im.BaseDefine.DepartInfo.classBuilder() as! Im.BaseDefine.DepartInfo.Builder
        }
        public func getBuilder() -> Im.BaseDefine.DepartInfo.Builder {
            return classBuilder() as! Im.BaseDefine.DepartInfo.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.DepartInfo.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.DepartInfo.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.DepartInfo.Builder {
            return try Im.BaseDefine.DepartInfo.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.DepartInfo) throws -> Im.BaseDefine.DepartInfo.Builder {
            return try Im.BaseDefine.DepartInfo.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasDeptId {
                jsonMap["deptId"] = UInt(deptId)
            }
            if hasPriority {
                jsonMap["priority"] = UInt(priority)
            }
            if hasDeptName {
                jsonMap["deptName"] = deptName
            }
            if hasParentDeptId {
                jsonMap["parentDeptId"] = UInt(parentDeptId)
            }
            if hasDeptStatus {
                jsonMap["deptStatus"] = deptStatus.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.DepartInfo {
            return try Im.BaseDefine.DepartInfo.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.DepartInfo {
            return try Im.BaseDefine.DepartInfo.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasDeptId {
                output += "\(indent) deptId: \(deptId) \n"
            }
            if hasPriority {
                output += "\(indent) priority: \(priority) \n"
            }
            if hasDeptName {
                output += "\(indent) deptName: \(deptName) \n"
            }
            if hasParentDeptId {
                output += "\(indent) parentDeptId: \(parentDeptId) \n"
            }
            if (hasDeptStatus) {
                output += "\(indent) deptStatus: \(deptStatus.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasDeptId {
                    hashCode = (hashCode &* 31) &+ deptId.hashValue
                }
                if hasPriority {
                    hashCode = (hashCode &* 31) &+ priority.hashValue
                }
                if hasDeptName {
                    hashCode = (hashCode &* 31) &+ deptName.hashValue
                }
                if hasParentDeptId {
                    hashCode = (hashCode &* 31) &+ parentDeptId.hashValue
                }
                if hasDeptStatus {
                     hashCode = (hashCode &* 31) &+ deptStatus.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.DepartInfo"
        }
        override public func className() -> String {
            return "Im.BaseDefine.DepartInfo"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.DepartInfo = Im.BaseDefine.DepartInfo()
            public func getMessage() -> Im.BaseDefine.DepartInfo {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var deptId:UInt32 {
                get {
                    return builderResult.deptId
                }
                set (value) {
                    builderResult.hasDeptId = true
                    builderResult.deptId = value
                }
            }
            public var hasDeptId:Bool {
                get {
                    return builderResult.hasDeptId
                }
            }
            @discardableResult
            public func setDeptId(_ value:UInt32) -> Im.BaseDefine.DepartInfo.Builder {
                self.deptId = value
                return self
            }
            @discardableResult
            public func clearDeptId() -> Im.BaseDefine.DepartInfo.Builder{
                builderResult.hasDeptId = false
                builderResult.deptId = nil
                return self
            }
            public var priority:UInt32 {
                get {
                    return builderResult.priority
                }
                set (value) {
                    builderResult.hasPriority = true
                    builderResult.priority = value
                }
            }
            public var hasPriority:Bool {
                get {
                    return builderResult.hasPriority
                }
            }
            @discardableResult
            public func setPriority(_ value:UInt32) -> Im.BaseDefine.DepartInfo.Builder {
                self.priority = value
                return self
            }
            @discardableResult
            public func clearPriority() -> Im.BaseDefine.DepartInfo.Builder{
                builderResult.hasPriority = false
                builderResult.priority = nil
                return self
            }
            public var deptName:String {
                get {
                    return builderResult.deptName
                }
                set (value) {
                    builderResult.hasDeptName = true
                    builderResult.deptName = value
                }
            }
            public var hasDeptName:Bool {
                get {
                    return builderResult.hasDeptName
                }
            }
            @discardableResult
            public func setDeptName(_ value:String) -> Im.BaseDefine.DepartInfo.Builder {
                self.deptName = value
                return self
            }
            @discardableResult
            public func clearDeptName() -> Im.BaseDefine.DepartInfo.Builder{
                builderResult.hasDeptName = false
                builderResult.deptName = nil
                return self
            }
            public var parentDeptId:UInt32 {
                get {
                    return builderResult.parentDeptId
                }
                set (value) {
                    builderResult.hasParentDeptId = true
                    builderResult.parentDeptId = value
                }
            }
            public var hasParentDeptId:Bool {
                get {
                    return builderResult.hasParentDeptId
                }
            }
            @discardableResult
            public func setParentDeptId(_ value:UInt32) -> Im.BaseDefine.DepartInfo.Builder {
                self.parentDeptId = value
                return self
            }
            @discardableResult
            public func clearParentDeptId() -> Im.BaseDefine.DepartInfo.Builder{
                builderResult.hasParentDeptId = false
                builderResult.parentDeptId = nil
                return self
            }
                public var deptStatus:Im.BaseDefine.DepartmentStatusType {
                    get {
                        return builderResult.deptStatus
                    }
                    set (value) {
                        builderResult.hasDeptStatus = true
                        builderResult.deptStatus = value
                    }
                }
                public var hasDeptStatus:Bool{
                    get {
                        return builderResult.hasDeptStatus
                    }
                }
            @discardableResult
                public func setDeptStatus(_ value:Im.BaseDefine.DepartmentStatusType) -> Im.BaseDefine.DepartInfo.Builder {
                  self.deptStatus = value
                  return self
                }
            @discardableResult
                public func clearDeptStatus() -> Im.BaseDefine.DepartInfo.Builder {
                   builderResult.hasDeptStatus = false
                   builderResult.deptStatus = .deptStatusOk
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.DepartInfo.Builder {
                builderResult = Im.BaseDefine.DepartInfo()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.DepartInfo.Builder {
                return try Im.BaseDefine.DepartInfo.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.DepartInfo {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.DepartInfo {
                let returnMe:Im.BaseDefine.DepartInfo = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.DepartInfo) throws -> Im.BaseDefine.DepartInfo.Builder {
                if other == Im.BaseDefine.DepartInfo() {
                    return self
                }
                if other.hasDeptId {
                    deptId = other.deptId
                }
                if other.hasPriority {
                    priority = other.priority
                }
                if other.hasDeptName {
                    deptName = other.deptName
                }
                if other.hasParentDeptId {
                    parentDeptId = other.parentDeptId
                }
                if other.hasDeptStatus {
                    deptStatus = other.deptStatus
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.DepartInfo.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.DepartInfo.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        deptId = try codedInputStream.readUInt32()

                    case 16:
                        priority = try codedInputStream.readUInt32()

                    case 26:
                        deptName = try codedInputStream.readString()

                    case 32:
                        parentDeptId = try codedInputStream.readUInt32()

                    case 40:
                        let valueIntdeptStatus = try codedInputStream.readEnum()
                        if let enumsdeptStatus = Im.BaseDefine.DepartmentStatusType(rawValue:valueIntdeptStatus){
                            deptStatus = enumsdeptStatus
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueIntdeptStatus))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.DepartInfo.Builder {
                let resultDecodedBuilder = Im.BaseDefine.DepartInfo.Builder()
                if let jsonValueDeptId = jsonMap["deptId"] as? UInt {
                    resultDecodedBuilder.deptId = UInt32(jsonValueDeptId)
                } else if let jsonValueDeptId = jsonMap["deptId"] as? String {
                    resultDecodedBuilder.deptId = UInt32(jsonValueDeptId)!
                }
                if let jsonValuePriority = jsonMap["priority"] as? UInt {
                    resultDecodedBuilder.priority = UInt32(jsonValuePriority)
                } else if let jsonValuePriority = jsonMap["priority"] as? String {
                    resultDecodedBuilder.priority = UInt32(jsonValuePriority)!
                }
                if let jsonValueDeptName = jsonMap["deptName"] as? String {
                    resultDecodedBuilder.deptName = jsonValueDeptName
                }
                if let jsonValueParentDeptId = jsonMap["parentDeptId"] as? UInt {
                    resultDecodedBuilder.parentDeptId = UInt32(jsonValueParentDeptId)
                } else if let jsonValueParentDeptId = jsonMap["parentDeptId"] as? String {
                    resultDecodedBuilder.parentDeptId = UInt32(jsonValueParentDeptId)!
                }
                if let jsonValueDeptStatus = jsonMap["deptStatus"] as? String {
                    resultDecodedBuilder.deptStatus = try Im.BaseDefine.DepartmentStatusType.fromString(jsonValueDeptStatus)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.DepartInfo.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.DepartInfo.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class PushShieldStatus : GeneratedMessage {
        public typealias BuilderType = Im.BaseDefine.PushShieldStatus.Builder

        public static func == (lhs: Im.BaseDefine.PushShieldStatus, rhs: Im.BaseDefine.PushShieldStatus) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasShieldStatus == rhs.hasShieldStatus) && (!lhs.hasShieldStatus || lhs.shieldStatus == rhs.shieldStatus)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        ///1: shield  0: not shield
        public fileprivate(set) var shieldStatus:UInt32! = nil
        public fileprivate(set) var hasShieldStatus:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasShieldStatus {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasShieldStatus {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:shieldStatus)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasShieldStatus {
                serialize_size += shieldStatus.computeUInt32Size(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.BaseDefine.PushShieldStatus.Builder {
            return Im.BaseDefine.PushShieldStatus.classBuilder() as! Im.BaseDefine.PushShieldStatus.Builder
        }
        public func getBuilder() -> Im.BaseDefine.PushShieldStatus.Builder {
            return classBuilder() as! Im.BaseDefine.PushShieldStatus.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.PushShieldStatus.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.BaseDefine.PushShieldStatus.Builder()
        }
        public func toBuilder() throws -> Im.BaseDefine.PushShieldStatus.Builder {
            return try Im.BaseDefine.PushShieldStatus.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.BaseDefine.PushShieldStatus) throws -> Im.BaseDefine.PushShieldStatus.Builder {
            return try Im.BaseDefine.PushShieldStatus.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasShieldStatus {
                jsonMap["shieldStatus"] = UInt(shieldStatus)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.PushShieldStatus {
            return try Im.BaseDefine.PushShieldStatus.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.BaseDefine.PushShieldStatus {
            return try Im.BaseDefine.PushShieldStatus.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasShieldStatus {
                output += "\(indent) shieldStatus: \(shieldStatus) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasShieldStatus {
                    hashCode = (hashCode &* 31) &+ shieldStatus.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.BaseDefine.PushShieldStatus"
        }
        override public func className() -> String {
            return "Im.BaseDefine.PushShieldStatus"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.BaseDefine.PushShieldStatus = Im.BaseDefine.PushShieldStatus()
            public func getMessage() -> Im.BaseDefine.PushShieldStatus {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.BaseDefine.PushShieldStatus.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.BaseDefine.PushShieldStatus.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            ///1: shield  0: not shield
            public var shieldStatus:UInt32 {
                get {
                    return builderResult.shieldStatus
                }
                set (value) {
                    builderResult.hasShieldStatus = true
                    builderResult.shieldStatus = value
                }
            }
            public var hasShieldStatus:Bool {
                get {
                    return builderResult.hasShieldStatus
                }
            }
            @discardableResult
            public func setShieldStatus(_ value:UInt32) -> Im.BaseDefine.PushShieldStatus.Builder {
                self.shieldStatus = value
                return self
            }
            @discardableResult
            public func clearShieldStatus() -> Im.BaseDefine.PushShieldStatus.Builder{
                builderResult.hasShieldStatus = false
                builderResult.shieldStatus = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.BaseDefine.PushShieldStatus.Builder {
                builderResult = Im.BaseDefine.PushShieldStatus()
                return self
            }
            override public func clone() throws -> Im.BaseDefine.PushShieldStatus.Builder {
                return try Im.BaseDefine.PushShieldStatus.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.BaseDefine.PushShieldStatus {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.BaseDefine.PushShieldStatus {
                let returnMe:Im.BaseDefine.PushShieldStatus = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.BaseDefine.PushShieldStatus) throws -> Im.BaseDefine.PushShieldStatus.Builder {
                if other == Im.BaseDefine.PushShieldStatus() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasShieldStatus {
                    shieldStatus = other.shieldStatus
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.PushShieldStatus.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.PushShieldStatus.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        shieldStatus = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.BaseDefine.PushShieldStatus.Builder {
                let resultDecodedBuilder = Im.BaseDefine.PushShieldStatus.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? UInt {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)
                } else if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? String {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.BaseDefine.PushShieldStatus.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.BaseDefine.PushShieldStatus.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Im.BaseDefine.IpAddr: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.IpAddr> {
        var mergedArray = Array<Im.BaseDefine.IpAddr>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.IpAddr? {
        return try Im.BaseDefine.IpAddr.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.IpAddr {
        return try Im.BaseDefine.IpAddr.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.IpAddr {
        return try Im.BaseDefine.IpAddr.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.IpAddr {
        return try Im.BaseDefine.IpAddr.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.IpAddr {
        return try Im.BaseDefine.IpAddr.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.IpAddr {
        return try Im.BaseDefine.IpAddr.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.IpAddr {
        return try Im.BaseDefine.IpAddr.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "ip": return self.ip
        case "port": return self.port
        default: return nil
        }
    }
}
extension Im.BaseDefine.IpAddr.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.IpAddr
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "ip": return self.ip
            case "port": return self.port
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "ip":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.ip = newSubscriptValue
            case "port":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.port = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.UserInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.UserInfo> {
        var mergedArray = Array<Im.BaseDefine.UserInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.UserInfo? {
        return try Im.BaseDefine.UserInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.UserInfo {
        return try Im.BaseDefine.UserInfo.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UserInfo {
        return try Im.BaseDefine.UserInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.UserInfo {
        return try Im.BaseDefine.UserInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UserInfo {
        return try Im.BaseDefine.UserInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.UserInfo {
        return try Im.BaseDefine.UserInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UserInfo {
        return try Im.BaseDefine.UserInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "userGender": return self.userGender
        case "userNickName": return self.userNickName
        case "avatarUrl": return self.avatarUrl
        case "departmentId": return self.departmentId
        case "email": return self.email
        case "userRealName": return self.userRealName
        case "userTel": return self.userTel
        case "userDomain": return self.userDomain
        case "status": return self.status
        case "signInfo": return self.signInfo
        default: return nil
        }
    }
}
extension Im.BaseDefine.UserInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.UserInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "userGender": return self.userGender
            case "userNickName": return self.userNickName
            case "avatarUrl": return self.avatarUrl
            case "departmentId": return self.departmentId
            case "email": return self.email
            case "userRealName": return self.userRealName
            case "userTel": return self.userTel
            case "userDomain": return self.userDomain
            case "status": return self.status
            case "signInfo": return self.signInfo
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "userGender":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userGender = newSubscriptValue
            case "userNickName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userNickName = newSubscriptValue
            case "avatarUrl":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.avatarUrl = newSubscriptValue
            case "departmentId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.departmentId = newSubscriptValue
            case "email":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.email = newSubscriptValue
            case "userRealName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userRealName = newSubscriptValue
            case "userTel":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userTel = newSubscriptValue
            case "userDomain":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userDomain = newSubscriptValue
            case "status":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.status = newSubscriptValue
            case "signInfo":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.signInfo = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.ContactSessionInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.ContactSessionInfo> {
        var mergedArray = Array<Im.BaseDefine.ContactSessionInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.ContactSessionInfo? {
        return try Im.BaseDefine.ContactSessionInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.ContactSessionInfo {
        return try Im.BaseDefine.ContactSessionInfo.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.ContactSessionInfo {
        return try Im.BaseDefine.ContactSessionInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.ContactSessionInfo {
        return try Im.BaseDefine.ContactSessionInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.ContactSessionInfo {
        return try Im.BaseDefine.ContactSessionInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.ContactSessionInfo {
        return try Im.BaseDefine.ContactSessionInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.ContactSessionInfo {
        return try Im.BaseDefine.ContactSessionInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sessionId": return self.sessionId
        case "sessionType": return self.sessionType
        case "sessionStatus": return self.sessionStatus
        case "updatedTime": return self.updatedTime
        case "latestMsgId": return self.latestMsgId
        case "latestMsgData": return self.latestMsgData
        case "latestMsgType": return self.latestMsgType
        case "latestMsgFromUserId": return self.latestMsgFromUserId
        default: return nil
        }
    }
}
extension Im.BaseDefine.ContactSessionInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.ContactSessionInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sessionId": return self.sessionId
            case "sessionType": return self.sessionType
            case "sessionStatus": return self.sessionStatus
            case "updatedTime": return self.updatedTime
            case "latestMsgId": return self.latestMsgId
            case "latestMsgData": return self.latestMsgData
            case "latestMsgType": return self.latestMsgType
            case "latestMsgFromUserId": return self.latestMsgFromUserId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            case "sessionStatus":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionStatusType else {
                    return
                }
                self.sessionStatus = newSubscriptValue
            case "updatedTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.updatedTime = newSubscriptValue
            case "latestMsgId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.latestMsgId = newSubscriptValue
            case "latestMsgData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.latestMsgData = newSubscriptValue
            case "latestMsgType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.MsgType else {
                    return
                }
                self.latestMsgType = newSubscriptValue
            case "latestMsgFromUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.latestMsgFromUserId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.UserStat: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.UserStat> {
        var mergedArray = Array<Im.BaseDefine.UserStat>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.UserStat? {
        return try Im.BaseDefine.UserStat.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.UserStat {
        return try Im.BaseDefine.UserStat.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UserStat {
        return try Im.BaseDefine.UserStat.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.UserStat {
        return try Im.BaseDefine.UserStat.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UserStat {
        return try Im.BaseDefine.UserStat.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.UserStat {
        return try Im.BaseDefine.UserStat.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UserStat {
        return try Im.BaseDefine.UserStat.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "status": return self.status
        default: return nil
        }
    }
}
extension Im.BaseDefine.UserStat.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.UserStat
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "status": return self.status
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "status":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.UserStatType else {
                    return
                }
                self.status = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.ServerUserStat: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.ServerUserStat> {
        var mergedArray = Array<Im.BaseDefine.ServerUserStat>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.ServerUserStat? {
        return try Im.BaseDefine.ServerUserStat.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.ServerUserStat {
        return try Im.BaseDefine.ServerUserStat.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.ServerUserStat {
        return try Im.BaseDefine.ServerUserStat.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.ServerUserStat {
        return try Im.BaseDefine.ServerUserStat.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.ServerUserStat {
        return try Im.BaseDefine.ServerUserStat.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.ServerUserStat {
        return try Im.BaseDefine.ServerUserStat.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.ServerUserStat {
        return try Im.BaseDefine.ServerUserStat.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "status": return self.status
        case "clientType": return self.clientType
        default: return nil
        }
    }
}
extension Im.BaseDefine.ServerUserStat.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.ServerUserStat
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "status": return self.status
            case "clientType": return self.clientType
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "status":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.UserStatType else {
                    return
                }
                self.status = newSubscriptValue
            case "clientType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.ClientType else {
                    return
                }
                self.clientType = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.UnreadInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.UnreadInfo> {
        var mergedArray = Array<Im.BaseDefine.UnreadInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.UnreadInfo? {
        return try Im.BaseDefine.UnreadInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.UnreadInfo {
        return try Im.BaseDefine.UnreadInfo.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UnreadInfo {
        return try Im.BaseDefine.UnreadInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.UnreadInfo {
        return try Im.BaseDefine.UnreadInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UnreadInfo {
        return try Im.BaseDefine.UnreadInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.UnreadInfo {
        return try Im.BaseDefine.UnreadInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UnreadInfo {
        return try Im.BaseDefine.UnreadInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sessionId": return self.sessionId
        case "sessionType": return self.sessionType
        case "unreadCnt": return self.unreadCnt
        case "latestMsgId": return self.latestMsgId
        case "latestMsgData": return self.latestMsgData
        case "latestMsgType": return self.latestMsgType
        case "latestMsgFromUserId": return self.latestMsgFromUserId
        default: return nil
        }
    }
}
extension Im.BaseDefine.UnreadInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.UnreadInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sessionId": return self.sessionId
            case "sessionType": return self.sessionType
            case "unreadCnt": return self.unreadCnt
            case "latestMsgId": return self.latestMsgId
            case "latestMsgData": return self.latestMsgData
            case "latestMsgType": return self.latestMsgType
            case "latestMsgFromUserId": return self.latestMsgFromUserId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "sessionType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.SessionType else {
                    return
                }
                self.sessionType = newSubscriptValue
            case "unreadCnt":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.unreadCnt = newSubscriptValue
            case "latestMsgId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.latestMsgId = newSubscriptValue
            case "latestMsgData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.latestMsgData = newSubscriptValue
            case "latestMsgType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.MsgType else {
                    return
                }
                self.latestMsgType = newSubscriptValue
            case "latestMsgFromUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.latestMsgFromUserId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.MsgInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.MsgInfo> {
        var mergedArray = Array<Im.BaseDefine.MsgInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.MsgInfo? {
        return try Im.BaseDefine.MsgInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.MsgInfo {
        return try Im.BaseDefine.MsgInfo.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.MsgInfo {
        return try Im.BaseDefine.MsgInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.MsgInfo {
        return try Im.BaseDefine.MsgInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.MsgInfo {
        return try Im.BaseDefine.MsgInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.MsgInfo {
        return try Im.BaseDefine.MsgInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.MsgInfo {
        return try Im.BaseDefine.MsgInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "msgId": return self.msgId
        case "fromSessionId": return self.fromSessionId
        case "createTime": return self.createTime
        case "msgType": return self.msgType
        case "msgData": return self.msgData
        default: return nil
        }
    }
}
extension Im.BaseDefine.MsgInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.MsgInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "msgId": return self.msgId
            case "fromSessionId": return self.fromSessionId
            case "createTime": return self.createTime
            case "msgType": return self.msgType
            case "msgData": return self.msgData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "msgId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.msgId = newSubscriptValue
            case "fromSessionId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fromSessionId = newSubscriptValue
            case "createTime":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.createTime = newSubscriptValue
            case "msgType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.MsgType else {
                    return
                }
                self.msgType = newSubscriptValue
            case "msgData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.msgData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.GroupVersionInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.GroupVersionInfo> {
        var mergedArray = Array<Im.BaseDefine.GroupVersionInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.GroupVersionInfo? {
        return try Im.BaseDefine.GroupVersionInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.GroupVersionInfo {
        return try Im.BaseDefine.GroupVersionInfo.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.GroupVersionInfo {
        return try Im.BaseDefine.GroupVersionInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.GroupVersionInfo {
        return try Im.BaseDefine.GroupVersionInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.GroupVersionInfo {
        return try Im.BaseDefine.GroupVersionInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.GroupVersionInfo {
        return try Im.BaseDefine.GroupVersionInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.GroupVersionInfo {
        return try Im.BaseDefine.GroupVersionInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        case "version": return self.version
        default: return nil
        }
    }
}
extension Im.BaseDefine.GroupVersionInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.GroupVersionInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            case "version": return self.version
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.groupId = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.version = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.GroupInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.GroupInfo> {
        var mergedArray = Array<Im.BaseDefine.GroupInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.GroupInfo? {
        return try Im.BaseDefine.GroupInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.GroupInfo {
        return try Im.BaseDefine.GroupInfo.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.GroupInfo {
        return try Im.BaseDefine.GroupInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.GroupInfo {
        return try Im.BaseDefine.GroupInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.GroupInfo {
        return try Im.BaseDefine.GroupInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.GroupInfo {
        return try Im.BaseDefine.GroupInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.GroupInfo {
        return try Im.BaseDefine.GroupInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "groupId": return self.groupId
        case "version": return self.version
        case "groupName": return self.groupName
        case "groupAvatar": return self.groupAvatar
        case "groupCreatorId": return self.groupCreatorId
        case "groupType": return self.groupType
        case "shieldStatus": return self.shieldStatus
        case "groupMemberList": return self.groupMemberList
        default: return nil
        }
    }
}
extension Im.BaseDefine.GroupInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.GroupInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "groupId": return self.groupId
            case "version": return self.version
            case "groupName": return self.groupName
            case "groupAvatar": return self.groupAvatar
            case "groupCreatorId": return self.groupCreatorId
            case "groupType": return self.groupType
            case "shieldStatus": return self.shieldStatus
            case "groupMemberList": return self.groupMemberList
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.groupId = newSubscriptValue
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.version = newSubscriptValue
            case "groupName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupName = newSubscriptValue
            case "groupAvatar":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupAvatar = newSubscriptValue
            case "groupCreatorId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.groupCreatorId = newSubscriptValue
            case "groupType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.GroupType else {
                    return
                }
                self.groupType = newSubscriptValue
            case "shieldStatus":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.shieldStatus = newSubscriptValue
            case "groupMemberList":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.groupMemberList = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.UserTokenInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.UserTokenInfo> {
        var mergedArray = Array<Im.BaseDefine.UserTokenInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.UserTokenInfo? {
        return try Im.BaseDefine.UserTokenInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.UserTokenInfo {
        return try Im.BaseDefine.UserTokenInfo.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UserTokenInfo {
        return try Im.BaseDefine.UserTokenInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.UserTokenInfo {
        return try Im.BaseDefine.UserTokenInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UserTokenInfo {
        return try Im.BaseDefine.UserTokenInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.UserTokenInfo {
        return try Im.BaseDefine.UserTokenInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.UserTokenInfo {
        return try Im.BaseDefine.UserTokenInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "userType": return self.userType
        case "token": return self.token
        case "pushCount": return self.pushCount
        case "pushType": return self.pushType
        default: return nil
        }
    }
}
extension Im.BaseDefine.UserTokenInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.UserTokenInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "userType": return self.userType
            case "token": return self.token
            case "pushCount": return self.pushCount
            case "pushType": return self.pushType
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "userType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.ClientType else {
                    return
                }
                self.userType = newSubscriptValue
            case "token":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.token = newSubscriptValue
            case "pushCount":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.pushCount = newSubscriptValue
            case "pushType":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.pushType = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.PushResult: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.PushResult> {
        var mergedArray = Array<Im.BaseDefine.PushResult>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.PushResult? {
        return try Im.BaseDefine.PushResult.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.PushResult {
        return try Im.BaseDefine.PushResult.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.PushResult {
        return try Im.BaseDefine.PushResult.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.PushResult {
        return try Im.BaseDefine.PushResult.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.PushResult {
        return try Im.BaseDefine.PushResult.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.PushResult {
        return try Im.BaseDefine.PushResult.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.PushResult {
        return try Im.BaseDefine.PushResult.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userToken": return self.userToken
        case "resultCode": return self.resultCode
        default: return nil
        }
    }
}
extension Im.BaseDefine.PushResult.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.PushResult
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userToken": return self.userToken
            case "resultCode": return self.resultCode
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userToken":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.userToken = newSubscriptValue
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.ShieldStatus: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.ShieldStatus> {
        var mergedArray = Array<Im.BaseDefine.ShieldStatus>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.ShieldStatus? {
        return try Im.BaseDefine.ShieldStatus.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.ShieldStatus {
        return try Im.BaseDefine.ShieldStatus.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.ShieldStatus {
        return try Im.BaseDefine.ShieldStatus.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.ShieldStatus {
        return try Im.BaseDefine.ShieldStatus.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.ShieldStatus {
        return try Im.BaseDefine.ShieldStatus.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.ShieldStatus {
        return try Im.BaseDefine.ShieldStatus.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.ShieldStatus {
        return try Im.BaseDefine.ShieldStatus.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "groupId": return self.groupId
        case "shieldStatus": return self.shieldStatus
        default: return nil
        }
    }
}
extension Im.BaseDefine.ShieldStatus.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.ShieldStatus
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "groupId": return self.groupId
            case "shieldStatus": return self.shieldStatus
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.groupId = newSubscriptValue
            case "shieldStatus":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.shieldStatus = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.OfflineFileInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.OfflineFileInfo> {
        var mergedArray = Array<Im.BaseDefine.OfflineFileInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.OfflineFileInfo? {
        return try Im.BaseDefine.OfflineFileInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.OfflineFileInfo {
        return try Im.BaseDefine.OfflineFileInfo.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.OfflineFileInfo {
        return try Im.BaseDefine.OfflineFileInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.OfflineFileInfo {
        return try Im.BaseDefine.OfflineFileInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.OfflineFileInfo {
        return try Im.BaseDefine.OfflineFileInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.OfflineFileInfo {
        return try Im.BaseDefine.OfflineFileInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.OfflineFileInfo {
        return try Im.BaseDefine.OfflineFileInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "fromUserId": return self.fromUserId
        case "taskId": return self.taskId
        case "fileName": return self.fileName
        case "fileSize": return self.fileSize
        default: return nil
        }
    }
}
extension Im.BaseDefine.OfflineFileInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.OfflineFileInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "fromUserId": return self.fromUserId
            case "taskId": return self.taskId
            case "fileName": return self.fileName
            case "fileSize": return self.fileSize
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "fromUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fromUserId = newSubscriptValue
            case "taskId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.taskId = newSubscriptValue
            case "fileName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fileName = newSubscriptValue
            case "fileSize":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fileSize = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.DepartInfo: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.DepartInfo> {
        var mergedArray = Array<Im.BaseDefine.DepartInfo>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.DepartInfo? {
        return try Im.BaseDefine.DepartInfo.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.DepartInfo {
        return try Im.BaseDefine.DepartInfo.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.DepartInfo {
        return try Im.BaseDefine.DepartInfo.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.DepartInfo {
        return try Im.BaseDefine.DepartInfo.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.DepartInfo {
        return try Im.BaseDefine.DepartInfo.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.DepartInfo {
        return try Im.BaseDefine.DepartInfo.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.DepartInfo {
        return try Im.BaseDefine.DepartInfo.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "deptId": return self.deptId
        case "priority": return self.priority
        case "deptName": return self.deptName
        case "parentDeptId": return self.parentDeptId
        case "deptStatus": return self.deptStatus
        default: return nil
        }
    }
}
extension Im.BaseDefine.DepartInfo.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.DepartInfo
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "deptId": return self.deptId
            case "priority": return self.priority
            case "deptName": return self.deptName
            case "parentDeptId": return self.parentDeptId
            case "deptStatus": return self.deptStatus
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "deptId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.deptId = newSubscriptValue
            case "priority":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.priority = newSubscriptValue
            case "deptName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.deptName = newSubscriptValue
            case "parentDeptId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.parentDeptId = newSubscriptValue
            case "deptStatus":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.DepartmentStatusType else {
                    return
                }
                self.deptStatus = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.BaseDefine.PushShieldStatus: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.BaseDefine.PushShieldStatus> {
        var mergedArray = Array<Im.BaseDefine.PushShieldStatus>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.BaseDefine.PushShieldStatus? {
        return try Im.BaseDefine.PushShieldStatus.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.BaseDefine.PushShieldStatus {
        return try Im.BaseDefine.PushShieldStatus.Builder().mergeFrom(data: data, extensionRegistry:Im.BaseDefine.ImbaseDefineRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.PushShieldStatus {
        return try Im.BaseDefine.PushShieldStatus.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.BaseDefine.PushShieldStatus {
        return try Im.BaseDefine.PushShieldStatus.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.PushShieldStatus {
        return try Im.BaseDefine.PushShieldStatus.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.BaseDefine.PushShieldStatus {
        return try Im.BaseDefine.PushShieldStatus.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.BaseDefine.PushShieldStatus {
        return try Im.BaseDefine.PushShieldStatus.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "shieldStatus": return self.shieldStatus
        default: return nil
        }
    }
}
extension Im.BaseDefine.PushShieldStatus.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.BaseDefine.PushShieldStatus
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "shieldStatus": return self.shieldStatus
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "shieldStatus":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.shieldStatus = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
