/// Generated by the Protocol Buffers 3.3.2 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "IM.File.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers

public extension Im {
    public struct File {}
}

public extension Im.File {
    public struct ImfileRoot {
        public static let `default` = ImfileRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Im.BaseDefine.ImbaseDefineRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class ImfileLoginReq : GeneratedMessage {
        public typealias BuilderType = Im.File.ImfileLoginReq.Builder

        public static func == (lhs: Im.File.ImfileLoginReq, rhs: Im.File.ImfileLoginReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasTaskId == rhs.hasTaskId) && (!lhs.hasTaskId || lhs.taskId == rhs.taskId)
            fieldCheck = fieldCheck && (lhs.hasFileRole == rhs.hasFileRole) && (!lhs.hasFileRole || lhs.fileRole == rhs.fileRole)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x0501
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var taskId:String! = nil
        public fileprivate(set) var hasTaskId:Bool = false

        public fileprivate(set) var fileRole:Im.BaseDefine.ClientFileRole = Im.BaseDefine.ClientFileRole.clientRealtimeSender
        public fileprivate(set) var hasFileRole:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasTaskId {
                return false
            }
            if !hasFileRole {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasTaskId {
                try codedOutputStream.writeString(fieldNumber: 2, value:taskId)
            }
            if hasFileRole {
                try codedOutputStream.writeEnum(fieldNumber: 3, value:fileRole.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasTaskId {
                serialize_size += taskId.computeStringSize(fieldNumber: 2)
            }
            if (hasFileRole) {
                serialize_size += fileRole.rawValue.computeEnumSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.File.ImfileLoginReq.Builder {
            return Im.File.ImfileLoginReq.classBuilder() as! Im.File.ImfileLoginReq.Builder
        }
        public func getBuilder() -> Im.File.ImfileLoginReq.Builder {
            return classBuilder() as! Im.File.ImfileLoginReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileLoginReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileLoginReq.Builder()
        }
        public func toBuilder() throws -> Im.File.ImfileLoginReq.Builder {
            return try Im.File.ImfileLoginReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.File.ImfileLoginReq) throws -> Im.File.ImfileLoginReq.Builder {
            return try Im.File.ImfileLoginReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasTaskId {
                jsonMap["taskId"] = taskId
            }
            if hasFileRole {
                jsonMap["fileRole"] = fileRole.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileLoginReq {
            return try Im.File.ImfileLoginReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.File.ImfileLoginReq {
            return try Im.File.ImfileLoginReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasTaskId {
                output += "\(indent) taskId: \(taskId) \n"
            }
            if (hasFileRole) {
                output += "\(indent) fileRole: \(fileRole.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasTaskId {
                    hashCode = (hashCode &* 31) &+ taskId.hashValue
                }
                if hasFileRole {
                     hashCode = (hashCode &* 31) &+ fileRole.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.File.ImfileLoginReq"
        }
        override public func className() -> String {
            return "Im.File.ImfileLoginReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.File.ImfileLoginReq = Im.File.ImfileLoginReq()
            public func getMessage() -> Im.File.ImfileLoginReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x0501
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.File.ImfileLoginReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.File.ImfileLoginReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var taskId:String {
                get {
                    return builderResult.taskId
                }
                set (value) {
                    builderResult.hasTaskId = true
                    builderResult.taskId = value
                }
            }
            public var hasTaskId:Bool {
                get {
                    return builderResult.hasTaskId
                }
            }
            @discardableResult
            public func setTaskId(_ value:String) -> Im.File.ImfileLoginReq.Builder {
                self.taskId = value
                return self
            }
            @discardableResult
            public func clearTaskId() -> Im.File.ImfileLoginReq.Builder{
                builderResult.hasTaskId = false
                builderResult.taskId = nil
                return self
            }
                public var fileRole:Im.BaseDefine.ClientFileRole {
                    get {
                        return builderResult.fileRole
                    }
                    set (value) {
                        builderResult.hasFileRole = true
                        builderResult.fileRole = value
                    }
                }
                public var hasFileRole:Bool{
                    get {
                        return builderResult.hasFileRole
                    }
                }
            @discardableResult
                public func setFileRole(_ value:Im.BaseDefine.ClientFileRole) -> Im.File.ImfileLoginReq.Builder {
                  self.fileRole = value
                  return self
                }
            @discardableResult
                public func clearFileRole() -> Im.File.ImfileLoginReq.Builder {
                   builderResult.hasFileRole = false
                   builderResult.fileRole = .clientRealtimeSender
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.File.ImfileLoginReq.Builder {
                builderResult = Im.File.ImfileLoginReq()
                return self
            }
            override public func clone() throws -> Im.File.ImfileLoginReq.Builder {
                return try Im.File.ImfileLoginReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.File.ImfileLoginReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.File.ImfileLoginReq {
                let returnMe:Im.File.ImfileLoginReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.File.ImfileLoginReq) throws -> Im.File.ImfileLoginReq.Builder {
                if other == Im.File.ImfileLoginReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasTaskId {
                    taskId = other.taskId
                }
                if other.hasFileRole {
                    fileRole = other.fileRole
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileLoginReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileLoginReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 18:
                        taskId = try codedInputStream.readString()

                    case 24:
                        let valueIntfileRole = try codedInputStream.readEnum()
                        if let enumsfileRole = Im.BaseDefine.ClientFileRole(rawValue:valueIntfileRole){
                            fileRole = enumsfileRole
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntfileRole))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileLoginReq.Builder {
                let resultDecodedBuilder = Im.File.ImfileLoginReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueTaskId = jsonMap["taskId"] as? String {
                    resultDecodedBuilder.taskId = jsonValueTaskId
                }
                if let jsonValueFileRole = jsonMap["fileRole"] as? String {
                    resultDecodedBuilder.fileRole = try Im.BaseDefine.ClientFileRole.fromString(jsonValueFileRole)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.File.ImfileLoginReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.File.ImfileLoginReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfileLoginRsp : GeneratedMessage {
        public typealias BuilderType = Im.File.ImfileLoginRsp.Builder

        public static func == (lhs: Im.File.ImfileLoginRsp, rhs: Im.File.ImfileLoginRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasTaskId == rhs.hasTaskId) && (!lhs.hasTaskId || lhs.taskId == rhs.taskId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x0502
        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        public fileprivate(set) var taskId:String! = nil
        public fileprivate(set) var hasTaskId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasResultCode {
                return false
            }
            if !hasTaskId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:resultCode)
            }
            if hasTaskId {
                try codedOutputStream.writeString(fieldNumber: 2, value:taskId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 1)
            }
            if hasTaskId {
                serialize_size += taskId.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.File.ImfileLoginRsp.Builder {
            return Im.File.ImfileLoginRsp.classBuilder() as! Im.File.ImfileLoginRsp.Builder
        }
        public func getBuilder() -> Im.File.ImfileLoginRsp.Builder {
            return classBuilder() as! Im.File.ImfileLoginRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileLoginRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileLoginRsp.Builder()
        }
        public func toBuilder() throws -> Im.File.ImfileLoginRsp.Builder {
            return try Im.File.ImfileLoginRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.File.ImfileLoginRsp) throws -> Im.File.ImfileLoginRsp.Builder {
            return try Im.File.ImfileLoginRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            if hasTaskId {
                jsonMap["taskId"] = taskId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileLoginRsp {
            return try Im.File.ImfileLoginRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.File.ImfileLoginRsp {
            return try Im.File.ImfileLoginRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            if hasTaskId {
                output += "\(indent) taskId: \(taskId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasTaskId {
                    hashCode = (hashCode &* 31) &+ taskId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.File.ImfileLoginRsp"
        }
        override public func className() -> String {
            return "Im.File.ImfileLoginRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.File.ImfileLoginRsp = Im.File.ImfileLoginRsp()
            public func getMessage() -> Im.File.ImfileLoginRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x0502
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.File.ImfileLoginRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.File.ImfileLoginRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            public var taskId:String {
                get {
                    return builderResult.taskId
                }
                set (value) {
                    builderResult.hasTaskId = true
                    builderResult.taskId = value
                }
            }
            public var hasTaskId:Bool {
                get {
                    return builderResult.hasTaskId
                }
            }
            @discardableResult
            public func setTaskId(_ value:String) -> Im.File.ImfileLoginRsp.Builder {
                self.taskId = value
                return self
            }
            @discardableResult
            public func clearTaskId() -> Im.File.ImfileLoginRsp.Builder{
                builderResult.hasTaskId = false
                builderResult.taskId = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.File.ImfileLoginRsp.Builder {
                builderResult = Im.File.ImfileLoginRsp()
                return self
            }
            override public func clone() throws -> Im.File.ImfileLoginRsp.Builder {
                return try Im.File.ImfileLoginRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.File.ImfileLoginRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.File.ImfileLoginRsp {
                let returnMe:Im.File.ImfileLoginRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.File.ImfileLoginRsp) throws -> Im.File.ImfileLoginRsp.Builder {
                if other == Im.File.ImfileLoginRsp() {
                    return self
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasTaskId {
                    taskId = other.taskId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileLoginRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileLoginRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        resultCode = try codedInputStream.readUInt32()

                    case 18:
                        taskId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileLoginRsp.Builder {
                let resultDecodedBuilder = Im.File.ImfileLoginRsp.Builder()
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                if let jsonValueTaskId = jsonMap["taskId"] as? String {
                    resultDecodedBuilder.taskId = jsonValueTaskId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.File.ImfileLoginRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.File.ImfileLoginRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfileState : GeneratedMessage {
        public typealias BuilderType = Im.File.ImfileState.Builder

        public static func == (lhs: Im.File.ImfileState, rhs: Im.File.ImfileState) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasState == rhs.hasState) && (!lhs.hasState || lhs.state == rhs.state)
            fieldCheck = fieldCheck && (lhs.hasTaskId == rhs.hasTaskId) && (!lhs.hasTaskId || lhs.taskId == rhs.taskId)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var state:Im.BaseDefine.ClientFileState = Im.BaseDefine.ClientFileState.clientFilePeerReady
        public fileprivate(set) var hasState:Bool = false
        public fileprivate(set) var taskId:String! = nil
        public fileprivate(set) var hasTaskId:Bool = false

        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasState {
                return false
            }
            if !hasTaskId {
                return false
            }
            if !hasUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasState {
                try codedOutputStream.writeEnum(fieldNumber: 1, value:state.rawValue)
            }
            if hasTaskId {
                try codedOutputStream.writeString(fieldNumber: 2, value:taskId)
            }
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:userId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if (hasState) {
                serialize_size += state.rawValue.computeEnumSize(fieldNumber: 1)
            }
            if hasTaskId {
                serialize_size += taskId.computeStringSize(fieldNumber: 2)
            }
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.File.ImfileState.Builder {
            return Im.File.ImfileState.classBuilder() as! Im.File.ImfileState.Builder
        }
        public func getBuilder() -> Im.File.ImfileState.Builder {
            return classBuilder() as! Im.File.ImfileState.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileState.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileState.Builder()
        }
        public func toBuilder() throws -> Im.File.ImfileState.Builder {
            return try Im.File.ImfileState.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.File.ImfileState) throws -> Im.File.ImfileState.Builder {
            return try Im.File.ImfileState.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasState {
                jsonMap["state"] = state.toString()
            }
            if hasTaskId {
                jsonMap["taskId"] = taskId
            }
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileState {
            return try Im.File.ImfileState.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.File.ImfileState {
            return try Im.File.ImfileState.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if (hasState) {
                output += "\(indent) state: \(state.description)\n"
            }
            if hasTaskId {
                output += "\(indent) taskId: \(taskId) \n"
            }
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasState {
                     hashCode = (hashCode &* 31) &+ state.hashValue
                }
                if hasTaskId {
                    hashCode = (hashCode &* 31) &+ taskId.hashValue
                }
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.File.ImfileState"
        }
        override public func className() -> String {
            return "Im.File.ImfileState"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.File.ImfileState = Im.File.ImfileState()
            public func getMessage() -> Im.File.ImfileState {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 	0x0503
                public var state:Im.BaseDefine.ClientFileState {
                    get {
                        return builderResult.state
                    }
                    set (value) {
                        builderResult.hasState = true
                        builderResult.state = value
                    }
                }
                public var hasState:Bool{
                    get {
                        return builderResult.hasState
                    }
                }
            @discardableResult
                public func setState(_ value:Im.BaseDefine.ClientFileState) -> Im.File.ImfileState.Builder {
                  self.state = value
                  return self
                }
            @discardableResult
                public func clearState() -> Im.File.ImfileState.Builder {
                   builderResult.hasState = false
                   builderResult.state = .clientFilePeerReady
                   return self
                }
            public var taskId:String {
                get {
                    return builderResult.taskId
                }
                set (value) {
                    builderResult.hasTaskId = true
                    builderResult.taskId = value
                }
            }
            public var hasTaskId:Bool {
                get {
                    return builderResult.hasTaskId
                }
            }
            @discardableResult
            public func setTaskId(_ value:String) -> Im.File.ImfileState.Builder {
                self.taskId = value
                return self
            }
            @discardableResult
            public func clearTaskId() -> Im.File.ImfileState.Builder{
                builderResult.hasTaskId = false
                builderResult.taskId = nil
                return self
            }
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.File.ImfileState.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.File.ImfileState.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.File.ImfileState.Builder {
                builderResult = Im.File.ImfileState()
                return self
            }
            override public func clone() throws -> Im.File.ImfileState.Builder {
                return try Im.File.ImfileState.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.File.ImfileState {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.File.ImfileState {
                let returnMe:Im.File.ImfileState = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.File.ImfileState) throws -> Im.File.ImfileState.Builder {
                if other == Im.File.ImfileState() {
                    return self
                }
                if other.hasState {
                    state = other.state
                }
                if other.hasTaskId {
                    taskId = other.taskId
                }
                if other.hasUserId {
                    userId = other.userId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileState.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileState.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        let valueIntstate = try codedInputStream.readEnum()
                        if let enumsstate = Im.BaseDefine.ClientFileState(rawValue:valueIntstate){
                            state = enumsstate
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntstate))
                        }

                    case 18:
                        taskId = try codedInputStream.readString()

                    case 24:
                        userId = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileState.Builder {
                let resultDecodedBuilder = Im.File.ImfileState.Builder()
                if let jsonValueState = jsonMap["state"] as? String {
                    resultDecodedBuilder.state = try Im.BaseDefine.ClientFileState.fromString(jsonValueState)
                }
                if let jsonValueTaskId = jsonMap["taskId"] as? String {
                    resultDecodedBuilder.taskId = jsonValueTaskId
                }
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.File.ImfileState.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.File.ImfileState.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfilePullDataReq : GeneratedMessage {
        public typealias BuilderType = Im.File.ImfilePullDataReq.Builder

        public static func == (lhs: Im.File.ImfilePullDataReq, rhs: Im.File.ImfilePullDataReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasTaskId == rhs.hasTaskId) && (!lhs.hasTaskId || lhs.taskId == rhs.taskId)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasTransMode == rhs.hasTransMode) && (!lhs.hasTransMode || lhs.transMode == rhs.transMode)
            fieldCheck = fieldCheck && (lhs.hasOffset == rhs.hasOffset) && (!lhs.hasOffset || lhs.offset == rhs.offset)
            fieldCheck = fieldCheck && (lhs.hasDataSize == rhs.hasDataSize) && (!lhs.hasDataSize || lhs.dataSize == rhs.dataSize)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x0504
        public fileprivate(set) var taskId:String! = nil
        public fileprivate(set) var hasTaskId:Bool = false

        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var transMode:Im.BaseDefine.TransferFileType = Im.BaseDefine.TransferFileType.fileTypeOnline
        public fileprivate(set) var hasTransMode:Bool = false
        public fileprivate(set) var offset:UInt32! = nil
        public fileprivate(set) var hasOffset:Bool = false

        public fileprivate(set) var dataSize:UInt32! = nil
        public fileprivate(set) var hasDataSize:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasTaskId {
                return false
            }
            if !hasUserId {
                return false
            }
            if !hasTransMode {
                return false
            }
            if !hasOffset {
                return false
            }
            if !hasDataSize {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasTaskId {
                try codedOutputStream.writeString(fieldNumber: 1, value:taskId)
            }
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:userId)
            }
            if hasTransMode {
                try codedOutputStream.writeEnum(fieldNumber: 3, value:transMode.rawValue)
            }
            if hasOffset {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:offset)
            }
            if hasDataSize {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:dataSize)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasTaskId {
                serialize_size += taskId.computeStringSize(fieldNumber: 1)
            }
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 2)
            }
            if (hasTransMode) {
                serialize_size += transMode.rawValue.computeEnumSize(fieldNumber: 3)
            }
            if hasOffset {
                serialize_size += offset.computeUInt32Size(fieldNumber: 4)
            }
            if hasDataSize {
                serialize_size += dataSize.computeUInt32Size(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.File.ImfilePullDataReq.Builder {
            return Im.File.ImfilePullDataReq.classBuilder() as! Im.File.ImfilePullDataReq.Builder
        }
        public func getBuilder() -> Im.File.ImfilePullDataReq.Builder {
            return classBuilder() as! Im.File.ImfilePullDataReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfilePullDataReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfilePullDataReq.Builder()
        }
        public func toBuilder() throws -> Im.File.ImfilePullDataReq.Builder {
            return try Im.File.ImfilePullDataReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.File.ImfilePullDataReq) throws -> Im.File.ImfilePullDataReq.Builder {
            return try Im.File.ImfilePullDataReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasTaskId {
                jsonMap["taskId"] = taskId
            }
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasTransMode {
                jsonMap["transMode"] = transMode.toString()
            }
            if hasOffset {
                jsonMap["offset"] = UInt(offset)
            }
            if hasDataSize {
                jsonMap["dataSize"] = UInt(dataSize)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfilePullDataReq {
            return try Im.File.ImfilePullDataReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.File.ImfilePullDataReq {
            return try Im.File.ImfilePullDataReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasTaskId {
                output += "\(indent) taskId: \(taskId) \n"
            }
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasTransMode) {
                output += "\(indent) transMode: \(transMode.description)\n"
            }
            if hasOffset {
                output += "\(indent) offset: \(offset) \n"
            }
            if hasDataSize {
                output += "\(indent) dataSize: \(dataSize) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTaskId {
                    hashCode = (hashCode &* 31) &+ taskId.hashValue
                }
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasTransMode {
                     hashCode = (hashCode &* 31) &+ transMode.hashValue
                }
                if hasOffset {
                    hashCode = (hashCode &* 31) &+ offset.hashValue
                }
                if hasDataSize {
                    hashCode = (hashCode &* 31) &+ dataSize.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.File.ImfilePullDataReq"
        }
        override public func className() -> String {
            return "Im.File.ImfilePullDataReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.File.ImfilePullDataReq = Im.File.ImfilePullDataReq()
            public func getMessage() -> Im.File.ImfilePullDataReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x0504
            public var taskId:String {
                get {
                    return builderResult.taskId
                }
                set (value) {
                    builderResult.hasTaskId = true
                    builderResult.taskId = value
                }
            }
            public var hasTaskId:Bool {
                get {
                    return builderResult.hasTaskId
                }
            }
            @discardableResult
            public func setTaskId(_ value:String) -> Im.File.ImfilePullDataReq.Builder {
                self.taskId = value
                return self
            }
            @discardableResult
            public func clearTaskId() -> Im.File.ImfilePullDataReq.Builder{
                builderResult.hasTaskId = false
                builderResult.taskId = nil
                return self
            }
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.File.ImfilePullDataReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.File.ImfilePullDataReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var transMode:Im.BaseDefine.TransferFileType {
                    get {
                        return builderResult.transMode
                    }
                    set (value) {
                        builderResult.hasTransMode = true
                        builderResult.transMode = value
                    }
                }
                public var hasTransMode:Bool{
                    get {
                        return builderResult.hasTransMode
                    }
                }
            @discardableResult
                public func setTransMode(_ value:Im.BaseDefine.TransferFileType) -> Im.File.ImfilePullDataReq.Builder {
                  self.transMode = value
                  return self
                }
            @discardableResult
                public func clearTransMode() -> Im.File.ImfilePullDataReq.Builder {
                   builderResult.hasTransMode = false
                   builderResult.transMode = .fileTypeOnline
                   return self
                }
            public var offset:UInt32 {
                get {
                    return builderResult.offset
                }
                set (value) {
                    builderResult.hasOffset = true
                    builderResult.offset = value
                }
            }
            public var hasOffset:Bool {
                get {
                    return builderResult.hasOffset
                }
            }
            @discardableResult
            public func setOffset(_ value:UInt32) -> Im.File.ImfilePullDataReq.Builder {
                self.offset = value
                return self
            }
            @discardableResult
            public func clearOffset() -> Im.File.ImfilePullDataReq.Builder{
                builderResult.hasOffset = false
                builderResult.offset = nil
                return self
            }
            public var dataSize:UInt32 {
                get {
                    return builderResult.dataSize
                }
                set (value) {
                    builderResult.hasDataSize = true
                    builderResult.dataSize = value
                }
            }
            public var hasDataSize:Bool {
                get {
                    return builderResult.hasDataSize
                }
            }
            @discardableResult
            public func setDataSize(_ value:UInt32) -> Im.File.ImfilePullDataReq.Builder {
                self.dataSize = value
                return self
            }
            @discardableResult
            public func clearDataSize() -> Im.File.ImfilePullDataReq.Builder{
                builderResult.hasDataSize = false
                builderResult.dataSize = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.File.ImfilePullDataReq.Builder {
                builderResult = Im.File.ImfilePullDataReq()
                return self
            }
            override public func clone() throws -> Im.File.ImfilePullDataReq.Builder {
                return try Im.File.ImfilePullDataReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.File.ImfilePullDataReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.File.ImfilePullDataReq {
                let returnMe:Im.File.ImfilePullDataReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.File.ImfilePullDataReq) throws -> Im.File.ImfilePullDataReq.Builder {
                if other == Im.File.ImfilePullDataReq() {
                    return self
                }
                if other.hasTaskId {
                    taskId = other.taskId
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasTransMode {
                    transMode = other.transMode
                }
                if other.hasOffset {
                    offset = other.offset
                }
                if other.hasDataSize {
                    dataSize = other.dataSize
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfilePullDataReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfilePullDataReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        taskId = try codedInputStream.readString()

                    case 16:
                        userId = try codedInputStream.readUInt32()

                    case 24:
                        let valueInttransMode = try codedInputStream.readEnum()
                        if let enumstransMode = Im.BaseDefine.TransferFileType(rawValue:valueInttransMode){
                            transMode = enumstransMode
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueInttransMode))
                        }

                    case 32:
                        offset = try codedInputStream.readUInt32()

                    case 40:
                        dataSize = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfilePullDataReq.Builder {
                let resultDecodedBuilder = Im.File.ImfilePullDataReq.Builder()
                if let jsonValueTaskId = jsonMap["taskId"] as? String {
                    resultDecodedBuilder.taskId = jsonValueTaskId
                }
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueTransMode = jsonMap["transMode"] as? String {
                    resultDecodedBuilder.transMode = try Im.BaseDefine.TransferFileType.fromString(jsonValueTransMode)
                }
                if let jsonValueOffset = jsonMap["offset"] as? UInt {
                    resultDecodedBuilder.offset = UInt32(jsonValueOffset)
                } else if let jsonValueOffset = jsonMap["offset"] as? String {
                    resultDecodedBuilder.offset = UInt32(jsonValueOffset)!
                }
                if let jsonValueDataSize = jsonMap["dataSize"] as? UInt {
                    resultDecodedBuilder.dataSize = UInt32(jsonValueDataSize)
                } else if let jsonValueDataSize = jsonMap["dataSize"] as? String {
                    resultDecodedBuilder.dataSize = UInt32(jsonValueDataSize)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.File.ImfilePullDataReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.File.ImfilePullDataReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfilePullDataRsp : GeneratedMessage {
        public typealias BuilderType = Im.File.ImfilePullDataRsp.Builder

        public static func == (lhs: Im.File.ImfilePullDataRsp, rhs: Im.File.ImfilePullDataRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasTaskId == rhs.hasTaskId) && (!lhs.hasTaskId || lhs.taskId == rhs.taskId)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasOffset == rhs.hasOffset) && (!lhs.hasOffset || lhs.offset == rhs.offset)
            fieldCheck = fieldCheck && (lhs.hasFileData == rhs.hasFileData) && (!lhs.hasFileData || lhs.fileData == rhs.fileData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id: 	0x0505
        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        public fileprivate(set) var taskId:String! = nil
        public fileprivate(set) var hasTaskId:Bool = false

        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var offset:UInt32! = nil
        public fileprivate(set) var hasOffset:Bool = false

        public fileprivate(set) var fileData:Data! = nil
        public fileprivate(set) var hasFileData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasResultCode {
                return false
            }
            if !hasTaskId {
                return false
            }
            if !hasUserId {
                return false
            }
            if !hasOffset {
                return false
            }
            if !hasFileData {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:resultCode)
            }
            if hasTaskId {
                try codedOutputStream.writeString(fieldNumber: 2, value:taskId)
            }
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:userId)
            }
            if hasOffset {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:offset)
            }
            if hasFileData {
                try codedOutputStream.writeData(fieldNumber: 5, value:fileData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 1)
            }
            if hasTaskId {
                serialize_size += taskId.computeStringSize(fieldNumber: 2)
            }
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 3)
            }
            if hasOffset {
                serialize_size += offset.computeUInt32Size(fieldNumber: 4)
            }
            if hasFileData {
                serialize_size += fileData.computeDataSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.File.ImfilePullDataRsp.Builder {
            return Im.File.ImfilePullDataRsp.classBuilder() as! Im.File.ImfilePullDataRsp.Builder
        }
        public func getBuilder() -> Im.File.ImfilePullDataRsp.Builder {
            return classBuilder() as! Im.File.ImfilePullDataRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfilePullDataRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfilePullDataRsp.Builder()
        }
        public func toBuilder() throws -> Im.File.ImfilePullDataRsp.Builder {
            return try Im.File.ImfilePullDataRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.File.ImfilePullDataRsp) throws -> Im.File.ImfilePullDataRsp.Builder {
            return try Im.File.ImfilePullDataRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            if hasTaskId {
                jsonMap["taskId"] = taskId
            }
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasOffset {
                jsonMap["offset"] = UInt(offset)
            }
            if hasFileData {
                jsonMap["fileData"] = fileData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfilePullDataRsp {
            return try Im.File.ImfilePullDataRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.File.ImfilePullDataRsp {
            return try Im.File.ImfilePullDataRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            if hasTaskId {
                output += "\(indent) taskId: \(taskId) \n"
            }
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasOffset {
                output += "\(indent) offset: \(offset) \n"
            }
            if hasFileData {
                output += "\(indent) fileData: \(fileData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasTaskId {
                    hashCode = (hashCode &* 31) &+ taskId.hashValue
                }
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasOffset {
                    hashCode = (hashCode &* 31) &+ offset.hashValue
                }
                if hasFileData {
                    hashCode = (hashCode &* 31) &+ fileData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.File.ImfilePullDataRsp"
        }
        override public func className() -> String {
            return "Im.File.ImfilePullDataRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.File.ImfilePullDataRsp = Im.File.ImfilePullDataRsp()
            public func getMessage() -> Im.File.ImfilePullDataRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 	0x0505
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.File.ImfilePullDataRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.File.ImfilePullDataRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            public var taskId:String {
                get {
                    return builderResult.taskId
                }
                set (value) {
                    builderResult.hasTaskId = true
                    builderResult.taskId = value
                }
            }
            public var hasTaskId:Bool {
                get {
                    return builderResult.hasTaskId
                }
            }
            @discardableResult
            public func setTaskId(_ value:String) -> Im.File.ImfilePullDataRsp.Builder {
                self.taskId = value
                return self
            }
            @discardableResult
            public func clearTaskId() -> Im.File.ImfilePullDataRsp.Builder{
                builderResult.hasTaskId = false
                builderResult.taskId = nil
                return self
            }
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.File.ImfilePullDataRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.File.ImfilePullDataRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var offset:UInt32 {
                get {
                    return builderResult.offset
                }
                set (value) {
                    builderResult.hasOffset = true
                    builderResult.offset = value
                }
            }
            public var hasOffset:Bool {
                get {
                    return builderResult.hasOffset
                }
            }
            @discardableResult
            public func setOffset(_ value:UInt32) -> Im.File.ImfilePullDataRsp.Builder {
                self.offset = value
                return self
            }
            @discardableResult
            public func clearOffset() -> Im.File.ImfilePullDataRsp.Builder{
                builderResult.hasOffset = false
                builderResult.offset = nil
                return self
            }
            public var fileData:Data {
                get {
                    return builderResult.fileData
                }
                set (value) {
                    builderResult.hasFileData = true
                    builderResult.fileData = value
                }
            }
            public var hasFileData:Bool {
                get {
                    return builderResult.hasFileData
                }
            }
            @discardableResult
            public func setFileData(_ value:Data) -> Im.File.ImfilePullDataRsp.Builder {
                self.fileData = value
                return self
            }
            @discardableResult
            public func clearFileData() -> Im.File.ImfilePullDataRsp.Builder{
                builderResult.hasFileData = false
                builderResult.fileData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.File.ImfilePullDataRsp.Builder {
                builderResult = Im.File.ImfilePullDataRsp()
                return self
            }
            override public func clone() throws -> Im.File.ImfilePullDataRsp.Builder {
                return try Im.File.ImfilePullDataRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.File.ImfilePullDataRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.File.ImfilePullDataRsp {
                let returnMe:Im.File.ImfilePullDataRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.File.ImfilePullDataRsp) throws -> Im.File.ImfilePullDataRsp.Builder {
                if other == Im.File.ImfilePullDataRsp() {
                    return self
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasTaskId {
                    taskId = other.taskId
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasOffset {
                    offset = other.offset
                }
                if other.hasFileData {
                    fileData = other.fileData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfilePullDataRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfilePullDataRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        resultCode = try codedInputStream.readUInt32()

                    case 18:
                        taskId = try codedInputStream.readString()

                    case 24:
                        userId = try codedInputStream.readUInt32()

                    case 32:
                        offset = try codedInputStream.readUInt32()

                    case 42:
                        fileData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfilePullDataRsp.Builder {
                let resultDecodedBuilder = Im.File.ImfilePullDataRsp.Builder()
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                if let jsonValueTaskId = jsonMap["taskId"] as? String {
                    resultDecodedBuilder.taskId = jsonValueTaskId
                }
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueOffset = jsonMap["offset"] as? UInt {
                    resultDecodedBuilder.offset = UInt32(jsonValueOffset)
                } else if let jsonValueOffset = jsonMap["offset"] as? String {
                    resultDecodedBuilder.offset = UInt32(jsonValueOffset)!
                }
                if let jsonValueFileData = jsonMap["fileData"] as? String {
                    resultDecodedBuilder.fileData = Data(base64Encoded:jsonValueFileData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.File.ImfilePullDataRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.File.ImfilePullDataRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfileReq : GeneratedMessage {
        public typealias BuilderType = Im.File.ImfileReq.Builder

        public static func == (lhs: Im.File.ImfileReq, rhs: Im.File.ImfileReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFromUserId == rhs.hasFromUserId) && (!lhs.hasFromUserId || lhs.fromUserId == rhs.fromUserId)
            fieldCheck = fieldCheck && (lhs.hasToUserId == rhs.hasToUserId) && (!lhs.hasToUserId || lhs.toUserId == rhs.toUserId)
            fieldCheck = fieldCheck && (lhs.hasFileName == rhs.hasFileName) && (!lhs.hasFileName || lhs.fileName == rhs.fileName)
            fieldCheck = fieldCheck && (lhs.hasFileSize == rhs.hasFileSize) && (!lhs.hasFileSize || lhs.fileSize == rhs.fileSize)
            fieldCheck = fieldCheck && (lhs.hasTransMode == rhs.hasTransMode) && (!lhs.hasTransMode || lhs.transMode == rhs.transMode)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id: 	0x0506
        public fileprivate(set) var fromUserId:UInt32! = nil
        public fileprivate(set) var hasFromUserId:Bool = false

        public fileprivate(set) var toUserId:UInt32! = nil
        public fileprivate(set) var hasToUserId:Bool = false

        public fileprivate(set) var fileName:String! = nil
        public fileprivate(set) var hasFileName:Bool = false

        public fileprivate(set) var fileSize:UInt32! = nil
        public fileprivate(set) var hasFileSize:Bool = false

        public fileprivate(set) var transMode:Im.BaseDefine.TransferFileType = Im.BaseDefine.TransferFileType.fileTypeOnline
        public fileprivate(set) var hasTransMode:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasFromUserId {
                return false
            }
            if !hasToUserId {
                return false
            }
            if !hasFileName {
                return false
            }
            if !hasFileSize {
                return false
            }
            if !hasTransMode {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFromUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:fromUserId)
            }
            if hasToUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:toUserId)
            }
            if hasFileName {
                try codedOutputStream.writeString(fieldNumber: 3, value:fileName)
            }
            if hasFileSize {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:fileSize)
            }
            if hasTransMode {
                try codedOutputStream.writeEnum(fieldNumber: 5, value:transMode.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFromUserId {
                serialize_size += fromUserId.computeUInt32Size(fieldNumber: 1)
            }
            if hasToUserId {
                serialize_size += toUserId.computeUInt32Size(fieldNumber: 2)
            }
            if hasFileName {
                serialize_size += fileName.computeStringSize(fieldNumber: 3)
            }
            if hasFileSize {
                serialize_size += fileSize.computeUInt32Size(fieldNumber: 4)
            }
            if (hasTransMode) {
                serialize_size += transMode.rawValue.computeEnumSize(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.File.ImfileReq.Builder {
            return Im.File.ImfileReq.classBuilder() as! Im.File.ImfileReq.Builder
        }
        public func getBuilder() -> Im.File.ImfileReq.Builder {
            return classBuilder() as! Im.File.ImfileReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileReq.Builder()
        }
        public func toBuilder() throws -> Im.File.ImfileReq.Builder {
            return try Im.File.ImfileReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.File.ImfileReq) throws -> Im.File.ImfileReq.Builder {
            return try Im.File.ImfileReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFromUserId {
                jsonMap["fromUserId"] = UInt(fromUserId)
            }
            if hasToUserId {
                jsonMap["toUserId"] = UInt(toUserId)
            }
            if hasFileName {
                jsonMap["fileName"] = fileName
            }
            if hasFileSize {
                jsonMap["fileSize"] = UInt(fileSize)
            }
            if hasTransMode {
                jsonMap["transMode"] = transMode.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileReq {
            return try Im.File.ImfileReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.File.ImfileReq {
            return try Im.File.ImfileReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFromUserId {
                output += "\(indent) fromUserId: \(fromUserId) \n"
            }
            if hasToUserId {
                output += "\(indent) toUserId: \(toUserId) \n"
            }
            if hasFileName {
                output += "\(indent) fileName: \(fileName) \n"
            }
            if hasFileSize {
                output += "\(indent) fileSize: \(fileSize) \n"
            }
            if (hasTransMode) {
                output += "\(indent) transMode: \(transMode.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFromUserId {
                    hashCode = (hashCode &* 31) &+ fromUserId.hashValue
                }
                if hasToUserId {
                    hashCode = (hashCode &* 31) &+ toUserId.hashValue
                }
                if hasFileName {
                    hashCode = (hashCode &* 31) &+ fileName.hashValue
                }
                if hasFileSize {
                    hashCode = (hashCode &* 31) &+ fileSize.hashValue
                }
                if hasTransMode {
                     hashCode = (hashCode &* 31) &+ transMode.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.File.ImfileReq"
        }
        override public func className() -> String {
            return "Im.File.ImfileReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.File.ImfileReq = Im.File.ImfileReq()
            public func getMessage() -> Im.File.ImfileReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 	0x0506
            public var fromUserId:UInt32 {
                get {
                    return builderResult.fromUserId
                }
                set (value) {
                    builderResult.hasFromUserId = true
                    builderResult.fromUserId = value
                }
            }
            public var hasFromUserId:Bool {
                get {
                    return builderResult.hasFromUserId
                }
            }
            @discardableResult
            public func setFromUserId(_ value:UInt32) -> Im.File.ImfileReq.Builder {
                self.fromUserId = value
                return self
            }
            @discardableResult
            public func clearFromUserId() -> Im.File.ImfileReq.Builder{
                builderResult.hasFromUserId = false
                builderResult.fromUserId = nil
                return self
            }
            public var toUserId:UInt32 {
                get {
                    return builderResult.toUserId
                }
                set (value) {
                    builderResult.hasToUserId = true
                    builderResult.toUserId = value
                }
            }
            public var hasToUserId:Bool {
                get {
                    return builderResult.hasToUserId
                }
            }
            @discardableResult
            public func setToUserId(_ value:UInt32) -> Im.File.ImfileReq.Builder {
                self.toUserId = value
                return self
            }
            @discardableResult
            public func clearToUserId() -> Im.File.ImfileReq.Builder{
                builderResult.hasToUserId = false
                builderResult.toUserId = nil
                return self
            }
            public var fileName:String {
                get {
                    return builderResult.fileName
                }
                set (value) {
                    builderResult.hasFileName = true
                    builderResult.fileName = value
                }
            }
            public var hasFileName:Bool {
                get {
                    return builderResult.hasFileName
                }
            }
            @discardableResult
            public func setFileName(_ value:String) -> Im.File.ImfileReq.Builder {
                self.fileName = value
                return self
            }
            @discardableResult
            public func clearFileName() -> Im.File.ImfileReq.Builder{
                builderResult.hasFileName = false
                builderResult.fileName = nil
                return self
            }
            public var fileSize:UInt32 {
                get {
                    return builderResult.fileSize
                }
                set (value) {
                    builderResult.hasFileSize = true
                    builderResult.fileSize = value
                }
            }
            public var hasFileSize:Bool {
                get {
                    return builderResult.hasFileSize
                }
            }
            @discardableResult
            public func setFileSize(_ value:UInt32) -> Im.File.ImfileReq.Builder {
                self.fileSize = value
                return self
            }
            @discardableResult
            public func clearFileSize() -> Im.File.ImfileReq.Builder{
                builderResult.hasFileSize = false
                builderResult.fileSize = nil
                return self
            }
                public var transMode:Im.BaseDefine.TransferFileType {
                    get {
                        return builderResult.transMode
                    }
                    set (value) {
                        builderResult.hasTransMode = true
                        builderResult.transMode = value
                    }
                }
                public var hasTransMode:Bool{
                    get {
                        return builderResult.hasTransMode
                    }
                }
            @discardableResult
                public func setTransMode(_ value:Im.BaseDefine.TransferFileType) -> Im.File.ImfileReq.Builder {
                  self.transMode = value
                  return self
                }
            @discardableResult
                public func clearTransMode() -> Im.File.ImfileReq.Builder {
                   builderResult.hasTransMode = false
                   builderResult.transMode = .fileTypeOnline
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.File.ImfileReq.Builder {
                builderResult = Im.File.ImfileReq()
                return self
            }
            override public func clone() throws -> Im.File.ImfileReq.Builder {
                return try Im.File.ImfileReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.File.ImfileReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.File.ImfileReq {
                let returnMe:Im.File.ImfileReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.File.ImfileReq) throws -> Im.File.ImfileReq.Builder {
                if other == Im.File.ImfileReq() {
                    return self
                }
                if other.hasFromUserId {
                    fromUserId = other.fromUserId
                }
                if other.hasToUserId {
                    toUserId = other.toUserId
                }
                if other.hasFileName {
                    fileName = other.fileName
                }
                if other.hasFileSize {
                    fileSize = other.fileSize
                }
                if other.hasTransMode {
                    transMode = other.transMode
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        fromUserId = try codedInputStream.readUInt32()

                    case 16:
                        toUserId = try codedInputStream.readUInt32()

                    case 26:
                        fileName = try codedInputStream.readString()

                    case 32:
                        fileSize = try codedInputStream.readUInt32()

                    case 40:
                        let valueInttransMode = try codedInputStream.readEnum()
                        if let enumstransMode = Im.BaseDefine.TransferFileType(rawValue:valueInttransMode){
                            transMode = enumstransMode
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 5, value:Int64(valueInttransMode))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileReq.Builder {
                let resultDecodedBuilder = Im.File.ImfileReq.Builder()
                if let jsonValueFromUserId = jsonMap["fromUserId"] as? UInt {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)
                } else if let jsonValueFromUserId = jsonMap["fromUserId"] as? String {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)!
                }
                if let jsonValueToUserId = jsonMap["toUserId"] as? UInt {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)
                } else if let jsonValueToUserId = jsonMap["toUserId"] as? String {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)!
                }
                if let jsonValueFileName = jsonMap["fileName"] as? String {
                    resultDecodedBuilder.fileName = jsonValueFileName
                }
                if let jsonValueFileSize = jsonMap["fileSize"] as? UInt {
                    resultDecodedBuilder.fileSize = UInt32(jsonValueFileSize)
                } else if let jsonValueFileSize = jsonMap["fileSize"] as? String {
                    resultDecodedBuilder.fileSize = UInt32(jsonValueFileSize)!
                }
                if let jsonValueTransMode = jsonMap["transMode"] as? String {
                    resultDecodedBuilder.transMode = try Im.BaseDefine.TransferFileType.fromString(jsonValueTransMode)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.File.ImfileReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.File.ImfileReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfileRsp : GeneratedMessage {
        public typealias BuilderType = Im.File.ImfileRsp.Builder

        public static func == (lhs: Im.File.ImfileRsp, rhs: Im.File.ImfileRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasFromUserId == rhs.hasFromUserId) && (!lhs.hasFromUserId || lhs.fromUserId == rhs.fromUserId)
            fieldCheck = fieldCheck && (lhs.hasToUserId == rhs.hasToUserId) && (!lhs.hasToUserId || lhs.toUserId == rhs.toUserId)
            fieldCheck = fieldCheck && (lhs.hasFileName == rhs.hasFileName) && (!lhs.hasFileName || lhs.fileName == rhs.fileName)
            fieldCheck = fieldCheck && (lhs.hasTaskId == rhs.hasTaskId) && (!lhs.hasTaskId || lhs.taskId == rhs.taskId)
            fieldCheck = fieldCheck && (lhs.ipAddrList == rhs.ipAddrList)
            fieldCheck = fieldCheck && (lhs.hasTransMode == rhs.hasTransMode) && (!lhs.hasTransMode || lhs.transMode == rhs.transMode)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id: 	0x0507
        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        public fileprivate(set) var fromUserId:UInt32! = nil
        public fileprivate(set) var hasFromUserId:Bool = false

        public fileprivate(set) var toUserId:UInt32! = nil
        public fileprivate(set) var hasToUserId:Bool = false

        public fileprivate(set) var fileName:String! = nil
        public fileprivate(set) var hasFileName:Bool = false

        public fileprivate(set) var taskId:String! = nil
        public fileprivate(set) var hasTaskId:Bool = false

        public fileprivate(set) var ipAddrList:Array<Im.BaseDefine.IpAddr>  = Array<Im.BaseDefine.IpAddr>()
        public fileprivate(set) var transMode:Im.BaseDefine.TransferFileType = Im.BaseDefine.TransferFileType.fileTypeOnline
        public fileprivate(set) var hasTransMode:Bool = false
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasResultCode {
                return false
            }
            if !hasFromUserId {
                return false
            }
            if !hasToUserId {
                return false
            }
            if !hasFileName {
                return false
            }
            if !hasTaskId {
                return false
            }
            if !hasTransMode {
                return false
            }
            var isInitIpAddrList:Bool = true
            for oneElementIpAddrList in ipAddrList {
                if !oneElementIpAddrList.isInitialized() {
                    isInitIpAddrList = false
                    break 
                }
            }
            if !isInitIpAddrList {
                return isInitIpAddrList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:resultCode)
            }
            if hasFromUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:fromUserId)
            }
            if hasToUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:toUserId)
            }
            if hasFileName {
                try codedOutputStream.writeString(fieldNumber: 4, value:fileName)
            }
            if hasTaskId {
                try codedOutputStream.writeString(fieldNumber: 5, value:taskId)
            }
            for oneElementIpAddrList in ipAddrList {
                  try codedOutputStream.writeMessage(fieldNumber: 6, value:oneElementIpAddrList)
            }
            if hasTransMode {
                try codedOutputStream.writeEnum(fieldNumber: 7, value:transMode.rawValue)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 1)
            }
            if hasFromUserId {
                serialize_size += fromUserId.computeUInt32Size(fieldNumber: 2)
            }
            if hasToUserId {
                serialize_size += toUserId.computeUInt32Size(fieldNumber: 3)
            }
            if hasFileName {
                serialize_size += fileName.computeStringSize(fieldNumber: 4)
            }
            if hasTaskId {
                serialize_size += taskId.computeStringSize(fieldNumber: 5)
            }
            for oneElementIpAddrList in ipAddrList {
                serialize_size += oneElementIpAddrList.computeMessageSize(fieldNumber: 6)
            }
            if (hasTransMode) {
                serialize_size += transMode.rawValue.computeEnumSize(fieldNumber: 7)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.File.ImfileRsp.Builder {
            return Im.File.ImfileRsp.classBuilder() as! Im.File.ImfileRsp.Builder
        }
        public func getBuilder() -> Im.File.ImfileRsp.Builder {
            return classBuilder() as! Im.File.ImfileRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileRsp.Builder()
        }
        public func toBuilder() throws -> Im.File.ImfileRsp.Builder {
            return try Im.File.ImfileRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.File.ImfileRsp) throws -> Im.File.ImfileRsp.Builder {
            return try Im.File.ImfileRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            if hasFromUserId {
                jsonMap["fromUserId"] = UInt(fromUserId)
            }
            if hasToUserId {
                jsonMap["toUserId"] = UInt(toUserId)
            }
            if hasFileName {
                jsonMap["fileName"] = fileName
            }
            if hasTaskId {
                jsonMap["taskId"] = taskId
            }
            if !ipAddrList.isEmpty {
                var jsonArrayIpAddrList:Array<Dictionary<String,Any>> = []
                for oneValueIpAddrList in ipAddrList {
                    let ecodedMessageIpAddrList = try oneValueIpAddrList.encode()
                    jsonArrayIpAddrList.append(ecodedMessageIpAddrList)
                }
                jsonMap["ipAddrList"] = jsonArrayIpAddrList
            }
            if hasTransMode {
                jsonMap["transMode"] = transMode.toString()
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileRsp {
            return try Im.File.ImfileRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.File.ImfileRsp {
            return try Im.File.ImfileRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            if hasFromUserId {
                output += "\(indent) fromUserId: \(fromUserId) \n"
            }
            if hasToUserId {
                output += "\(indent) toUserId: \(toUserId) \n"
            }
            if hasFileName {
                output += "\(indent) fileName: \(fileName) \n"
            }
            if hasTaskId {
                output += "\(indent) taskId: \(taskId) \n"
            }
            var ipAddrListElementIndex:Int = 0
            for oneElementIpAddrList in ipAddrList {
                output += "\(indent) ipAddrList[\(ipAddrListElementIndex)] {\n"
                output += try oneElementIpAddrList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                ipAddrListElementIndex += 1
            }
            if (hasTransMode) {
                output += "\(indent) transMode: \(transMode.description)\n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasFromUserId {
                    hashCode = (hashCode &* 31) &+ fromUserId.hashValue
                }
                if hasToUserId {
                    hashCode = (hashCode &* 31) &+ toUserId.hashValue
                }
                if hasFileName {
                    hashCode = (hashCode &* 31) &+ fileName.hashValue
                }
                if hasTaskId {
                    hashCode = (hashCode &* 31) &+ taskId.hashValue
                }
                for oneElementIpAddrList in ipAddrList {
                    hashCode = (hashCode &* 31) &+ oneElementIpAddrList.hashValue
                }
                if hasTransMode {
                     hashCode = (hashCode &* 31) &+ transMode.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.File.ImfileRsp"
        }
        override public func className() -> String {
            return "Im.File.ImfileRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.File.ImfileRsp = Im.File.ImfileRsp()
            public func getMessage() -> Im.File.ImfileRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 	0x0507
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.File.ImfileRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.File.ImfileRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            public var fromUserId:UInt32 {
                get {
                    return builderResult.fromUserId
                }
                set (value) {
                    builderResult.hasFromUserId = true
                    builderResult.fromUserId = value
                }
            }
            public var hasFromUserId:Bool {
                get {
                    return builderResult.hasFromUserId
                }
            }
            @discardableResult
            public func setFromUserId(_ value:UInt32) -> Im.File.ImfileRsp.Builder {
                self.fromUserId = value
                return self
            }
            @discardableResult
            public func clearFromUserId() -> Im.File.ImfileRsp.Builder{
                builderResult.hasFromUserId = false
                builderResult.fromUserId = nil
                return self
            }
            public var toUserId:UInt32 {
                get {
                    return builderResult.toUserId
                }
                set (value) {
                    builderResult.hasToUserId = true
                    builderResult.toUserId = value
                }
            }
            public var hasToUserId:Bool {
                get {
                    return builderResult.hasToUserId
                }
            }
            @discardableResult
            public func setToUserId(_ value:UInt32) -> Im.File.ImfileRsp.Builder {
                self.toUserId = value
                return self
            }
            @discardableResult
            public func clearToUserId() -> Im.File.ImfileRsp.Builder{
                builderResult.hasToUserId = false
                builderResult.toUserId = nil
                return self
            }
            public var fileName:String {
                get {
                    return builderResult.fileName
                }
                set (value) {
                    builderResult.hasFileName = true
                    builderResult.fileName = value
                }
            }
            public var hasFileName:Bool {
                get {
                    return builderResult.hasFileName
                }
            }
            @discardableResult
            public func setFileName(_ value:String) -> Im.File.ImfileRsp.Builder {
                self.fileName = value
                return self
            }
            @discardableResult
            public func clearFileName() -> Im.File.ImfileRsp.Builder{
                builderResult.hasFileName = false
                builderResult.fileName = nil
                return self
            }
            public var taskId:String {
                get {
                    return builderResult.taskId
                }
                set (value) {
                    builderResult.hasTaskId = true
                    builderResult.taskId = value
                }
            }
            public var hasTaskId:Bool {
                get {
                    return builderResult.hasTaskId
                }
            }
            @discardableResult
            public func setTaskId(_ value:String) -> Im.File.ImfileRsp.Builder {
                self.taskId = value
                return self
            }
            @discardableResult
            public func clearTaskId() -> Im.File.ImfileRsp.Builder{
                builderResult.hasTaskId = false
                builderResult.taskId = nil
                return self
            }
            public var ipAddrList:Array<Im.BaseDefine.IpAddr> {
                get {
                    return builderResult.ipAddrList
                }
                set (value) {
                    builderResult.ipAddrList = value
                }
            }
            @discardableResult
            public func setIpAddrList(_ value:Array<Im.BaseDefine.IpAddr>) -> Im.File.ImfileRsp.Builder {
                self.ipAddrList = value
                return self
            }
            @discardableResult
            public func clearIpAddrList() -> Im.File.ImfileRsp.Builder {
                builderResult.ipAddrList.removeAll(keepingCapacity: false)
                return self
            }
                public var transMode:Im.BaseDefine.TransferFileType {
                    get {
                        return builderResult.transMode
                    }
                    set (value) {
                        builderResult.hasTransMode = true
                        builderResult.transMode = value
                    }
                }
                public var hasTransMode:Bool{
                    get {
                        return builderResult.hasTransMode
                    }
                }
            @discardableResult
                public func setTransMode(_ value:Im.BaseDefine.TransferFileType) -> Im.File.ImfileRsp.Builder {
                  self.transMode = value
                  return self
                }
            @discardableResult
                public func clearTransMode() -> Im.File.ImfileRsp.Builder {
                   builderResult.hasTransMode = false
                   builderResult.transMode = .fileTypeOnline
                   return self
                }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.File.ImfileRsp.Builder {
                builderResult = Im.File.ImfileRsp()
                return self
            }
            override public func clone() throws -> Im.File.ImfileRsp.Builder {
                return try Im.File.ImfileRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.File.ImfileRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.File.ImfileRsp {
                let returnMe:Im.File.ImfileRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.File.ImfileRsp) throws -> Im.File.ImfileRsp.Builder {
                if other == Im.File.ImfileRsp() {
                    return self
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasFromUserId {
                    fromUserId = other.fromUserId
                }
                if other.hasToUserId {
                    toUserId = other.toUserId
                }
                if other.hasFileName {
                    fileName = other.fileName
                }
                if other.hasTaskId {
                    taskId = other.taskId
                }
                if !other.ipAddrList.isEmpty  {
                     builderResult.ipAddrList += other.ipAddrList
                }
                if other.hasTransMode {
                    transMode = other.transMode
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        resultCode = try codedInputStream.readUInt32()

                    case 16:
                        fromUserId = try codedInputStream.readUInt32()

                    case 24:
                        toUserId = try codedInputStream.readUInt32()

                    case 34:
                        fileName = try codedInputStream.readString()

                    case 42:
                        taskId = try codedInputStream.readString()

                    case 50:
                        let subBuilder = Im.BaseDefine.IpAddr.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        ipAddrList.append(subBuilder.buildPartial())

                    case 56:
                        let valueInttransMode = try codedInputStream.readEnum()
                        if let enumstransMode = Im.BaseDefine.TransferFileType(rawValue:valueInttransMode){
                            transMode = enumstransMode
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 7, value:Int64(valueInttransMode))
                        }

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileRsp.Builder {
                let resultDecodedBuilder = Im.File.ImfileRsp.Builder()
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                if let jsonValueFromUserId = jsonMap["fromUserId"] as? UInt {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)
                } else if let jsonValueFromUserId = jsonMap["fromUserId"] as? String {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)!
                }
                if let jsonValueToUserId = jsonMap["toUserId"] as? UInt {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)
                } else if let jsonValueToUserId = jsonMap["toUserId"] as? String {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)!
                }
                if let jsonValueFileName = jsonMap["fileName"] as? String {
                    resultDecodedBuilder.fileName = jsonValueFileName
                }
                if let jsonValueTaskId = jsonMap["taskId"] as? String {
                    resultDecodedBuilder.taskId = jsonValueTaskId
                }
                if let jsonValueIpAddrList = jsonMap["ipAddrList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayIpAddrList:Array<Im.BaseDefine.IpAddr> = []
                    for oneValueIpAddrList in jsonValueIpAddrList {
                        let messageFromStringIpAddrList = try Im.BaseDefine.IpAddr.Builder.decodeToBuilder(jsonMap:oneValueIpAddrList).build()

                        jsonArrayIpAddrList.append(messageFromStringIpAddrList)
                    }
                    resultDecodedBuilder.ipAddrList = jsonArrayIpAddrList
                }
                if let jsonValueTransMode = jsonMap["transMode"] as? String {
                    resultDecodedBuilder.transMode = try Im.BaseDefine.TransferFileType.fromString(jsonValueTransMode)
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.File.ImfileRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.File.ImfileRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfileNotify : GeneratedMessage {
        public typealias BuilderType = Im.File.ImfileNotify.Builder

        public static func == (lhs: Im.File.ImfileNotify, rhs: Im.File.ImfileNotify) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFromUserId == rhs.hasFromUserId) && (!lhs.hasFromUserId || lhs.fromUserId == rhs.fromUserId)
            fieldCheck = fieldCheck && (lhs.hasToUserId == rhs.hasToUserId) && (!lhs.hasToUserId || lhs.toUserId == rhs.toUserId)
            fieldCheck = fieldCheck && (lhs.hasFileName == rhs.hasFileName) && (!lhs.hasFileName || lhs.fileName == rhs.fileName)
            fieldCheck = fieldCheck && (lhs.hasFileSize == rhs.hasFileSize) && (!lhs.hasFileSize || lhs.fileSize == rhs.fileSize)
            fieldCheck = fieldCheck && (lhs.hasTaskId == rhs.hasTaskId) && (!lhs.hasTaskId || lhs.taskId == rhs.taskId)
            fieldCheck = fieldCheck && (lhs.ipAddrList == rhs.ipAddrList)
            fieldCheck = fieldCheck && (lhs.hasTransMode == rhs.hasTransMode) && (!lhs.hasTransMode || lhs.transMode == rhs.transMode)
            fieldCheck = fieldCheck && (lhs.hasOfflineReady == rhs.hasOfflineReady) && (!lhs.hasOfflineReady || lhs.offlineReady == rhs.offlineReady)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id: 	0x0508
        public fileprivate(set) var fromUserId:UInt32! = nil
        public fileprivate(set) var hasFromUserId:Bool = false

        public fileprivate(set) var toUserId:UInt32! = nil
        public fileprivate(set) var hasToUserId:Bool = false

        public fileprivate(set) var fileName:String! = nil
        public fileprivate(set) var hasFileName:Bool = false

        public fileprivate(set) var fileSize:UInt32! = nil
        public fileprivate(set) var hasFileSize:Bool = false

        public fileprivate(set) var taskId:String! = nil
        public fileprivate(set) var hasTaskId:Bool = false

        public fileprivate(set) var ipAddrList:Array<Im.BaseDefine.IpAddr>  = Array<Im.BaseDefine.IpAddr>()
        public fileprivate(set) var transMode:Im.BaseDefine.TransferFileType = Im.BaseDefine.TransferFileType.fileTypeOnline
        public fileprivate(set) var hasTransMode:Bool = false
        ///1:True 0:False
        public fileprivate(set) var offlineReady:UInt32! = nil
        public fileprivate(set) var hasOfflineReady:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasFromUserId {
                return false
            }
            if !hasToUserId {
                return false
            }
            if !hasFileName {
                return false
            }
            if !hasFileSize {
                return false
            }
            if !hasTaskId {
                return false
            }
            if !hasTransMode {
                return false
            }
            if !hasOfflineReady {
                return false
            }
            var isInitIpAddrList:Bool = true
            for oneElementIpAddrList in ipAddrList {
                if !oneElementIpAddrList.isInitialized() {
                    isInitIpAddrList = false
                    break 
                }
            }
            if !isInitIpAddrList {
                return isInitIpAddrList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFromUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:fromUserId)
            }
            if hasToUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:toUserId)
            }
            if hasFileName {
                try codedOutputStream.writeString(fieldNumber: 3, value:fileName)
            }
            if hasFileSize {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:fileSize)
            }
            if hasTaskId {
                try codedOutputStream.writeString(fieldNumber: 5, value:taskId)
            }
            for oneElementIpAddrList in ipAddrList {
                  try codedOutputStream.writeMessage(fieldNumber: 6, value:oneElementIpAddrList)
            }
            if hasTransMode {
                try codedOutputStream.writeEnum(fieldNumber: 7, value:transMode.rawValue)
            }
            if hasOfflineReady {
                try codedOutputStream.writeUInt32(fieldNumber: 8, value:offlineReady)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFromUserId {
                serialize_size += fromUserId.computeUInt32Size(fieldNumber: 1)
            }
            if hasToUserId {
                serialize_size += toUserId.computeUInt32Size(fieldNumber: 2)
            }
            if hasFileName {
                serialize_size += fileName.computeStringSize(fieldNumber: 3)
            }
            if hasFileSize {
                serialize_size += fileSize.computeUInt32Size(fieldNumber: 4)
            }
            if hasTaskId {
                serialize_size += taskId.computeStringSize(fieldNumber: 5)
            }
            for oneElementIpAddrList in ipAddrList {
                serialize_size += oneElementIpAddrList.computeMessageSize(fieldNumber: 6)
            }
            if (hasTransMode) {
                serialize_size += transMode.rawValue.computeEnumSize(fieldNumber: 7)
            }
            if hasOfflineReady {
                serialize_size += offlineReady.computeUInt32Size(fieldNumber: 8)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.File.ImfileNotify.Builder {
            return Im.File.ImfileNotify.classBuilder() as! Im.File.ImfileNotify.Builder
        }
        public func getBuilder() -> Im.File.ImfileNotify.Builder {
            return classBuilder() as! Im.File.ImfileNotify.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileNotify.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileNotify.Builder()
        }
        public func toBuilder() throws -> Im.File.ImfileNotify.Builder {
            return try Im.File.ImfileNotify.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.File.ImfileNotify) throws -> Im.File.ImfileNotify.Builder {
            return try Im.File.ImfileNotify.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFromUserId {
                jsonMap["fromUserId"] = UInt(fromUserId)
            }
            if hasToUserId {
                jsonMap["toUserId"] = UInt(toUserId)
            }
            if hasFileName {
                jsonMap["fileName"] = fileName
            }
            if hasFileSize {
                jsonMap["fileSize"] = UInt(fileSize)
            }
            if hasTaskId {
                jsonMap["taskId"] = taskId
            }
            if !ipAddrList.isEmpty {
                var jsonArrayIpAddrList:Array<Dictionary<String,Any>> = []
                for oneValueIpAddrList in ipAddrList {
                    let ecodedMessageIpAddrList = try oneValueIpAddrList.encode()
                    jsonArrayIpAddrList.append(ecodedMessageIpAddrList)
                }
                jsonMap["ipAddrList"] = jsonArrayIpAddrList
            }
            if hasTransMode {
                jsonMap["transMode"] = transMode.toString()
            }
            if hasOfflineReady {
                jsonMap["offlineReady"] = UInt(offlineReady)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileNotify {
            return try Im.File.ImfileNotify.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.File.ImfileNotify {
            return try Im.File.ImfileNotify.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFromUserId {
                output += "\(indent) fromUserId: \(fromUserId) \n"
            }
            if hasToUserId {
                output += "\(indent) toUserId: \(toUserId) \n"
            }
            if hasFileName {
                output += "\(indent) fileName: \(fileName) \n"
            }
            if hasFileSize {
                output += "\(indent) fileSize: \(fileSize) \n"
            }
            if hasTaskId {
                output += "\(indent) taskId: \(taskId) \n"
            }
            var ipAddrListElementIndex:Int = 0
            for oneElementIpAddrList in ipAddrList {
                output += "\(indent) ipAddrList[\(ipAddrListElementIndex)] {\n"
                output += try oneElementIpAddrList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                ipAddrListElementIndex += 1
            }
            if (hasTransMode) {
                output += "\(indent) transMode: \(transMode.description)\n"
            }
            if hasOfflineReady {
                output += "\(indent) offlineReady: \(offlineReady) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFromUserId {
                    hashCode = (hashCode &* 31) &+ fromUserId.hashValue
                }
                if hasToUserId {
                    hashCode = (hashCode &* 31) &+ toUserId.hashValue
                }
                if hasFileName {
                    hashCode = (hashCode &* 31) &+ fileName.hashValue
                }
                if hasFileSize {
                    hashCode = (hashCode &* 31) &+ fileSize.hashValue
                }
                if hasTaskId {
                    hashCode = (hashCode &* 31) &+ taskId.hashValue
                }
                for oneElementIpAddrList in ipAddrList {
                    hashCode = (hashCode &* 31) &+ oneElementIpAddrList.hashValue
                }
                if hasTransMode {
                     hashCode = (hashCode &* 31) &+ transMode.hashValue
                }
                if hasOfflineReady {
                    hashCode = (hashCode &* 31) &+ offlineReady.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.File.ImfileNotify"
        }
        override public func className() -> String {
            return "Im.File.ImfileNotify"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.File.ImfileNotify = Im.File.ImfileNotify()
            public func getMessage() -> Im.File.ImfileNotify {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 	0x0508
            public var fromUserId:UInt32 {
                get {
                    return builderResult.fromUserId
                }
                set (value) {
                    builderResult.hasFromUserId = true
                    builderResult.fromUserId = value
                }
            }
            public var hasFromUserId:Bool {
                get {
                    return builderResult.hasFromUserId
                }
            }
            @discardableResult
            public func setFromUserId(_ value:UInt32) -> Im.File.ImfileNotify.Builder {
                self.fromUserId = value
                return self
            }
            @discardableResult
            public func clearFromUserId() -> Im.File.ImfileNotify.Builder{
                builderResult.hasFromUserId = false
                builderResult.fromUserId = nil
                return self
            }
            public var toUserId:UInt32 {
                get {
                    return builderResult.toUserId
                }
                set (value) {
                    builderResult.hasToUserId = true
                    builderResult.toUserId = value
                }
            }
            public var hasToUserId:Bool {
                get {
                    return builderResult.hasToUserId
                }
            }
            @discardableResult
            public func setToUserId(_ value:UInt32) -> Im.File.ImfileNotify.Builder {
                self.toUserId = value
                return self
            }
            @discardableResult
            public func clearToUserId() -> Im.File.ImfileNotify.Builder{
                builderResult.hasToUserId = false
                builderResult.toUserId = nil
                return self
            }
            public var fileName:String {
                get {
                    return builderResult.fileName
                }
                set (value) {
                    builderResult.hasFileName = true
                    builderResult.fileName = value
                }
            }
            public var hasFileName:Bool {
                get {
                    return builderResult.hasFileName
                }
            }
            @discardableResult
            public func setFileName(_ value:String) -> Im.File.ImfileNotify.Builder {
                self.fileName = value
                return self
            }
            @discardableResult
            public func clearFileName() -> Im.File.ImfileNotify.Builder{
                builderResult.hasFileName = false
                builderResult.fileName = nil
                return self
            }
            public var fileSize:UInt32 {
                get {
                    return builderResult.fileSize
                }
                set (value) {
                    builderResult.hasFileSize = true
                    builderResult.fileSize = value
                }
            }
            public var hasFileSize:Bool {
                get {
                    return builderResult.hasFileSize
                }
            }
            @discardableResult
            public func setFileSize(_ value:UInt32) -> Im.File.ImfileNotify.Builder {
                self.fileSize = value
                return self
            }
            @discardableResult
            public func clearFileSize() -> Im.File.ImfileNotify.Builder{
                builderResult.hasFileSize = false
                builderResult.fileSize = nil
                return self
            }
            public var taskId:String {
                get {
                    return builderResult.taskId
                }
                set (value) {
                    builderResult.hasTaskId = true
                    builderResult.taskId = value
                }
            }
            public var hasTaskId:Bool {
                get {
                    return builderResult.hasTaskId
                }
            }
            @discardableResult
            public func setTaskId(_ value:String) -> Im.File.ImfileNotify.Builder {
                self.taskId = value
                return self
            }
            @discardableResult
            public func clearTaskId() -> Im.File.ImfileNotify.Builder{
                builderResult.hasTaskId = false
                builderResult.taskId = nil
                return self
            }
            public var ipAddrList:Array<Im.BaseDefine.IpAddr> {
                get {
                    return builderResult.ipAddrList
                }
                set (value) {
                    builderResult.ipAddrList = value
                }
            }
            @discardableResult
            public func setIpAddrList(_ value:Array<Im.BaseDefine.IpAddr>) -> Im.File.ImfileNotify.Builder {
                self.ipAddrList = value
                return self
            }
            @discardableResult
            public func clearIpAddrList() -> Im.File.ImfileNotify.Builder {
                builderResult.ipAddrList.removeAll(keepingCapacity: false)
                return self
            }
                public var transMode:Im.BaseDefine.TransferFileType {
                    get {
                        return builderResult.transMode
                    }
                    set (value) {
                        builderResult.hasTransMode = true
                        builderResult.transMode = value
                    }
                }
                public var hasTransMode:Bool{
                    get {
                        return builderResult.hasTransMode
                    }
                }
            @discardableResult
                public func setTransMode(_ value:Im.BaseDefine.TransferFileType) -> Im.File.ImfileNotify.Builder {
                  self.transMode = value
                  return self
                }
            @discardableResult
                public func clearTransMode() -> Im.File.ImfileNotify.Builder {
                   builderResult.hasTransMode = false
                   builderResult.transMode = .fileTypeOnline
                   return self
                }
            ///1:True 0:False
            public var offlineReady:UInt32 {
                get {
                    return builderResult.offlineReady
                }
                set (value) {
                    builderResult.hasOfflineReady = true
                    builderResult.offlineReady = value
                }
            }
            public var hasOfflineReady:Bool {
                get {
                    return builderResult.hasOfflineReady
                }
            }
            @discardableResult
            public func setOfflineReady(_ value:UInt32) -> Im.File.ImfileNotify.Builder {
                self.offlineReady = value
                return self
            }
            @discardableResult
            public func clearOfflineReady() -> Im.File.ImfileNotify.Builder{
                builderResult.hasOfflineReady = false
                builderResult.offlineReady = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.File.ImfileNotify.Builder {
                builderResult = Im.File.ImfileNotify()
                return self
            }
            override public func clone() throws -> Im.File.ImfileNotify.Builder {
                return try Im.File.ImfileNotify.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.File.ImfileNotify {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.File.ImfileNotify {
                let returnMe:Im.File.ImfileNotify = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.File.ImfileNotify) throws -> Im.File.ImfileNotify.Builder {
                if other == Im.File.ImfileNotify() {
                    return self
                }
                if other.hasFromUserId {
                    fromUserId = other.fromUserId
                }
                if other.hasToUserId {
                    toUserId = other.toUserId
                }
                if other.hasFileName {
                    fileName = other.fileName
                }
                if other.hasFileSize {
                    fileSize = other.fileSize
                }
                if other.hasTaskId {
                    taskId = other.taskId
                }
                if !other.ipAddrList.isEmpty  {
                     builderResult.ipAddrList += other.ipAddrList
                }
                if other.hasTransMode {
                    transMode = other.transMode
                }
                if other.hasOfflineReady {
                    offlineReady = other.offlineReady
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileNotify.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileNotify.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        fromUserId = try codedInputStream.readUInt32()

                    case 16:
                        toUserId = try codedInputStream.readUInt32()

                    case 26:
                        fileName = try codedInputStream.readString()

                    case 32:
                        fileSize = try codedInputStream.readUInt32()

                    case 42:
                        taskId = try codedInputStream.readString()

                    case 50:
                        let subBuilder = Im.BaseDefine.IpAddr.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        ipAddrList.append(subBuilder.buildPartial())

                    case 56:
                        let valueInttransMode = try codedInputStream.readEnum()
                        if let enumstransMode = Im.BaseDefine.TransferFileType(rawValue:valueInttransMode){
                            transMode = enumstransMode
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 7, value:Int64(valueInttransMode))
                        }

                    case 64:
                        offlineReady = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileNotify.Builder {
                let resultDecodedBuilder = Im.File.ImfileNotify.Builder()
                if let jsonValueFromUserId = jsonMap["fromUserId"] as? UInt {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)
                } else if let jsonValueFromUserId = jsonMap["fromUserId"] as? String {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)!
                }
                if let jsonValueToUserId = jsonMap["toUserId"] as? UInt {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)
                } else if let jsonValueToUserId = jsonMap["toUserId"] as? String {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)!
                }
                if let jsonValueFileName = jsonMap["fileName"] as? String {
                    resultDecodedBuilder.fileName = jsonValueFileName
                }
                if let jsonValueFileSize = jsonMap["fileSize"] as? UInt {
                    resultDecodedBuilder.fileSize = UInt32(jsonValueFileSize)
                } else if let jsonValueFileSize = jsonMap["fileSize"] as? String {
                    resultDecodedBuilder.fileSize = UInt32(jsonValueFileSize)!
                }
                if let jsonValueTaskId = jsonMap["taskId"] as? String {
                    resultDecodedBuilder.taskId = jsonValueTaskId
                }
                if let jsonValueIpAddrList = jsonMap["ipAddrList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayIpAddrList:Array<Im.BaseDefine.IpAddr> = []
                    for oneValueIpAddrList in jsonValueIpAddrList {
                        let messageFromStringIpAddrList = try Im.BaseDefine.IpAddr.Builder.decodeToBuilder(jsonMap:oneValueIpAddrList).build()

                        jsonArrayIpAddrList.append(messageFromStringIpAddrList)
                    }
                    resultDecodedBuilder.ipAddrList = jsonArrayIpAddrList
                }
                if let jsonValueTransMode = jsonMap["transMode"] as? String {
                    resultDecodedBuilder.transMode = try Im.BaseDefine.TransferFileType.fromString(jsonValueTransMode)
                }
                if let jsonValueOfflineReady = jsonMap["offlineReady"] as? UInt {
                    resultDecodedBuilder.offlineReady = UInt32(jsonValueOfflineReady)
                } else if let jsonValueOfflineReady = jsonMap["offlineReady"] as? String {
                    resultDecodedBuilder.offlineReady = UInt32(jsonValueOfflineReady)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.File.ImfileNotify.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.File.ImfileNotify.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfileHasOfflineReq : GeneratedMessage {
        public typealias BuilderType = Im.File.ImfileHasOfflineReq.Builder

        public static func == (lhs: Im.File.ImfileHasOfflineReq, rhs: Im.File.ImfileHasOfflineReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id: 	0x0509
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.File.ImfileHasOfflineReq.Builder {
            return Im.File.ImfileHasOfflineReq.classBuilder() as! Im.File.ImfileHasOfflineReq.Builder
        }
        public func getBuilder() -> Im.File.ImfileHasOfflineReq.Builder {
            return classBuilder() as! Im.File.ImfileHasOfflineReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileHasOfflineReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileHasOfflineReq.Builder()
        }
        public func toBuilder() throws -> Im.File.ImfileHasOfflineReq.Builder {
            return try Im.File.ImfileHasOfflineReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.File.ImfileHasOfflineReq) throws -> Im.File.ImfileHasOfflineReq.Builder {
            return try Im.File.ImfileHasOfflineReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileHasOfflineReq {
            return try Im.File.ImfileHasOfflineReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.File.ImfileHasOfflineReq {
            return try Im.File.ImfileHasOfflineReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.File.ImfileHasOfflineReq"
        }
        override public func className() -> String {
            return "Im.File.ImfileHasOfflineReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.File.ImfileHasOfflineReq = Im.File.ImfileHasOfflineReq()
            public func getMessage() -> Im.File.ImfileHasOfflineReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 	0x0509
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.File.ImfileHasOfflineReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.File.ImfileHasOfflineReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.File.ImfileHasOfflineReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.File.ImfileHasOfflineReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.File.ImfileHasOfflineReq.Builder {
                builderResult = Im.File.ImfileHasOfflineReq()
                return self
            }
            override public func clone() throws -> Im.File.ImfileHasOfflineReq.Builder {
                return try Im.File.ImfileHasOfflineReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.File.ImfileHasOfflineReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.File.ImfileHasOfflineReq {
                let returnMe:Im.File.ImfileHasOfflineReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.File.ImfileHasOfflineReq) throws -> Im.File.ImfileHasOfflineReq.Builder {
                if other == Im.File.ImfileHasOfflineReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileHasOfflineReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileHasOfflineReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileHasOfflineReq.Builder {
                let resultDecodedBuilder = Im.File.ImfileHasOfflineReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.File.ImfileHasOfflineReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.File.ImfileHasOfflineReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfileHasOfflineRsp : GeneratedMessage {
        public typealias BuilderType = Im.File.ImfileHasOfflineRsp.Builder

        public static func == (lhs: Im.File.ImfileHasOfflineRsp, rhs: Im.File.ImfileHasOfflineRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.offlineFileList == rhs.offlineFileList)
            fieldCheck = fieldCheck && (lhs.ipAddrList == rhs.ipAddrList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x050a
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var offlineFileList:Array<Im.BaseDefine.OfflineFileInfo>  = Array<Im.BaseDefine.OfflineFileInfo>()
        public fileprivate(set) var ipAddrList:Array<Im.BaseDefine.IpAddr>  = Array<Im.BaseDefine.IpAddr>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            var isInitOfflineFileList:Bool = true
            for oneElementOfflineFileList in offlineFileList {
                if !oneElementOfflineFileList.isInitialized() {
                    isInitOfflineFileList = false
                    break 
                }
            }
            if !isInitOfflineFileList {
                return isInitOfflineFileList
            }
            var isInitIpAddrList:Bool = true
            for oneElementIpAddrList in ipAddrList {
                if !oneElementIpAddrList.isInitialized() {
                    isInitIpAddrList = false
                    break 
                }
            }
            if !isInitIpAddrList {
                return isInitIpAddrList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            for oneElementOfflineFileList in offlineFileList {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementOfflineFileList)
            }
            for oneElementIpAddrList in ipAddrList {
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementIpAddrList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            for oneElementOfflineFileList in offlineFileList {
                serialize_size += oneElementOfflineFileList.computeMessageSize(fieldNumber: 2)
            }
            for oneElementIpAddrList in ipAddrList {
                serialize_size += oneElementIpAddrList.computeMessageSize(fieldNumber: 3)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.File.ImfileHasOfflineRsp.Builder {
            return Im.File.ImfileHasOfflineRsp.classBuilder() as! Im.File.ImfileHasOfflineRsp.Builder
        }
        public func getBuilder() -> Im.File.ImfileHasOfflineRsp.Builder {
            return classBuilder() as! Im.File.ImfileHasOfflineRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileHasOfflineRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileHasOfflineRsp.Builder()
        }
        public func toBuilder() throws -> Im.File.ImfileHasOfflineRsp.Builder {
            return try Im.File.ImfileHasOfflineRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.File.ImfileHasOfflineRsp) throws -> Im.File.ImfileHasOfflineRsp.Builder {
            return try Im.File.ImfileHasOfflineRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if !offlineFileList.isEmpty {
                var jsonArrayOfflineFileList:Array<Dictionary<String,Any>> = []
                for oneValueOfflineFileList in offlineFileList {
                    let ecodedMessageOfflineFileList = try oneValueOfflineFileList.encode()
                    jsonArrayOfflineFileList.append(ecodedMessageOfflineFileList)
                }
                jsonMap["offlineFileList"] = jsonArrayOfflineFileList
            }
            if !ipAddrList.isEmpty {
                var jsonArrayIpAddrList:Array<Dictionary<String,Any>> = []
                for oneValueIpAddrList in ipAddrList {
                    let ecodedMessageIpAddrList = try oneValueIpAddrList.encode()
                    jsonArrayIpAddrList.append(ecodedMessageIpAddrList)
                }
                jsonMap["ipAddrList"] = jsonArrayIpAddrList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileHasOfflineRsp {
            return try Im.File.ImfileHasOfflineRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.File.ImfileHasOfflineRsp {
            return try Im.File.ImfileHasOfflineRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            var offlineFileListElementIndex:Int = 0
            for oneElementOfflineFileList in offlineFileList {
                output += "\(indent) offlineFileList[\(offlineFileListElementIndex)] {\n"
                output += try oneElementOfflineFileList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                offlineFileListElementIndex += 1
            }
            var ipAddrListElementIndex:Int = 0
            for oneElementIpAddrList in ipAddrList {
                output += "\(indent) ipAddrList[\(ipAddrListElementIndex)] {\n"
                output += try oneElementIpAddrList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                ipAddrListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                for oneElementOfflineFileList in offlineFileList {
                    hashCode = (hashCode &* 31) &+ oneElementOfflineFileList.hashValue
                }
                for oneElementIpAddrList in ipAddrList {
                    hashCode = (hashCode &* 31) &+ oneElementIpAddrList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.File.ImfileHasOfflineRsp"
        }
        override public func className() -> String {
            return "Im.File.ImfileHasOfflineRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.File.ImfileHasOfflineRsp = Im.File.ImfileHasOfflineRsp()
            public func getMessage() -> Im.File.ImfileHasOfflineRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x050a
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.File.ImfileHasOfflineRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.File.ImfileHasOfflineRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var offlineFileList:Array<Im.BaseDefine.OfflineFileInfo> {
                get {
                    return builderResult.offlineFileList
                }
                set (value) {
                    builderResult.offlineFileList = value
                }
            }
            @discardableResult
            public func setOfflineFileList(_ value:Array<Im.BaseDefine.OfflineFileInfo>) -> Im.File.ImfileHasOfflineRsp.Builder {
                self.offlineFileList = value
                return self
            }
            @discardableResult
            public func clearOfflineFileList() -> Im.File.ImfileHasOfflineRsp.Builder {
                builderResult.offlineFileList.removeAll(keepingCapacity: false)
                return self
            }
            public var ipAddrList:Array<Im.BaseDefine.IpAddr> {
                get {
                    return builderResult.ipAddrList
                }
                set (value) {
                    builderResult.ipAddrList = value
                }
            }
            @discardableResult
            public func setIpAddrList(_ value:Array<Im.BaseDefine.IpAddr>) -> Im.File.ImfileHasOfflineRsp.Builder {
                self.ipAddrList = value
                return self
            }
            @discardableResult
            public func clearIpAddrList() -> Im.File.ImfileHasOfflineRsp.Builder {
                builderResult.ipAddrList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.File.ImfileHasOfflineRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.File.ImfileHasOfflineRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.File.ImfileHasOfflineRsp.Builder {
                builderResult = Im.File.ImfileHasOfflineRsp()
                return self
            }
            override public func clone() throws -> Im.File.ImfileHasOfflineRsp.Builder {
                return try Im.File.ImfileHasOfflineRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.File.ImfileHasOfflineRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.File.ImfileHasOfflineRsp {
                let returnMe:Im.File.ImfileHasOfflineRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.File.ImfileHasOfflineRsp) throws -> Im.File.ImfileHasOfflineRsp.Builder {
                if other == Im.File.ImfileHasOfflineRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if !other.offlineFileList.isEmpty  {
                     builderResult.offlineFileList += other.offlineFileList
                }
                if !other.ipAddrList.isEmpty  {
                     builderResult.ipAddrList += other.ipAddrList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileHasOfflineRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileHasOfflineRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 18:
                        let subBuilder = Im.BaseDefine.OfflineFileInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        offlineFileList.append(subBuilder.buildPartial())

                    case 26:
                        let subBuilder = Im.BaseDefine.IpAddr.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        ipAddrList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileHasOfflineRsp.Builder {
                let resultDecodedBuilder = Im.File.ImfileHasOfflineRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueOfflineFileList = jsonMap["offlineFileList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayOfflineFileList:Array<Im.BaseDefine.OfflineFileInfo> = []
                    for oneValueOfflineFileList in jsonValueOfflineFileList {
                        let messageFromStringOfflineFileList = try Im.BaseDefine.OfflineFileInfo.Builder.decodeToBuilder(jsonMap:oneValueOfflineFileList).build()

                        jsonArrayOfflineFileList.append(messageFromStringOfflineFileList)
                    }
                    resultDecodedBuilder.offlineFileList = jsonArrayOfflineFileList
                }
                if let jsonValueIpAddrList = jsonMap["ipAddrList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayIpAddrList:Array<Im.BaseDefine.IpAddr> = []
                    for oneValueIpAddrList in jsonValueIpAddrList {
                        let messageFromStringIpAddrList = try Im.BaseDefine.IpAddr.Builder.decodeToBuilder(jsonMap:oneValueIpAddrList).build()

                        jsonArrayIpAddrList.append(messageFromStringIpAddrList)
                    }
                    resultDecodedBuilder.ipAddrList = jsonArrayIpAddrList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.File.ImfileHasOfflineRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.File.ImfileHasOfflineRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfileAddOfflineReq : GeneratedMessage {
        public typealias BuilderType = Im.File.ImfileAddOfflineReq.Builder

        public static func == (lhs: Im.File.ImfileAddOfflineReq, rhs: Im.File.ImfileAddOfflineReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFromUserId == rhs.hasFromUserId) && (!lhs.hasFromUserId || lhs.fromUserId == rhs.fromUserId)
            fieldCheck = fieldCheck && (lhs.hasToUserId == rhs.hasToUserId) && (!lhs.hasToUserId || lhs.toUserId == rhs.toUserId)
            fieldCheck = fieldCheck && (lhs.hasTaskId == rhs.hasTaskId) && (!lhs.hasTaskId || lhs.taskId == rhs.taskId)
            fieldCheck = fieldCheck && (lhs.hasFileName == rhs.hasFileName) && (!lhs.hasFileName || lhs.fileName == rhs.fileName)
            fieldCheck = fieldCheck && (lhs.hasFileSize == rhs.hasFileSize) && (!lhs.hasFileSize || lhs.fileSize == rhs.fileSize)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x050b
        public fileprivate(set) var fromUserId:UInt32! = nil
        public fileprivate(set) var hasFromUserId:Bool = false

        public fileprivate(set) var toUserId:UInt32! = nil
        public fileprivate(set) var hasToUserId:Bool = false

        public fileprivate(set) var taskId:String! = nil
        public fileprivate(set) var hasTaskId:Bool = false

        public fileprivate(set) var fileName:String! = nil
        public fileprivate(set) var hasFileName:Bool = false

        public fileprivate(set) var fileSize:UInt32! = nil
        public fileprivate(set) var hasFileSize:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasFromUserId {
                return false
            }
            if !hasToUserId {
                return false
            }
            if !hasTaskId {
                return false
            }
            if !hasFileName {
                return false
            }
            if !hasFileSize {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFromUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:fromUserId)
            }
            if hasToUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:toUserId)
            }
            if hasTaskId {
                try codedOutputStream.writeString(fieldNumber: 3, value:taskId)
            }
            if hasFileName {
                try codedOutputStream.writeString(fieldNumber: 4, value:fileName)
            }
            if hasFileSize {
                try codedOutputStream.writeUInt32(fieldNumber: 5, value:fileSize)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFromUserId {
                serialize_size += fromUserId.computeUInt32Size(fieldNumber: 1)
            }
            if hasToUserId {
                serialize_size += toUserId.computeUInt32Size(fieldNumber: 2)
            }
            if hasTaskId {
                serialize_size += taskId.computeStringSize(fieldNumber: 3)
            }
            if hasFileName {
                serialize_size += fileName.computeStringSize(fieldNumber: 4)
            }
            if hasFileSize {
                serialize_size += fileSize.computeUInt32Size(fieldNumber: 5)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.File.ImfileAddOfflineReq.Builder {
            return Im.File.ImfileAddOfflineReq.classBuilder() as! Im.File.ImfileAddOfflineReq.Builder
        }
        public func getBuilder() -> Im.File.ImfileAddOfflineReq.Builder {
            return classBuilder() as! Im.File.ImfileAddOfflineReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileAddOfflineReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileAddOfflineReq.Builder()
        }
        public func toBuilder() throws -> Im.File.ImfileAddOfflineReq.Builder {
            return try Im.File.ImfileAddOfflineReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.File.ImfileAddOfflineReq) throws -> Im.File.ImfileAddOfflineReq.Builder {
            return try Im.File.ImfileAddOfflineReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFromUserId {
                jsonMap["fromUserId"] = UInt(fromUserId)
            }
            if hasToUserId {
                jsonMap["toUserId"] = UInt(toUserId)
            }
            if hasTaskId {
                jsonMap["taskId"] = taskId
            }
            if hasFileName {
                jsonMap["fileName"] = fileName
            }
            if hasFileSize {
                jsonMap["fileSize"] = UInt(fileSize)
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileAddOfflineReq {
            return try Im.File.ImfileAddOfflineReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.File.ImfileAddOfflineReq {
            return try Im.File.ImfileAddOfflineReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFromUserId {
                output += "\(indent) fromUserId: \(fromUserId) \n"
            }
            if hasToUserId {
                output += "\(indent) toUserId: \(toUserId) \n"
            }
            if hasTaskId {
                output += "\(indent) taskId: \(taskId) \n"
            }
            if hasFileName {
                output += "\(indent) fileName: \(fileName) \n"
            }
            if hasFileSize {
                output += "\(indent) fileSize: \(fileSize) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFromUserId {
                    hashCode = (hashCode &* 31) &+ fromUserId.hashValue
                }
                if hasToUserId {
                    hashCode = (hashCode &* 31) &+ toUserId.hashValue
                }
                if hasTaskId {
                    hashCode = (hashCode &* 31) &+ taskId.hashValue
                }
                if hasFileName {
                    hashCode = (hashCode &* 31) &+ fileName.hashValue
                }
                if hasFileSize {
                    hashCode = (hashCode &* 31) &+ fileSize.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.File.ImfileAddOfflineReq"
        }
        override public func className() -> String {
            return "Im.File.ImfileAddOfflineReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.File.ImfileAddOfflineReq = Im.File.ImfileAddOfflineReq()
            public func getMessage() -> Im.File.ImfileAddOfflineReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x050b
            public var fromUserId:UInt32 {
                get {
                    return builderResult.fromUserId
                }
                set (value) {
                    builderResult.hasFromUserId = true
                    builderResult.fromUserId = value
                }
            }
            public var hasFromUserId:Bool {
                get {
                    return builderResult.hasFromUserId
                }
            }
            @discardableResult
            public func setFromUserId(_ value:UInt32) -> Im.File.ImfileAddOfflineReq.Builder {
                self.fromUserId = value
                return self
            }
            @discardableResult
            public func clearFromUserId() -> Im.File.ImfileAddOfflineReq.Builder{
                builderResult.hasFromUserId = false
                builderResult.fromUserId = nil
                return self
            }
            public var toUserId:UInt32 {
                get {
                    return builderResult.toUserId
                }
                set (value) {
                    builderResult.hasToUserId = true
                    builderResult.toUserId = value
                }
            }
            public var hasToUserId:Bool {
                get {
                    return builderResult.hasToUserId
                }
            }
            @discardableResult
            public func setToUserId(_ value:UInt32) -> Im.File.ImfileAddOfflineReq.Builder {
                self.toUserId = value
                return self
            }
            @discardableResult
            public func clearToUserId() -> Im.File.ImfileAddOfflineReq.Builder{
                builderResult.hasToUserId = false
                builderResult.toUserId = nil
                return self
            }
            public var taskId:String {
                get {
                    return builderResult.taskId
                }
                set (value) {
                    builderResult.hasTaskId = true
                    builderResult.taskId = value
                }
            }
            public var hasTaskId:Bool {
                get {
                    return builderResult.hasTaskId
                }
            }
            @discardableResult
            public func setTaskId(_ value:String) -> Im.File.ImfileAddOfflineReq.Builder {
                self.taskId = value
                return self
            }
            @discardableResult
            public func clearTaskId() -> Im.File.ImfileAddOfflineReq.Builder{
                builderResult.hasTaskId = false
                builderResult.taskId = nil
                return self
            }
            public var fileName:String {
                get {
                    return builderResult.fileName
                }
                set (value) {
                    builderResult.hasFileName = true
                    builderResult.fileName = value
                }
            }
            public var hasFileName:Bool {
                get {
                    return builderResult.hasFileName
                }
            }
            @discardableResult
            public func setFileName(_ value:String) -> Im.File.ImfileAddOfflineReq.Builder {
                self.fileName = value
                return self
            }
            @discardableResult
            public func clearFileName() -> Im.File.ImfileAddOfflineReq.Builder{
                builderResult.hasFileName = false
                builderResult.fileName = nil
                return self
            }
            public var fileSize:UInt32 {
                get {
                    return builderResult.fileSize
                }
                set (value) {
                    builderResult.hasFileSize = true
                    builderResult.fileSize = value
                }
            }
            public var hasFileSize:Bool {
                get {
                    return builderResult.hasFileSize
                }
            }
            @discardableResult
            public func setFileSize(_ value:UInt32) -> Im.File.ImfileAddOfflineReq.Builder {
                self.fileSize = value
                return self
            }
            @discardableResult
            public func clearFileSize() -> Im.File.ImfileAddOfflineReq.Builder{
                builderResult.hasFileSize = false
                builderResult.fileSize = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.File.ImfileAddOfflineReq.Builder {
                builderResult = Im.File.ImfileAddOfflineReq()
                return self
            }
            override public func clone() throws -> Im.File.ImfileAddOfflineReq.Builder {
                return try Im.File.ImfileAddOfflineReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.File.ImfileAddOfflineReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.File.ImfileAddOfflineReq {
                let returnMe:Im.File.ImfileAddOfflineReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.File.ImfileAddOfflineReq) throws -> Im.File.ImfileAddOfflineReq.Builder {
                if other == Im.File.ImfileAddOfflineReq() {
                    return self
                }
                if other.hasFromUserId {
                    fromUserId = other.fromUserId
                }
                if other.hasToUserId {
                    toUserId = other.toUserId
                }
                if other.hasTaskId {
                    taskId = other.taskId
                }
                if other.hasFileName {
                    fileName = other.fileName
                }
                if other.hasFileSize {
                    fileSize = other.fileSize
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileAddOfflineReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileAddOfflineReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        fromUserId = try codedInputStream.readUInt32()

                    case 16:
                        toUserId = try codedInputStream.readUInt32()

                    case 26:
                        taskId = try codedInputStream.readString()

                    case 34:
                        fileName = try codedInputStream.readString()

                    case 40:
                        fileSize = try codedInputStream.readUInt32()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileAddOfflineReq.Builder {
                let resultDecodedBuilder = Im.File.ImfileAddOfflineReq.Builder()
                if let jsonValueFromUserId = jsonMap["fromUserId"] as? UInt {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)
                } else if let jsonValueFromUserId = jsonMap["fromUserId"] as? String {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)!
                }
                if let jsonValueToUserId = jsonMap["toUserId"] as? UInt {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)
                } else if let jsonValueToUserId = jsonMap["toUserId"] as? String {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)!
                }
                if let jsonValueTaskId = jsonMap["taskId"] as? String {
                    resultDecodedBuilder.taskId = jsonValueTaskId
                }
                if let jsonValueFileName = jsonMap["fileName"] as? String {
                    resultDecodedBuilder.fileName = jsonValueFileName
                }
                if let jsonValueFileSize = jsonMap["fileSize"] as? UInt {
                    resultDecodedBuilder.fileSize = UInt32(jsonValueFileSize)
                } else if let jsonValueFileSize = jsonMap["fileSize"] as? String {
                    resultDecodedBuilder.fileSize = UInt32(jsonValueFileSize)!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.File.ImfileAddOfflineReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.File.ImfileAddOfflineReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImfileDelOfflineReq : GeneratedMessage {
        public typealias BuilderType = Im.File.ImfileDelOfflineReq.Builder

        public static func == (lhs: Im.File.ImfileDelOfflineReq, rhs: Im.File.ImfileDelOfflineReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasFromUserId == rhs.hasFromUserId) && (!lhs.hasFromUserId || lhs.fromUserId == rhs.fromUserId)
            fieldCheck = fieldCheck && (lhs.hasToUserId == rhs.hasToUserId) && (!lhs.hasToUserId || lhs.toUserId == rhs.toUserId)
            fieldCheck = fieldCheck && (lhs.hasTaskId == rhs.hasTaskId) && (!lhs.hasTaskId || lhs.taskId == rhs.taskId)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:	0x050c
        public fileprivate(set) var fromUserId:UInt32! = nil
        public fileprivate(set) var hasFromUserId:Bool = false

        public fileprivate(set) var toUserId:UInt32! = nil
        public fileprivate(set) var hasToUserId:Bool = false

        public fileprivate(set) var taskId:String! = nil
        public fileprivate(set) var hasTaskId:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasFromUserId {
                return false
            }
            if !hasToUserId {
                return false
            }
            if !hasTaskId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasFromUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:fromUserId)
            }
            if hasToUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:toUserId)
            }
            if hasTaskId {
                try codedOutputStream.writeString(fieldNumber: 3, value:taskId)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasFromUserId {
                serialize_size += fromUserId.computeUInt32Size(fieldNumber: 1)
            }
            if hasToUserId {
                serialize_size += toUserId.computeUInt32Size(fieldNumber: 2)
            }
            if hasTaskId {
                serialize_size += taskId.computeStringSize(fieldNumber: 3)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.File.ImfileDelOfflineReq.Builder {
            return Im.File.ImfileDelOfflineReq.classBuilder() as! Im.File.ImfileDelOfflineReq.Builder
        }
        public func getBuilder() -> Im.File.ImfileDelOfflineReq.Builder {
            return classBuilder() as! Im.File.ImfileDelOfflineReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileDelOfflineReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.File.ImfileDelOfflineReq.Builder()
        }
        public func toBuilder() throws -> Im.File.ImfileDelOfflineReq.Builder {
            return try Im.File.ImfileDelOfflineReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.File.ImfileDelOfflineReq) throws -> Im.File.ImfileDelOfflineReq.Builder {
            return try Im.File.ImfileDelOfflineReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasFromUserId {
                jsonMap["fromUserId"] = UInt(fromUserId)
            }
            if hasToUserId {
                jsonMap["toUserId"] = UInt(toUserId)
            }
            if hasTaskId {
                jsonMap["taskId"] = taskId
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileDelOfflineReq {
            return try Im.File.ImfileDelOfflineReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.File.ImfileDelOfflineReq {
            return try Im.File.ImfileDelOfflineReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasFromUserId {
                output += "\(indent) fromUserId: \(fromUserId) \n"
            }
            if hasToUserId {
                output += "\(indent) toUserId: \(toUserId) \n"
            }
            if hasTaskId {
                output += "\(indent) taskId: \(taskId) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasFromUserId {
                    hashCode = (hashCode &* 31) &+ fromUserId.hashValue
                }
                if hasToUserId {
                    hashCode = (hashCode &* 31) &+ toUserId.hashValue
                }
                if hasTaskId {
                    hashCode = (hashCode &* 31) &+ taskId.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.File.ImfileDelOfflineReq"
        }
        override public func className() -> String {
            return "Im.File.ImfileDelOfflineReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.File.ImfileDelOfflineReq = Im.File.ImfileDelOfflineReq()
            public func getMessage() -> Im.File.ImfileDelOfflineReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:	0x050c
            public var fromUserId:UInt32 {
                get {
                    return builderResult.fromUserId
                }
                set (value) {
                    builderResult.hasFromUserId = true
                    builderResult.fromUserId = value
                }
            }
            public var hasFromUserId:Bool {
                get {
                    return builderResult.hasFromUserId
                }
            }
            @discardableResult
            public func setFromUserId(_ value:UInt32) -> Im.File.ImfileDelOfflineReq.Builder {
                self.fromUserId = value
                return self
            }
            @discardableResult
            public func clearFromUserId() -> Im.File.ImfileDelOfflineReq.Builder{
                builderResult.hasFromUserId = false
                builderResult.fromUserId = nil
                return self
            }
            public var toUserId:UInt32 {
                get {
                    return builderResult.toUserId
                }
                set (value) {
                    builderResult.hasToUserId = true
                    builderResult.toUserId = value
                }
            }
            public var hasToUserId:Bool {
                get {
                    return builderResult.hasToUserId
                }
            }
            @discardableResult
            public func setToUserId(_ value:UInt32) -> Im.File.ImfileDelOfflineReq.Builder {
                self.toUserId = value
                return self
            }
            @discardableResult
            public func clearToUserId() -> Im.File.ImfileDelOfflineReq.Builder{
                builderResult.hasToUserId = false
                builderResult.toUserId = nil
                return self
            }
            public var taskId:String {
                get {
                    return builderResult.taskId
                }
                set (value) {
                    builderResult.hasTaskId = true
                    builderResult.taskId = value
                }
            }
            public var hasTaskId:Bool {
                get {
                    return builderResult.hasTaskId
                }
            }
            @discardableResult
            public func setTaskId(_ value:String) -> Im.File.ImfileDelOfflineReq.Builder {
                self.taskId = value
                return self
            }
            @discardableResult
            public func clearTaskId() -> Im.File.ImfileDelOfflineReq.Builder{
                builderResult.hasTaskId = false
                builderResult.taskId = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.File.ImfileDelOfflineReq.Builder {
                builderResult = Im.File.ImfileDelOfflineReq()
                return self
            }
            override public func clone() throws -> Im.File.ImfileDelOfflineReq.Builder {
                return try Im.File.ImfileDelOfflineReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.File.ImfileDelOfflineReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.File.ImfileDelOfflineReq {
                let returnMe:Im.File.ImfileDelOfflineReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.File.ImfileDelOfflineReq) throws -> Im.File.ImfileDelOfflineReq.Builder {
                if other == Im.File.ImfileDelOfflineReq() {
                    return self
                }
                if other.hasFromUserId {
                    fromUserId = other.fromUserId
                }
                if other.hasToUserId {
                    toUserId = other.toUserId
                }
                if other.hasTaskId {
                    taskId = other.taskId
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileDelOfflineReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileDelOfflineReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        fromUserId = try codedInputStream.readUInt32()

                    case 16:
                        toUserId = try codedInputStream.readUInt32()

                    case 26:
                        taskId = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.File.ImfileDelOfflineReq.Builder {
                let resultDecodedBuilder = Im.File.ImfileDelOfflineReq.Builder()
                if let jsonValueFromUserId = jsonMap["fromUserId"] as? UInt {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)
                } else if let jsonValueFromUserId = jsonMap["fromUserId"] as? String {
                    resultDecodedBuilder.fromUserId = UInt32(jsonValueFromUserId)!
                }
                if let jsonValueToUserId = jsonMap["toUserId"] as? UInt {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)
                } else if let jsonValueToUserId = jsonMap["toUserId"] as? String {
                    resultDecodedBuilder.toUserId = UInt32(jsonValueToUserId)!
                }
                if let jsonValueTaskId = jsonMap["taskId"] as? String {
                    resultDecodedBuilder.taskId = jsonValueTaskId
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.File.ImfileDelOfflineReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.File.ImfileDelOfflineReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Im.File.ImfileLoginReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.File.ImfileLoginReq> {
        var mergedArray = Array<Im.File.ImfileLoginReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.File.ImfileLoginReq? {
        return try Im.File.ImfileLoginReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.File.ImfileLoginReq {
        return try Im.File.ImfileLoginReq.Builder().mergeFrom(data: data, extensionRegistry:Im.File.ImfileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileLoginReq {
        return try Im.File.ImfileLoginReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.File.ImfileLoginReq {
        return try Im.File.ImfileLoginReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileLoginReq {
        return try Im.File.ImfileLoginReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileLoginReq {
        return try Im.File.ImfileLoginReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileLoginReq {
        return try Im.File.ImfileLoginReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "taskId": return self.taskId
        case "fileRole": return self.fileRole
        default: return nil
        }
    }
}
extension Im.File.ImfileLoginReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.File.ImfileLoginReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "taskId": return self.taskId
            case "fileRole": return self.fileRole
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "taskId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.taskId = newSubscriptValue
            case "fileRole":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.ClientFileRole else {
                    return
                }
                self.fileRole = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.File.ImfileLoginRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.File.ImfileLoginRsp> {
        var mergedArray = Array<Im.File.ImfileLoginRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.File.ImfileLoginRsp? {
        return try Im.File.ImfileLoginRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.File.ImfileLoginRsp {
        return try Im.File.ImfileLoginRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.File.ImfileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileLoginRsp {
        return try Im.File.ImfileLoginRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.File.ImfileLoginRsp {
        return try Im.File.ImfileLoginRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileLoginRsp {
        return try Im.File.ImfileLoginRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileLoginRsp {
        return try Im.File.ImfileLoginRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileLoginRsp {
        return try Im.File.ImfileLoginRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "resultCode": return self.resultCode
        case "taskId": return self.taskId
        default: return nil
        }
    }
}
extension Im.File.ImfileLoginRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.File.ImfileLoginRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "resultCode": return self.resultCode
            case "taskId": return self.taskId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "taskId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.taskId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.File.ImfileState: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.File.ImfileState> {
        var mergedArray = Array<Im.File.ImfileState>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.File.ImfileState? {
        return try Im.File.ImfileState.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.File.ImfileState {
        return try Im.File.ImfileState.Builder().mergeFrom(data: data, extensionRegistry:Im.File.ImfileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileState {
        return try Im.File.ImfileState.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.File.ImfileState {
        return try Im.File.ImfileState.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileState {
        return try Im.File.ImfileState.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileState {
        return try Im.File.ImfileState.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileState {
        return try Im.File.ImfileState.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "state": return self.state
        case "taskId": return self.taskId
        case "userId": return self.userId
        default: return nil
        }
    }
}
extension Im.File.ImfileState.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.File.ImfileState
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "state": return self.state
            case "taskId": return self.taskId
            case "userId": return self.userId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "state":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.ClientFileState else {
                    return
                }
                self.state = newSubscriptValue
            case "taskId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.taskId = newSubscriptValue
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.File.ImfilePullDataReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.File.ImfilePullDataReq> {
        var mergedArray = Array<Im.File.ImfilePullDataReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.File.ImfilePullDataReq? {
        return try Im.File.ImfilePullDataReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.File.ImfilePullDataReq {
        return try Im.File.ImfilePullDataReq.Builder().mergeFrom(data: data, extensionRegistry:Im.File.ImfileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfilePullDataReq {
        return try Im.File.ImfilePullDataReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.File.ImfilePullDataReq {
        return try Im.File.ImfilePullDataReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfilePullDataReq {
        return try Im.File.ImfilePullDataReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfilePullDataReq {
        return try Im.File.ImfilePullDataReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfilePullDataReq {
        return try Im.File.ImfilePullDataReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "taskId": return self.taskId
        case "userId": return self.userId
        case "transMode": return self.transMode
        case "offset": return self.offset
        case "dataSize": return self.dataSize
        default: return nil
        }
    }
}
extension Im.File.ImfilePullDataReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.File.ImfilePullDataReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "taskId": return self.taskId
            case "userId": return self.userId
            case "transMode": return self.transMode
            case "offset": return self.offset
            case "dataSize": return self.dataSize
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "taskId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.taskId = newSubscriptValue
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "transMode":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.TransferFileType else {
                    return
                }
                self.transMode = newSubscriptValue
            case "offset":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.offset = newSubscriptValue
            case "dataSize":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.dataSize = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.File.ImfilePullDataRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.File.ImfilePullDataRsp> {
        var mergedArray = Array<Im.File.ImfilePullDataRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.File.ImfilePullDataRsp? {
        return try Im.File.ImfilePullDataRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.File.ImfilePullDataRsp {
        return try Im.File.ImfilePullDataRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.File.ImfileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfilePullDataRsp {
        return try Im.File.ImfilePullDataRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.File.ImfilePullDataRsp {
        return try Im.File.ImfilePullDataRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfilePullDataRsp {
        return try Im.File.ImfilePullDataRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfilePullDataRsp {
        return try Im.File.ImfilePullDataRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfilePullDataRsp {
        return try Im.File.ImfilePullDataRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "resultCode": return self.resultCode
        case "taskId": return self.taskId
        case "userId": return self.userId
        case "offset": return self.offset
        case "fileData": return self.fileData
        default: return nil
        }
    }
}
extension Im.File.ImfilePullDataRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.File.ImfilePullDataRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "resultCode": return self.resultCode
            case "taskId": return self.taskId
            case "userId": return self.userId
            case "offset": return self.offset
            case "fileData": return self.fileData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "taskId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.taskId = newSubscriptValue
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "offset":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.offset = newSubscriptValue
            case "fileData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.fileData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.File.ImfileReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.File.ImfileReq> {
        var mergedArray = Array<Im.File.ImfileReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.File.ImfileReq? {
        return try Im.File.ImfileReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.File.ImfileReq {
        return try Im.File.ImfileReq.Builder().mergeFrom(data: data, extensionRegistry:Im.File.ImfileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileReq {
        return try Im.File.ImfileReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.File.ImfileReq {
        return try Im.File.ImfileReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileReq {
        return try Im.File.ImfileReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileReq {
        return try Im.File.ImfileReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileReq {
        return try Im.File.ImfileReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "fromUserId": return self.fromUserId
        case "toUserId": return self.toUserId
        case "fileName": return self.fileName
        case "fileSize": return self.fileSize
        case "transMode": return self.transMode
        default: return nil
        }
    }
}
extension Im.File.ImfileReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.File.ImfileReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "fromUserId": return self.fromUserId
            case "toUserId": return self.toUserId
            case "fileName": return self.fileName
            case "fileSize": return self.fileSize
            case "transMode": return self.transMode
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "fromUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fromUserId = newSubscriptValue
            case "toUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.toUserId = newSubscriptValue
            case "fileName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fileName = newSubscriptValue
            case "fileSize":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fileSize = newSubscriptValue
            case "transMode":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.TransferFileType else {
                    return
                }
                self.transMode = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.File.ImfileRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.File.ImfileRsp> {
        var mergedArray = Array<Im.File.ImfileRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.File.ImfileRsp? {
        return try Im.File.ImfileRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.File.ImfileRsp {
        return try Im.File.ImfileRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.File.ImfileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileRsp {
        return try Im.File.ImfileRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.File.ImfileRsp {
        return try Im.File.ImfileRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileRsp {
        return try Im.File.ImfileRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileRsp {
        return try Im.File.ImfileRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileRsp {
        return try Im.File.ImfileRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "resultCode": return self.resultCode
        case "fromUserId": return self.fromUserId
        case "toUserId": return self.toUserId
        case "fileName": return self.fileName
        case "taskId": return self.taskId
        case "ipAddrList": return self.ipAddrList
        case "transMode": return self.transMode
        default: return nil
        }
    }
}
extension Im.File.ImfileRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.File.ImfileRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "resultCode": return self.resultCode
            case "fromUserId": return self.fromUserId
            case "toUserId": return self.toUserId
            case "fileName": return self.fileName
            case "taskId": return self.taskId
            case "ipAddrList": return self.ipAddrList
            case "transMode": return self.transMode
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "fromUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fromUserId = newSubscriptValue
            case "toUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.toUserId = newSubscriptValue
            case "fileName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fileName = newSubscriptValue
            case "taskId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.taskId = newSubscriptValue
            case "ipAddrList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.IpAddr> else {
                    return
                }
                self.ipAddrList = newSubscriptValue
            case "transMode":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.TransferFileType else {
                    return
                }
                self.transMode = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.File.ImfileNotify: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.File.ImfileNotify> {
        var mergedArray = Array<Im.File.ImfileNotify>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.File.ImfileNotify? {
        return try Im.File.ImfileNotify.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.File.ImfileNotify {
        return try Im.File.ImfileNotify.Builder().mergeFrom(data: data, extensionRegistry:Im.File.ImfileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileNotify {
        return try Im.File.ImfileNotify.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.File.ImfileNotify {
        return try Im.File.ImfileNotify.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileNotify {
        return try Im.File.ImfileNotify.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileNotify {
        return try Im.File.ImfileNotify.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileNotify {
        return try Im.File.ImfileNotify.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "fromUserId": return self.fromUserId
        case "toUserId": return self.toUserId
        case "fileName": return self.fileName
        case "fileSize": return self.fileSize
        case "taskId": return self.taskId
        case "ipAddrList": return self.ipAddrList
        case "transMode": return self.transMode
        case "offlineReady": return self.offlineReady
        default: return nil
        }
    }
}
extension Im.File.ImfileNotify.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.File.ImfileNotify
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "fromUserId": return self.fromUserId
            case "toUserId": return self.toUserId
            case "fileName": return self.fileName
            case "fileSize": return self.fileSize
            case "taskId": return self.taskId
            case "ipAddrList": return self.ipAddrList
            case "transMode": return self.transMode
            case "offlineReady": return self.offlineReady
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "fromUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fromUserId = newSubscriptValue
            case "toUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.toUserId = newSubscriptValue
            case "fileName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fileName = newSubscriptValue
            case "fileSize":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fileSize = newSubscriptValue
            case "taskId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.taskId = newSubscriptValue
            case "ipAddrList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.IpAddr> else {
                    return
                }
                self.ipAddrList = newSubscriptValue
            case "transMode":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.TransferFileType else {
                    return
                }
                self.transMode = newSubscriptValue
            case "offlineReady":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.offlineReady = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.File.ImfileHasOfflineReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.File.ImfileHasOfflineReq> {
        var mergedArray = Array<Im.File.ImfileHasOfflineReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.File.ImfileHasOfflineReq? {
        return try Im.File.ImfileHasOfflineReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.File.ImfileHasOfflineReq {
        return try Im.File.ImfileHasOfflineReq.Builder().mergeFrom(data: data, extensionRegistry:Im.File.ImfileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileHasOfflineReq {
        return try Im.File.ImfileHasOfflineReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.File.ImfileHasOfflineReq {
        return try Im.File.ImfileHasOfflineReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileHasOfflineReq {
        return try Im.File.ImfileHasOfflineReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileHasOfflineReq {
        return try Im.File.ImfileHasOfflineReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileHasOfflineReq {
        return try Im.File.ImfileHasOfflineReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.File.ImfileHasOfflineReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.File.ImfileHasOfflineReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.File.ImfileHasOfflineRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.File.ImfileHasOfflineRsp> {
        var mergedArray = Array<Im.File.ImfileHasOfflineRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.File.ImfileHasOfflineRsp? {
        return try Im.File.ImfileHasOfflineRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.File.ImfileHasOfflineRsp {
        return try Im.File.ImfileHasOfflineRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.File.ImfileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileHasOfflineRsp {
        return try Im.File.ImfileHasOfflineRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.File.ImfileHasOfflineRsp {
        return try Im.File.ImfileHasOfflineRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileHasOfflineRsp {
        return try Im.File.ImfileHasOfflineRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileHasOfflineRsp {
        return try Im.File.ImfileHasOfflineRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileHasOfflineRsp {
        return try Im.File.ImfileHasOfflineRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "offlineFileList": return self.offlineFileList
        case "ipAddrList": return self.ipAddrList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.File.ImfileHasOfflineRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.File.ImfileHasOfflineRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "offlineFileList": return self.offlineFileList
            case "ipAddrList": return self.ipAddrList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "offlineFileList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.OfflineFileInfo> else {
                    return
                }
                self.offlineFileList = newSubscriptValue
            case "ipAddrList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.IpAddr> else {
                    return
                }
                self.ipAddrList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.File.ImfileAddOfflineReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.File.ImfileAddOfflineReq> {
        var mergedArray = Array<Im.File.ImfileAddOfflineReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.File.ImfileAddOfflineReq? {
        return try Im.File.ImfileAddOfflineReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.File.ImfileAddOfflineReq {
        return try Im.File.ImfileAddOfflineReq.Builder().mergeFrom(data: data, extensionRegistry:Im.File.ImfileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileAddOfflineReq {
        return try Im.File.ImfileAddOfflineReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.File.ImfileAddOfflineReq {
        return try Im.File.ImfileAddOfflineReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileAddOfflineReq {
        return try Im.File.ImfileAddOfflineReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileAddOfflineReq {
        return try Im.File.ImfileAddOfflineReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileAddOfflineReq {
        return try Im.File.ImfileAddOfflineReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "fromUserId": return self.fromUserId
        case "toUserId": return self.toUserId
        case "taskId": return self.taskId
        case "fileName": return self.fileName
        case "fileSize": return self.fileSize
        default: return nil
        }
    }
}
extension Im.File.ImfileAddOfflineReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.File.ImfileAddOfflineReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "fromUserId": return self.fromUserId
            case "toUserId": return self.toUserId
            case "taskId": return self.taskId
            case "fileName": return self.fileName
            case "fileSize": return self.fileSize
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "fromUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fromUserId = newSubscriptValue
            case "toUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.toUserId = newSubscriptValue
            case "taskId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.taskId = newSubscriptValue
            case "fileName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.fileName = newSubscriptValue
            case "fileSize":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fileSize = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.File.ImfileDelOfflineReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.File.ImfileDelOfflineReq> {
        var mergedArray = Array<Im.File.ImfileDelOfflineReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.File.ImfileDelOfflineReq? {
        return try Im.File.ImfileDelOfflineReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.File.ImfileDelOfflineReq {
        return try Im.File.ImfileDelOfflineReq.Builder().mergeFrom(data: data, extensionRegistry:Im.File.ImfileRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileDelOfflineReq {
        return try Im.File.ImfileDelOfflineReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.File.ImfileDelOfflineReq {
        return try Im.File.ImfileDelOfflineReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileDelOfflineReq {
        return try Im.File.ImfileDelOfflineReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.File.ImfileDelOfflineReq {
        return try Im.File.ImfileDelOfflineReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.File.ImfileDelOfflineReq {
        return try Im.File.ImfileDelOfflineReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "fromUserId": return self.fromUserId
        case "toUserId": return self.toUserId
        case "taskId": return self.taskId
        default: return nil
        }
    }
}
extension Im.File.ImfileDelOfflineReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.File.ImfileDelOfflineReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "fromUserId": return self.fromUserId
            case "toUserId": return self.toUserId
            case "taskId": return self.taskId
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "fromUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.fromUserId = newSubscriptValue
            case "toUserId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.toUserId = newSubscriptValue
            case "taskId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.taskId = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
