/// Generated by the Protocol Buffers 3.3.2 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.22
/// Source file "IM.Group.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers

public extension Im {
    public struct Group {}
}

public extension Im.Group {
    public struct ImgroupRoot {
        public static let `default` = ImgroupRoot()
        public var extensionRegistry:ExtensionRegistry

        init() {
            extensionRegistry = ExtensionRegistry()
            registerAllExtensions(registry: extensionRegistry)
            Im.BaseDefine.ImbaseDefineRoot.default.registerAllExtensions(registry: extensionRegistry)
        }
        public func registerAllExtensions(registry: ExtensionRegistry) {
        }
    }

    final public class ImnormalGroupListReq : GeneratedMessage {
        public typealias BuilderType = Im.Group.ImnormalGroupListReq.Builder

        public static func == (lhs: Im.Group.ImnormalGroupListReq, rhs: Im.Group.ImnormalGroupListReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x0401
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Group.ImnormalGroupListReq.Builder {
            return Im.Group.ImnormalGroupListReq.classBuilder() as! Im.Group.ImnormalGroupListReq.Builder
        }
        public func getBuilder() -> Im.Group.ImnormalGroupListReq.Builder {
            return classBuilder() as! Im.Group.ImnormalGroupListReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImnormalGroupListReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImnormalGroupListReq.Builder()
        }
        public func toBuilder() throws -> Im.Group.ImnormalGroupListReq.Builder {
            return try Im.Group.ImnormalGroupListReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Group.ImnormalGroupListReq) throws -> Im.Group.ImnormalGroupListReq.Builder {
            return try Im.Group.ImnormalGroupListReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImnormalGroupListReq {
            return try Im.Group.ImnormalGroupListReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Group.ImnormalGroupListReq {
            return try Im.Group.ImnormalGroupListReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Group.ImnormalGroupListReq"
        }
        override public func className() -> String {
            return "Im.Group.ImnormalGroupListReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Group.ImnormalGroupListReq = Im.Group.ImnormalGroupListReq()
            public func getMessage() -> Im.Group.ImnormalGroupListReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x0401
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Group.ImnormalGroupListReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Group.ImnormalGroupListReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Group.ImnormalGroupListReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Group.ImnormalGroupListReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Group.ImnormalGroupListReq.Builder {
                builderResult = Im.Group.ImnormalGroupListReq()
                return self
            }
            override public func clone() throws -> Im.Group.ImnormalGroupListReq.Builder {
                return try Im.Group.ImnormalGroupListReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Group.ImnormalGroupListReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Group.ImnormalGroupListReq {
                let returnMe:Im.Group.ImnormalGroupListReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Group.ImnormalGroupListReq) throws -> Im.Group.ImnormalGroupListReq.Builder {
                if other == Im.Group.ImnormalGroupListReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImnormalGroupListReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImnormalGroupListReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImnormalGroupListReq.Builder {
                let resultDecodedBuilder = Im.Group.ImnormalGroupListReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Group.ImnormalGroupListReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Group.ImnormalGroupListReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImnormalGroupListRsp : GeneratedMessage {
        public typealias BuilderType = Im.Group.ImnormalGroupListRsp.Builder

        public static func == (lhs: Im.Group.ImnormalGroupListRsp, rhs: Im.Group.ImnormalGroupListRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.groupVersionList == rhs.groupVersionList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x0402
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var groupVersionList:Array<Im.BaseDefine.GroupVersionInfo>  = Array<Im.BaseDefine.GroupVersionInfo>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            var isInitGroupVersionList:Bool = true
            for oneElementGroupVersionList in groupVersionList {
                if !oneElementGroupVersionList.isInitialized() {
                    isInitGroupVersionList = false
                    break 
                }
            }
            if !isInitGroupVersionList {
                return isInitGroupVersionList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            for oneElementGroupVersionList in groupVersionList {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementGroupVersionList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            for oneElementGroupVersionList in groupVersionList {
                serialize_size += oneElementGroupVersionList.computeMessageSize(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Group.ImnormalGroupListRsp.Builder {
            return Im.Group.ImnormalGroupListRsp.classBuilder() as! Im.Group.ImnormalGroupListRsp.Builder
        }
        public func getBuilder() -> Im.Group.ImnormalGroupListRsp.Builder {
            return classBuilder() as! Im.Group.ImnormalGroupListRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImnormalGroupListRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImnormalGroupListRsp.Builder()
        }
        public func toBuilder() throws -> Im.Group.ImnormalGroupListRsp.Builder {
            return try Im.Group.ImnormalGroupListRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Group.ImnormalGroupListRsp) throws -> Im.Group.ImnormalGroupListRsp.Builder {
            return try Im.Group.ImnormalGroupListRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if !groupVersionList.isEmpty {
                var jsonArrayGroupVersionList:Array<Dictionary<String,Any>> = []
                for oneValueGroupVersionList in groupVersionList {
                    let ecodedMessageGroupVersionList = try oneValueGroupVersionList.encode()
                    jsonArrayGroupVersionList.append(ecodedMessageGroupVersionList)
                }
                jsonMap["groupVersionList"] = jsonArrayGroupVersionList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImnormalGroupListRsp {
            return try Im.Group.ImnormalGroupListRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Group.ImnormalGroupListRsp {
            return try Im.Group.ImnormalGroupListRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            var groupVersionListElementIndex:Int = 0
            for oneElementGroupVersionList in groupVersionList {
                output += "\(indent) groupVersionList[\(groupVersionListElementIndex)] {\n"
                output += try oneElementGroupVersionList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                groupVersionListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                for oneElementGroupVersionList in groupVersionList {
                    hashCode = (hashCode &* 31) &+ oneElementGroupVersionList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Group.ImnormalGroupListRsp"
        }
        override public func className() -> String {
            return "Im.Group.ImnormalGroupListRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Group.ImnormalGroupListRsp = Im.Group.ImnormalGroupListRsp()
            public func getMessage() -> Im.Group.ImnormalGroupListRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x0402
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Group.ImnormalGroupListRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Group.ImnormalGroupListRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var groupVersionList:Array<Im.BaseDefine.GroupVersionInfo> {
                get {
                    return builderResult.groupVersionList
                }
                set (value) {
                    builderResult.groupVersionList = value
                }
            }
            @discardableResult
            public func setGroupVersionList(_ value:Array<Im.BaseDefine.GroupVersionInfo>) -> Im.Group.ImnormalGroupListRsp.Builder {
                self.groupVersionList = value
                return self
            }
            @discardableResult
            public func clearGroupVersionList() -> Im.Group.ImnormalGroupListRsp.Builder {
                builderResult.groupVersionList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Group.ImnormalGroupListRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Group.ImnormalGroupListRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Group.ImnormalGroupListRsp.Builder {
                builderResult = Im.Group.ImnormalGroupListRsp()
                return self
            }
            override public func clone() throws -> Im.Group.ImnormalGroupListRsp.Builder {
                return try Im.Group.ImnormalGroupListRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Group.ImnormalGroupListRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Group.ImnormalGroupListRsp {
                let returnMe:Im.Group.ImnormalGroupListRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Group.ImnormalGroupListRsp) throws -> Im.Group.ImnormalGroupListRsp.Builder {
                if other == Im.Group.ImnormalGroupListRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if !other.groupVersionList.isEmpty  {
                     builderResult.groupVersionList += other.groupVersionList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImnormalGroupListRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImnormalGroupListRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 18:
                        let subBuilder = Im.BaseDefine.GroupVersionInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        groupVersionList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImnormalGroupListRsp.Builder {
                let resultDecodedBuilder = Im.Group.ImnormalGroupListRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueGroupVersionList = jsonMap["groupVersionList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayGroupVersionList:Array<Im.BaseDefine.GroupVersionInfo> = []
                    for oneValueGroupVersionList in jsonValueGroupVersionList {
                        let messageFromStringGroupVersionList = try Im.BaseDefine.GroupVersionInfo.Builder.decodeToBuilder(jsonMap:oneValueGroupVersionList).build()

                        jsonArrayGroupVersionList.append(messageFromStringGroupVersionList)
                    }
                    resultDecodedBuilder.groupVersionList = jsonArrayGroupVersionList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Group.ImnormalGroupListRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Group.ImnormalGroupListRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgroupInfoListReq : GeneratedMessage {
        public typealias BuilderType = Im.Group.ImgroupInfoListReq.Builder

        public static func == (lhs: Im.Group.ImgroupInfoListReq, rhs: Im.Group.ImgroupInfoListReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.groupVersionList == rhs.groupVersionList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x0403
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var groupVersionList:Array<Im.BaseDefine.GroupVersionInfo>  = Array<Im.BaseDefine.GroupVersionInfo>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            var isInitGroupVersionList:Bool = true
            for oneElementGroupVersionList in groupVersionList {
                if !oneElementGroupVersionList.isInitialized() {
                    isInitGroupVersionList = false
                    break 
                }
            }
            if !isInitGroupVersionList {
                return isInitGroupVersionList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            for oneElementGroupVersionList in groupVersionList {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementGroupVersionList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            for oneElementGroupVersionList in groupVersionList {
                serialize_size += oneElementGroupVersionList.computeMessageSize(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Group.ImgroupInfoListReq.Builder {
            return Im.Group.ImgroupInfoListReq.classBuilder() as! Im.Group.ImgroupInfoListReq.Builder
        }
        public func getBuilder() -> Im.Group.ImgroupInfoListReq.Builder {
            return classBuilder() as! Im.Group.ImgroupInfoListReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupInfoListReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupInfoListReq.Builder()
        }
        public func toBuilder() throws -> Im.Group.ImgroupInfoListReq.Builder {
            return try Im.Group.ImgroupInfoListReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Group.ImgroupInfoListReq) throws -> Im.Group.ImgroupInfoListReq.Builder {
            return try Im.Group.ImgroupInfoListReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if !groupVersionList.isEmpty {
                var jsonArrayGroupVersionList:Array<Dictionary<String,Any>> = []
                for oneValueGroupVersionList in groupVersionList {
                    let ecodedMessageGroupVersionList = try oneValueGroupVersionList.encode()
                    jsonArrayGroupVersionList.append(ecodedMessageGroupVersionList)
                }
                jsonMap["groupVersionList"] = jsonArrayGroupVersionList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupInfoListReq {
            return try Im.Group.ImgroupInfoListReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Group.ImgroupInfoListReq {
            return try Im.Group.ImgroupInfoListReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            var groupVersionListElementIndex:Int = 0
            for oneElementGroupVersionList in groupVersionList {
                output += "\(indent) groupVersionList[\(groupVersionListElementIndex)] {\n"
                output += try oneElementGroupVersionList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                groupVersionListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                for oneElementGroupVersionList in groupVersionList {
                    hashCode = (hashCode &* 31) &+ oneElementGroupVersionList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Group.ImgroupInfoListReq"
        }
        override public func className() -> String {
            return "Im.Group.ImgroupInfoListReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Group.ImgroupInfoListReq = Im.Group.ImgroupInfoListReq()
            public func getMessage() -> Im.Group.ImgroupInfoListReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x0403
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Group.ImgroupInfoListReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Group.ImgroupInfoListReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var groupVersionList:Array<Im.BaseDefine.GroupVersionInfo> {
                get {
                    return builderResult.groupVersionList
                }
                set (value) {
                    builderResult.groupVersionList = value
                }
            }
            @discardableResult
            public func setGroupVersionList(_ value:Array<Im.BaseDefine.GroupVersionInfo>) -> Im.Group.ImgroupInfoListReq.Builder {
                self.groupVersionList = value
                return self
            }
            @discardableResult
            public func clearGroupVersionList() -> Im.Group.ImgroupInfoListReq.Builder {
                builderResult.groupVersionList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Group.ImgroupInfoListReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Group.ImgroupInfoListReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Group.ImgroupInfoListReq.Builder {
                builderResult = Im.Group.ImgroupInfoListReq()
                return self
            }
            override public func clone() throws -> Im.Group.ImgroupInfoListReq.Builder {
                return try Im.Group.ImgroupInfoListReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Group.ImgroupInfoListReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Group.ImgroupInfoListReq {
                let returnMe:Im.Group.ImgroupInfoListReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Group.ImgroupInfoListReq) throws -> Im.Group.ImgroupInfoListReq.Builder {
                if other == Im.Group.ImgroupInfoListReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if !other.groupVersionList.isEmpty  {
                     builderResult.groupVersionList += other.groupVersionList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupInfoListReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupInfoListReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 18:
                        let subBuilder = Im.BaseDefine.GroupVersionInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        groupVersionList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupInfoListReq.Builder {
                let resultDecodedBuilder = Im.Group.ImgroupInfoListReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueGroupVersionList = jsonMap["groupVersionList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayGroupVersionList:Array<Im.BaseDefine.GroupVersionInfo> = []
                    for oneValueGroupVersionList in jsonValueGroupVersionList {
                        let messageFromStringGroupVersionList = try Im.BaseDefine.GroupVersionInfo.Builder.decodeToBuilder(jsonMap:oneValueGroupVersionList).build()

                        jsonArrayGroupVersionList.append(messageFromStringGroupVersionList)
                    }
                    resultDecodedBuilder.groupVersionList = jsonArrayGroupVersionList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Group.ImgroupInfoListReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Group.ImgroupInfoListReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgroupInfoListRsp : GeneratedMessage {
        public typealias BuilderType = Im.Group.ImgroupInfoListRsp.Builder

        public static func == (lhs: Im.Group.ImgroupInfoListRsp, rhs: Im.Group.ImgroupInfoListRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.groupInfoList == rhs.groupInfoList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x0404
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var groupInfoList:Array<Im.BaseDefine.GroupInfo>  = Array<Im.BaseDefine.GroupInfo>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            var isInitGroupInfoList:Bool = true
            for oneElementGroupInfoList in groupInfoList {
                if !oneElementGroupInfoList.isInitialized() {
                    isInitGroupInfoList = false
                    break 
                }
            }
            if !isInitGroupInfoList {
                return isInitGroupInfoList
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            for oneElementGroupInfoList in groupInfoList {
                  try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementGroupInfoList)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            for oneElementGroupInfoList in groupInfoList {
                serialize_size += oneElementGroupInfoList.computeMessageSize(fieldNumber: 2)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Group.ImgroupInfoListRsp.Builder {
            return Im.Group.ImgroupInfoListRsp.classBuilder() as! Im.Group.ImgroupInfoListRsp.Builder
        }
        public func getBuilder() -> Im.Group.ImgroupInfoListRsp.Builder {
            return classBuilder() as! Im.Group.ImgroupInfoListRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupInfoListRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupInfoListRsp.Builder()
        }
        public func toBuilder() throws -> Im.Group.ImgroupInfoListRsp.Builder {
            return try Im.Group.ImgroupInfoListRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Group.ImgroupInfoListRsp) throws -> Im.Group.ImgroupInfoListRsp.Builder {
            return try Im.Group.ImgroupInfoListRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if !groupInfoList.isEmpty {
                var jsonArrayGroupInfoList:Array<Dictionary<String,Any>> = []
                for oneValueGroupInfoList in groupInfoList {
                    let ecodedMessageGroupInfoList = try oneValueGroupInfoList.encode()
                    jsonArrayGroupInfoList.append(ecodedMessageGroupInfoList)
                }
                jsonMap["groupInfoList"] = jsonArrayGroupInfoList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupInfoListRsp {
            return try Im.Group.ImgroupInfoListRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Group.ImgroupInfoListRsp {
            return try Im.Group.ImgroupInfoListRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            var groupInfoListElementIndex:Int = 0
            for oneElementGroupInfoList in groupInfoList {
                output += "\(indent) groupInfoList[\(groupInfoListElementIndex)] {\n"
                output += try oneElementGroupInfoList.getDescription(indent: "\(indent)  ")
                output += "\(indent)}\n"
                groupInfoListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                for oneElementGroupInfoList in groupInfoList {
                    hashCode = (hashCode &* 31) &+ oneElementGroupInfoList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Group.ImgroupInfoListRsp"
        }
        override public func className() -> String {
            return "Im.Group.ImgroupInfoListRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Group.ImgroupInfoListRsp = Im.Group.ImgroupInfoListRsp()
            public func getMessage() -> Im.Group.ImgroupInfoListRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x0404
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Group.ImgroupInfoListRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Group.ImgroupInfoListRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var groupInfoList:Array<Im.BaseDefine.GroupInfo> {
                get {
                    return builderResult.groupInfoList
                }
                set (value) {
                    builderResult.groupInfoList = value
                }
            }
            @discardableResult
            public func setGroupInfoList(_ value:Array<Im.BaseDefine.GroupInfo>) -> Im.Group.ImgroupInfoListRsp.Builder {
                self.groupInfoList = value
                return self
            }
            @discardableResult
            public func clearGroupInfoList() -> Im.Group.ImgroupInfoListRsp.Builder {
                builderResult.groupInfoList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Group.ImgroupInfoListRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Group.ImgroupInfoListRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Group.ImgroupInfoListRsp.Builder {
                builderResult = Im.Group.ImgroupInfoListRsp()
                return self
            }
            override public func clone() throws -> Im.Group.ImgroupInfoListRsp.Builder {
                return try Im.Group.ImgroupInfoListRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Group.ImgroupInfoListRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Group.ImgroupInfoListRsp {
                let returnMe:Im.Group.ImgroupInfoListRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Group.ImgroupInfoListRsp) throws -> Im.Group.ImgroupInfoListRsp.Builder {
                if other == Im.Group.ImgroupInfoListRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if !other.groupInfoList.isEmpty  {
                     builderResult.groupInfoList += other.groupInfoList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupInfoListRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupInfoListRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 18:
                        let subBuilder = Im.BaseDefine.GroupInfo.Builder()
                        try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                        groupInfoList.append(subBuilder.buildPartial())

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupInfoListRsp.Builder {
                let resultDecodedBuilder = Im.Group.ImgroupInfoListRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueGroupInfoList = jsonMap["groupInfoList"] as? Array<Dictionary<String,Any>> {
                    var jsonArrayGroupInfoList:Array<Im.BaseDefine.GroupInfo> = []
                    for oneValueGroupInfoList in jsonValueGroupInfoList {
                        let messageFromStringGroupInfoList = try Im.BaseDefine.GroupInfo.Builder.decodeToBuilder(jsonMap:oneValueGroupInfoList).build()

                        jsonArrayGroupInfoList.append(messageFromStringGroupInfoList)
                    }
                    resultDecodedBuilder.groupInfoList = jsonArrayGroupInfoList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Group.ImgroupInfoListRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Group.ImgroupInfoListRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgroupCreateReq : GeneratedMessage {
        public typealias BuilderType = Im.Group.ImgroupCreateReq.Builder

        public static func == (lhs: Im.Group.ImgroupCreateReq, rhs: Im.Group.ImgroupCreateReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasGroupType == rhs.hasGroupType) && (!lhs.hasGroupType || lhs.groupType == rhs.groupType)
            fieldCheck = fieldCheck && (lhs.hasGroupName == rhs.hasGroupName) && (!lhs.hasGroupName || lhs.groupName == rhs.groupName)
            fieldCheck = fieldCheck && (lhs.hasGroupAvatar == rhs.hasGroupAvatar) && (!lhs.hasGroupAvatar || lhs.groupAvatar == rhs.groupAvatar)
            fieldCheck = fieldCheck && (lhs.memberIdList == rhs.memberIdList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x0405
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var groupType:Im.BaseDefine.GroupType = Im.BaseDefine.GroupType.groupTypeTmp
        public fileprivate(set) var hasGroupType:Bool = false
        public fileprivate(set) var groupName:String! = nil
        public fileprivate(set) var hasGroupName:Bool = false

        public fileprivate(set) var groupAvatar:String! = nil
        public fileprivate(set) var hasGroupAvatar:Bool = false

        public fileprivate(set) var memberIdList:Array<UInt32> = Array<UInt32>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasGroupType {
                return false
            }
            if !hasGroupName {
                return false
            }
            if !hasGroupAvatar {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasGroupType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:groupType.rawValue)
            }
            if hasGroupName {
                try codedOutputStream.writeString(fieldNumber: 3, value:groupName)
            }
            if hasGroupAvatar {
                try codedOutputStream.writeString(fieldNumber: 4, value:groupAvatar)
            }
            if !memberIdList.isEmpty {
                for oneValuememberIdList in memberIdList {
                    try codedOutputStream.writeUInt32(fieldNumber: 5, value:oneValuememberIdList)
                }
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasGroupType) {
                serialize_size += groupType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasGroupName {
                serialize_size += groupName.computeStringSize(fieldNumber: 3)
            }
            if hasGroupAvatar {
                serialize_size += groupAvatar.computeStringSize(fieldNumber: 4)
            }
            var dataSizeMemberIdList:Int32 = 0
            for oneValuememberIdList in memberIdList {
                dataSizeMemberIdList += oneValuememberIdList.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeMemberIdList
            serialize_size += 1 * Int32(memberIdList.count)
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Group.ImgroupCreateReq.Builder {
            return Im.Group.ImgroupCreateReq.classBuilder() as! Im.Group.ImgroupCreateReq.Builder
        }
        public func getBuilder() -> Im.Group.ImgroupCreateReq.Builder {
            return classBuilder() as! Im.Group.ImgroupCreateReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupCreateReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupCreateReq.Builder()
        }
        public func toBuilder() throws -> Im.Group.ImgroupCreateReq.Builder {
            return try Im.Group.ImgroupCreateReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Group.ImgroupCreateReq) throws -> Im.Group.ImgroupCreateReq.Builder {
            return try Im.Group.ImgroupCreateReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasGroupType {
                jsonMap["groupType"] = groupType.toString()
            }
            if hasGroupName {
                jsonMap["groupName"] = groupName
            }
            if hasGroupAvatar {
                jsonMap["groupAvatar"] = groupAvatar
            }
            if !memberIdList.isEmpty {
                var jsonArrayMemberIdList:Array<UInt> = []
                for oneValueMemberIdList in memberIdList {
                    jsonArrayMemberIdList.append(UInt(oneValueMemberIdList))
                }
                jsonMap["memberIdList"] = jsonArrayMemberIdList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupCreateReq {
            return try Im.Group.ImgroupCreateReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Group.ImgroupCreateReq {
            return try Im.Group.ImgroupCreateReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasGroupType) {
                output += "\(indent) groupType: \(groupType.description)\n"
            }
            if hasGroupName {
                output += "\(indent) groupName: \(groupName) \n"
            }
            if hasGroupAvatar {
                output += "\(indent) groupAvatar: \(groupAvatar) \n"
            }
            var memberIdListElementIndex:Int = 0
            for oneValueMemberIdList in memberIdList  {
                output += "\(indent) memberIdList[\(memberIdListElementIndex)]: \(oneValueMemberIdList)\n"
                memberIdListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasGroupType {
                     hashCode = (hashCode &* 31) &+ groupType.hashValue
                }
                if hasGroupName {
                    hashCode = (hashCode &* 31) &+ groupName.hashValue
                }
                if hasGroupAvatar {
                    hashCode = (hashCode &* 31) &+ groupAvatar.hashValue
                }
                for oneValueMemberIdList in memberIdList {
                    hashCode = (hashCode &* 31) &+ oneValueMemberIdList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Group.ImgroupCreateReq"
        }
        override public func className() -> String {
            return "Im.Group.ImgroupCreateReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Group.ImgroupCreateReq = Im.Group.ImgroupCreateReq()
            public func getMessage() -> Im.Group.ImgroupCreateReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x0405
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Group.ImgroupCreateReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Group.ImgroupCreateReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            ///默认是创建临时群，且客户端只能创建临时群
                public var groupType:Im.BaseDefine.GroupType {
                    get {
                        return builderResult.groupType
                    }
                    set (value) {
                        builderResult.hasGroupType = true
                        builderResult.groupType = value
                    }
                }
                public var hasGroupType:Bool{
                    get {
                        return builderResult.hasGroupType
                    }
                }
            @discardableResult
                public func setGroupType(_ value:Im.BaseDefine.GroupType) -> Im.Group.ImgroupCreateReq.Builder {
                  self.groupType = value
                  return self
                }
            @discardableResult
                public func clearGroupType() -> Im.Group.ImgroupCreateReq.Builder {
                   builderResult.hasGroupType = false
                   builderResult.groupType = .groupTypeTmp
                   return self
                }
            public var groupName:String {
                get {
                    return builderResult.groupName
                }
                set (value) {
                    builderResult.hasGroupName = true
                    builderResult.groupName = value
                }
            }
            public var hasGroupName:Bool {
                get {
                    return builderResult.hasGroupName
                }
            }
            @discardableResult
            public func setGroupName(_ value:String) -> Im.Group.ImgroupCreateReq.Builder {
                self.groupName = value
                return self
            }
            @discardableResult
            public func clearGroupName() -> Im.Group.ImgroupCreateReq.Builder{
                builderResult.hasGroupName = false
                builderResult.groupName = nil
                return self
            }
            public var groupAvatar:String {
                get {
                    return builderResult.groupAvatar
                }
                set (value) {
                    builderResult.hasGroupAvatar = true
                    builderResult.groupAvatar = value
                }
            }
            public var hasGroupAvatar:Bool {
                get {
                    return builderResult.hasGroupAvatar
                }
            }
            @discardableResult
            public func setGroupAvatar(_ value:String) -> Im.Group.ImgroupCreateReq.Builder {
                self.groupAvatar = value
                return self
            }
            @discardableResult
            public func clearGroupAvatar() -> Im.Group.ImgroupCreateReq.Builder{
                builderResult.hasGroupAvatar = false
                builderResult.groupAvatar = nil
                return self
            }
            public var memberIdList:Array<UInt32> {
                get {
                    return builderResult.memberIdList
                }
                set (array) {
                    builderResult.memberIdList = array
                }
            }
            @discardableResult
            public func setMemberIdList(_ value:Array<UInt32>) -> Im.Group.ImgroupCreateReq.Builder {
                self.memberIdList = value
                return self
            }
            @discardableResult
            public func clearMemberIdList() -> Im.Group.ImgroupCreateReq.Builder {
                builderResult.memberIdList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Group.ImgroupCreateReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Group.ImgroupCreateReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Group.ImgroupCreateReq.Builder {
                builderResult = Im.Group.ImgroupCreateReq()
                return self
            }
            override public func clone() throws -> Im.Group.ImgroupCreateReq.Builder {
                return try Im.Group.ImgroupCreateReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Group.ImgroupCreateReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Group.ImgroupCreateReq {
                let returnMe:Im.Group.ImgroupCreateReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Group.ImgroupCreateReq) throws -> Im.Group.ImgroupCreateReq.Builder {
                if other == Im.Group.ImgroupCreateReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasGroupType {
                    groupType = other.groupType
                }
                if other.hasGroupName {
                    groupName = other.groupName
                }
                if other.hasGroupAvatar {
                    groupAvatar = other.groupAvatar
                }
                if !other.memberIdList.isEmpty {
                    builderResult.memberIdList += other.memberIdList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupCreateReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupCreateReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntgroupType = try codedInputStream.readEnum()
                        if let enumsgroupType = Im.BaseDefine.GroupType(rawValue:valueIntgroupType){
                            groupType = enumsgroupType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntgroupType))
                        }

                    case 26:
                        groupName = try codedInputStream.readString()

                    case 34:
                        groupAvatar = try codedInputStream.readString()

                    case 40:
                        memberIdList += [try codedInputStream.readUInt32()]

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupCreateReq.Builder {
                let resultDecodedBuilder = Im.Group.ImgroupCreateReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueGroupType = jsonMap["groupType"] as? String {
                    resultDecodedBuilder.groupType = try Im.BaseDefine.GroupType.fromString(jsonValueGroupType)
                }
                if let jsonValueGroupName = jsonMap["groupName"] as? String {
                    resultDecodedBuilder.groupName = jsonValueGroupName
                }
                if let jsonValueGroupAvatar = jsonMap["groupAvatar"] as? String {
                    resultDecodedBuilder.groupAvatar = jsonValueGroupAvatar
                }
                if let jsonValueMemberIdList = jsonMap["memberIdList"] as? Array<UInt> {
                    var jsonArrayMemberIdList:Array<UInt32> = []
                    for oneValueMemberIdList in jsonValueMemberIdList {
                        jsonArrayMemberIdList.append(UInt32(oneValueMemberIdList))
                    }
                    resultDecodedBuilder.memberIdList = jsonArrayMemberIdList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Group.ImgroupCreateReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Group.ImgroupCreateReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgroupCreateRsp : GeneratedMessage {
        public typealias BuilderType = Im.Group.ImgroupCreateRsp.Builder

        public static func == (lhs: Im.Group.ImgroupCreateRsp, rhs: Im.Group.ImgroupCreateRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasGroupName == rhs.hasGroupName) && (!lhs.hasGroupName || lhs.groupName == rhs.groupName)
            fieldCheck = fieldCheck && (lhs.userIdList == rhs.userIdList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x0406
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        public fileprivate(set) var groupId:UInt32! = nil
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var groupName:String! = nil
        public fileprivate(set) var hasGroupName:Bool = false

        public fileprivate(set) var userIdList:Array<UInt32> = Array<UInt32>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasResultCode {
                return false
            }
            if !hasGroupName {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:resultCode)
            }
            if hasGroupId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:groupId)
            }
            if hasGroupName {
                try codedOutputStream.writeString(fieldNumber: 4, value:groupName)
            }
            if !userIdList.isEmpty {
                for oneValueuserIdList in userIdList {
                    try codedOutputStream.writeUInt32(fieldNumber: 5, value:oneValueuserIdList)
                }
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 2)
            }
            if hasGroupId {
                serialize_size += groupId.computeUInt32Size(fieldNumber: 3)
            }
            if hasGroupName {
                serialize_size += groupName.computeStringSize(fieldNumber: 4)
            }
            var dataSizeUserIdList:Int32 = 0
            for oneValueuserIdList in userIdList {
                dataSizeUserIdList += oneValueuserIdList.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeUserIdList
            serialize_size += 1 * Int32(userIdList.count)
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Group.ImgroupCreateRsp.Builder {
            return Im.Group.ImgroupCreateRsp.classBuilder() as! Im.Group.ImgroupCreateRsp.Builder
        }
        public func getBuilder() -> Im.Group.ImgroupCreateRsp.Builder {
            return classBuilder() as! Im.Group.ImgroupCreateRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupCreateRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupCreateRsp.Builder()
        }
        public func toBuilder() throws -> Im.Group.ImgroupCreateRsp.Builder {
            return try Im.Group.ImgroupCreateRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Group.ImgroupCreateRsp) throws -> Im.Group.ImgroupCreateRsp.Builder {
            return try Im.Group.ImgroupCreateRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            if hasGroupId {
                jsonMap["groupId"] = UInt(groupId)
            }
            if hasGroupName {
                jsonMap["groupName"] = groupName
            }
            if !userIdList.isEmpty {
                var jsonArrayUserIdList:Array<UInt> = []
                for oneValueUserIdList in userIdList {
                    jsonArrayUserIdList.append(UInt(oneValueUserIdList))
                }
                jsonMap["userIdList"] = jsonArrayUserIdList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupCreateRsp {
            return try Im.Group.ImgroupCreateRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Group.ImgroupCreateRsp {
            return try Im.Group.ImgroupCreateRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if hasGroupName {
                output += "\(indent) groupName: \(groupName) \n"
            }
            var userIdListElementIndex:Int = 0
            for oneValueUserIdList in userIdList  {
                output += "\(indent) userIdList[\(userIdListElementIndex)]: \(oneValueUserIdList)\n"
                userIdListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasGroupName {
                    hashCode = (hashCode &* 31) &+ groupName.hashValue
                }
                for oneValueUserIdList in userIdList {
                    hashCode = (hashCode &* 31) &+ oneValueUserIdList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Group.ImgroupCreateRsp"
        }
        override public func className() -> String {
            return "Im.Group.ImgroupCreateRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Group.ImgroupCreateRsp = Im.Group.ImgroupCreateRsp()
            public func getMessage() -> Im.Group.ImgroupCreateRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x0406
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Group.ImgroupCreateRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Group.ImgroupCreateRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.Group.ImgroupCreateRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.Group.ImgroupCreateRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            public var groupId:UInt32 {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:UInt32) -> Im.Group.ImgroupCreateRsp.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Im.Group.ImgroupCreateRsp.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = nil
                return self
            }
            public var groupName:String {
                get {
                    return builderResult.groupName
                }
                set (value) {
                    builderResult.hasGroupName = true
                    builderResult.groupName = value
                }
            }
            public var hasGroupName:Bool {
                get {
                    return builderResult.hasGroupName
                }
            }
            @discardableResult
            public func setGroupName(_ value:String) -> Im.Group.ImgroupCreateRsp.Builder {
                self.groupName = value
                return self
            }
            @discardableResult
            public func clearGroupName() -> Im.Group.ImgroupCreateRsp.Builder{
                builderResult.hasGroupName = false
                builderResult.groupName = nil
                return self
            }
            public var userIdList:Array<UInt32> {
                get {
                    return builderResult.userIdList
                }
                set (array) {
                    builderResult.userIdList = array
                }
            }
            @discardableResult
            public func setUserIdList(_ value:Array<UInt32>) -> Im.Group.ImgroupCreateRsp.Builder {
                self.userIdList = value
                return self
            }
            @discardableResult
            public func clearUserIdList() -> Im.Group.ImgroupCreateRsp.Builder {
                builderResult.userIdList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Group.ImgroupCreateRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Group.ImgroupCreateRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Group.ImgroupCreateRsp.Builder {
                builderResult = Im.Group.ImgroupCreateRsp()
                return self
            }
            override public func clone() throws -> Im.Group.ImgroupCreateRsp.Builder {
                return try Im.Group.ImgroupCreateRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Group.ImgroupCreateRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Group.ImgroupCreateRsp {
                let returnMe:Im.Group.ImgroupCreateRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Group.ImgroupCreateRsp) throws -> Im.Group.ImgroupCreateRsp.Builder {
                if other == Im.Group.ImgroupCreateRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if other.hasGroupName {
                    groupName = other.groupName
                }
                if !other.userIdList.isEmpty {
                    builderResult.userIdList += other.userIdList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupCreateRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupCreateRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        resultCode = try codedInputStream.readUInt32()

                    case 24:
                        groupId = try codedInputStream.readUInt32()

                    case 34:
                        groupName = try codedInputStream.readString()

                    case 40:
                        userIdList += [try codedInputStream.readUInt32()]

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupCreateRsp.Builder {
                let resultDecodedBuilder = Im.Group.ImgroupCreateRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                if let jsonValueGroupId = jsonMap["groupId"] as? UInt {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)
                } else if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)!
                }
                if let jsonValueGroupName = jsonMap["groupName"] as? String {
                    resultDecodedBuilder.groupName = jsonValueGroupName
                }
                if let jsonValueUserIdList = jsonMap["userIdList"] as? Array<UInt> {
                    var jsonArrayUserIdList:Array<UInt32> = []
                    for oneValueUserIdList in jsonValueUserIdList {
                        jsonArrayUserIdList.append(UInt32(oneValueUserIdList))
                    }
                    resultDecodedBuilder.userIdList = jsonArrayUserIdList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Group.ImgroupCreateRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Group.ImgroupCreateRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgroupChangeMemberReq : GeneratedMessage {
        public typealias BuilderType = Im.Group.ImgroupChangeMemberReq.Builder

        public static func == (lhs: Im.Group.ImgroupChangeMemberReq, rhs: Im.Group.ImgroupChangeMemberReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasChangeType == rhs.hasChangeType) && (!lhs.hasChangeType || lhs.changeType == rhs.changeType)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.memberIdList == rhs.memberIdList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x0407
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var changeType:Im.BaseDefine.GroupModifyType = Im.BaseDefine.GroupModifyType.groupModifyTypeAdd
        public fileprivate(set) var hasChangeType:Bool = false
        public fileprivate(set) var groupId:UInt32! = nil
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var memberIdList:Array<UInt32> = Array<UInt32>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasChangeType {
                return false
            }
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasChangeType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:changeType.rawValue)
            }
            if hasGroupId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:groupId)
            }
            if !memberIdList.isEmpty {
                for oneValuememberIdList in memberIdList {
                    try codedOutputStream.writeUInt32(fieldNumber: 4, value:oneValuememberIdList)
                }
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasChangeType) {
                serialize_size += changeType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasGroupId {
                serialize_size += groupId.computeUInt32Size(fieldNumber: 3)
            }
            var dataSizeMemberIdList:Int32 = 0
            for oneValuememberIdList in memberIdList {
                dataSizeMemberIdList += oneValuememberIdList.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeMemberIdList
            serialize_size += 1 * Int32(memberIdList.count)
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Group.ImgroupChangeMemberReq.Builder {
            return Im.Group.ImgroupChangeMemberReq.classBuilder() as! Im.Group.ImgroupChangeMemberReq.Builder
        }
        public func getBuilder() -> Im.Group.ImgroupChangeMemberReq.Builder {
            return classBuilder() as! Im.Group.ImgroupChangeMemberReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupChangeMemberReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupChangeMemberReq.Builder()
        }
        public func toBuilder() throws -> Im.Group.ImgroupChangeMemberReq.Builder {
            return try Im.Group.ImgroupChangeMemberReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Group.ImgroupChangeMemberReq) throws -> Im.Group.ImgroupChangeMemberReq.Builder {
            return try Im.Group.ImgroupChangeMemberReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasChangeType {
                jsonMap["changeType"] = changeType.toString()
            }
            if hasGroupId {
                jsonMap["groupId"] = UInt(groupId)
            }
            if !memberIdList.isEmpty {
                var jsonArrayMemberIdList:Array<UInt> = []
                for oneValueMemberIdList in memberIdList {
                    jsonArrayMemberIdList.append(UInt(oneValueMemberIdList))
                }
                jsonMap["memberIdList"] = jsonArrayMemberIdList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupChangeMemberReq {
            return try Im.Group.ImgroupChangeMemberReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Group.ImgroupChangeMemberReq {
            return try Im.Group.ImgroupChangeMemberReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasChangeType) {
                output += "\(indent) changeType: \(changeType.description)\n"
            }
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            var memberIdListElementIndex:Int = 0
            for oneValueMemberIdList in memberIdList  {
                output += "\(indent) memberIdList[\(memberIdListElementIndex)]: \(oneValueMemberIdList)\n"
                memberIdListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasChangeType {
                     hashCode = (hashCode &* 31) &+ changeType.hashValue
                }
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                for oneValueMemberIdList in memberIdList {
                    hashCode = (hashCode &* 31) &+ oneValueMemberIdList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Group.ImgroupChangeMemberReq"
        }
        override public func className() -> String {
            return "Im.Group.ImgroupChangeMemberReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Group.ImgroupChangeMemberReq = Im.Group.ImgroupChangeMemberReq()
            public func getMessage() -> Im.Group.ImgroupChangeMemberReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x0407
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Group.ImgroupChangeMemberReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Group.ImgroupChangeMemberReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var changeType:Im.BaseDefine.GroupModifyType {
                    get {
                        return builderResult.changeType
                    }
                    set (value) {
                        builderResult.hasChangeType = true
                        builderResult.changeType = value
                    }
                }
                public var hasChangeType:Bool{
                    get {
                        return builderResult.hasChangeType
                    }
                }
            @discardableResult
                public func setChangeType(_ value:Im.BaseDefine.GroupModifyType) -> Im.Group.ImgroupChangeMemberReq.Builder {
                  self.changeType = value
                  return self
                }
            @discardableResult
                public func clearChangeType() -> Im.Group.ImgroupChangeMemberReq.Builder {
                   builderResult.hasChangeType = false
                   builderResult.changeType = .groupModifyTypeAdd
                   return self
                }
            public var groupId:UInt32 {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:UInt32) -> Im.Group.ImgroupChangeMemberReq.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Im.Group.ImgroupChangeMemberReq.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = nil
                return self
            }
            public var memberIdList:Array<UInt32> {
                get {
                    return builderResult.memberIdList
                }
                set (array) {
                    builderResult.memberIdList = array
                }
            }
            @discardableResult
            public func setMemberIdList(_ value:Array<UInt32>) -> Im.Group.ImgroupChangeMemberReq.Builder {
                self.memberIdList = value
                return self
            }
            @discardableResult
            public func clearMemberIdList() -> Im.Group.ImgroupChangeMemberReq.Builder {
                builderResult.memberIdList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Group.ImgroupChangeMemberReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Group.ImgroupChangeMemberReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Group.ImgroupChangeMemberReq.Builder {
                builderResult = Im.Group.ImgroupChangeMemberReq()
                return self
            }
            override public func clone() throws -> Im.Group.ImgroupChangeMemberReq.Builder {
                return try Im.Group.ImgroupChangeMemberReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Group.ImgroupChangeMemberReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Group.ImgroupChangeMemberReq {
                let returnMe:Im.Group.ImgroupChangeMemberReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Group.ImgroupChangeMemberReq) throws -> Im.Group.ImgroupChangeMemberReq.Builder {
                if other == Im.Group.ImgroupChangeMemberReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasChangeType {
                    changeType = other.changeType
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if !other.memberIdList.isEmpty {
                    builderResult.memberIdList += other.memberIdList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupChangeMemberReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupChangeMemberReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntchangeType = try codedInputStream.readEnum()
                        if let enumschangeType = Im.BaseDefine.GroupModifyType(rawValue:valueIntchangeType){
                            changeType = enumschangeType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntchangeType))
                        }

                    case 24:
                        groupId = try codedInputStream.readUInt32()

                    case 32:
                        memberIdList += [try codedInputStream.readUInt32()]

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupChangeMemberReq.Builder {
                let resultDecodedBuilder = Im.Group.ImgroupChangeMemberReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueChangeType = jsonMap["changeType"] as? String {
                    resultDecodedBuilder.changeType = try Im.BaseDefine.GroupModifyType.fromString(jsonValueChangeType)
                }
                if let jsonValueGroupId = jsonMap["groupId"] as? UInt {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)
                } else if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)!
                }
                if let jsonValueMemberIdList = jsonMap["memberIdList"] as? Array<UInt> {
                    var jsonArrayMemberIdList:Array<UInt32> = []
                    for oneValueMemberIdList in jsonValueMemberIdList {
                        jsonArrayMemberIdList.append(UInt32(oneValueMemberIdList))
                    }
                    resultDecodedBuilder.memberIdList = jsonArrayMemberIdList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Group.ImgroupChangeMemberReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Group.ImgroupChangeMemberReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgroupChangeMemberRsp : GeneratedMessage {
        public typealias BuilderType = Im.Group.ImgroupChangeMemberRsp.Builder

        public static func == (lhs: Im.Group.ImgroupChangeMemberRsp, rhs: Im.Group.ImgroupChangeMemberRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasChangeType == rhs.hasChangeType) && (!lhs.hasChangeType || lhs.changeType == rhs.changeType)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.curUserIdList == rhs.curUserIdList)
            fieldCheck = fieldCheck && (lhs.chgUserIdList == rhs.chgUserIdList)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x0408
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var changeType:Im.BaseDefine.GroupModifyType = Im.BaseDefine.GroupModifyType.groupModifyTypeAdd
        public fileprivate(set) var hasChangeType:Bool = false
        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        public fileprivate(set) var groupId:UInt32! = nil
        public fileprivate(set) var hasGroupId:Bool = false

        ///现有的成员id		
        public fileprivate(set) var curUserIdList:Array<UInt32> = Array<UInt32>()
        ///变动的成员id,add: 表示添加成功的id,   del: 表示删除的id
        public fileprivate(set) var chgUserIdList:Array<UInt32> = Array<UInt32>()
        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasChangeType {
                return false
            }
            if !hasResultCode {
                return false
            }
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasChangeType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:changeType.rawValue)
            }
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:resultCode)
            }
            if hasGroupId {
                try codedOutputStream.writeUInt32(fieldNumber: 4, value:groupId)
            }
            if !curUserIdList.isEmpty {
                for oneValuecurUserIdList in curUserIdList {
                    try codedOutputStream.writeUInt32(fieldNumber: 5, value:oneValuecurUserIdList)
                }
            }
            if !chgUserIdList.isEmpty {
                for oneValuechgUserIdList in chgUserIdList {
                    try codedOutputStream.writeUInt32(fieldNumber: 6, value:oneValuechgUserIdList)
                }
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasChangeType) {
                serialize_size += changeType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 3)
            }
            if hasGroupId {
                serialize_size += groupId.computeUInt32Size(fieldNumber: 4)
            }
            var dataSizeCurUserIdList:Int32 = 0
            for oneValuecurUserIdList in curUserIdList {
                dataSizeCurUserIdList += oneValuecurUserIdList.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeCurUserIdList
            serialize_size += 1 * Int32(curUserIdList.count)
            var dataSizeChgUserIdList:Int32 = 0
            for oneValuechgUserIdList in chgUserIdList {
                dataSizeChgUserIdList += oneValuechgUserIdList.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeChgUserIdList
            serialize_size += 1 * Int32(chgUserIdList.count)
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Group.ImgroupChangeMemberRsp.Builder {
            return Im.Group.ImgroupChangeMemberRsp.classBuilder() as! Im.Group.ImgroupChangeMemberRsp.Builder
        }
        public func getBuilder() -> Im.Group.ImgroupChangeMemberRsp.Builder {
            return classBuilder() as! Im.Group.ImgroupChangeMemberRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupChangeMemberRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupChangeMemberRsp.Builder()
        }
        public func toBuilder() throws -> Im.Group.ImgroupChangeMemberRsp.Builder {
            return try Im.Group.ImgroupChangeMemberRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Group.ImgroupChangeMemberRsp) throws -> Im.Group.ImgroupChangeMemberRsp.Builder {
            return try Im.Group.ImgroupChangeMemberRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasChangeType {
                jsonMap["changeType"] = changeType.toString()
            }
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            if hasGroupId {
                jsonMap["groupId"] = UInt(groupId)
            }
            if !curUserIdList.isEmpty {
                var jsonArrayCurUserIdList:Array<UInt> = []
                for oneValueCurUserIdList in curUserIdList {
                    jsonArrayCurUserIdList.append(UInt(oneValueCurUserIdList))
                }
                jsonMap["curUserIdList"] = jsonArrayCurUserIdList
            }
            if !chgUserIdList.isEmpty {
                var jsonArrayChgUserIdList:Array<UInt> = []
                for oneValueChgUserIdList in chgUserIdList {
                    jsonArrayChgUserIdList.append(UInt(oneValueChgUserIdList))
                }
                jsonMap["chgUserIdList"] = jsonArrayChgUserIdList
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupChangeMemberRsp {
            return try Im.Group.ImgroupChangeMemberRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Group.ImgroupChangeMemberRsp {
            return try Im.Group.ImgroupChangeMemberRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasChangeType) {
                output += "\(indent) changeType: \(changeType.description)\n"
            }
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            var curUserIdListElementIndex:Int = 0
            for oneValueCurUserIdList in curUserIdList  {
                output += "\(indent) curUserIdList[\(curUserIdListElementIndex)]: \(oneValueCurUserIdList)\n"
                curUserIdListElementIndex += 1
            }
            var chgUserIdListElementIndex:Int = 0
            for oneValueChgUserIdList in chgUserIdList  {
                output += "\(indent) chgUserIdList[\(chgUserIdListElementIndex)]: \(oneValueChgUserIdList)\n"
                chgUserIdListElementIndex += 1
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasChangeType {
                     hashCode = (hashCode &* 31) &+ changeType.hashValue
                }
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                for oneValueCurUserIdList in curUserIdList {
                    hashCode = (hashCode &* 31) &+ oneValueCurUserIdList.hashValue
                }
                for oneValueChgUserIdList in chgUserIdList {
                    hashCode = (hashCode &* 31) &+ oneValueChgUserIdList.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Group.ImgroupChangeMemberRsp"
        }
        override public func className() -> String {
            return "Im.Group.ImgroupChangeMemberRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Group.ImgroupChangeMemberRsp = Im.Group.ImgroupChangeMemberRsp()
            public func getMessage() -> Im.Group.ImgroupChangeMemberRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x0408
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Group.ImgroupChangeMemberRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Group.ImgroupChangeMemberRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var changeType:Im.BaseDefine.GroupModifyType {
                    get {
                        return builderResult.changeType
                    }
                    set (value) {
                        builderResult.hasChangeType = true
                        builderResult.changeType = value
                    }
                }
                public var hasChangeType:Bool{
                    get {
                        return builderResult.hasChangeType
                    }
                }
            @discardableResult
                public func setChangeType(_ value:Im.BaseDefine.GroupModifyType) -> Im.Group.ImgroupChangeMemberRsp.Builder {
                  self.changeType = value
                  return self
                }
            @discardableResult
                public func clearChangeType() -> Im.Group.ImgroupChangeMemberRsp.Builder {
                   builderResult.hasChangeType = false
                   builderResult.changeType = .groupModifyTypeAdd
                   return self
                }
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.Group.ImgroupChangeMemberRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.Group.ImgroupChangeMemberRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            public var groupId:UInt32 {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:UInt32) -> Im.Group.ImgroupChangeMemberRsp.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Im.Group.ImgroupChangeMemberRsp.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = nil
                return self
            }
            ///现有的成员id		
            public var curUserIdList:Array<UInt32> {
                get {
                    return builderResult.curUserIdList
                }
                set (array) {
                    builderResult.curUserIdList = array
                }
            }
            @discardableResult
            public func setCurUserIdList(_ value:Array<UInt32>) -> Im.Group.ImgroupChangeMemberRsp.Builder {
                self.curUserIdList = value
                return self
            }
            @discardableResult
            public func clearCurUserIdList() -> Im.Group.ImgroupChangeMemberRsp.Builder {
                builderResult.curUserIdList.removeAll(keepingCapacity: false)
                return self
            }
            ///变动的成员id,add: 表示添加成功的id,   del: 表示删除的id
            public var chgUserIdList:Array<UInt32> {
                get {
                    return builderResult.chgUserIdList
                }
                set (array) {
                    builderResult.chgUserIdList = array
                }
            }
            @discardableResult
            public func setChgUserIdList(_ value:Array<UInt32>) -> Im.Group.ImgroupChangeMemberRsp.Builder {
                self.chgUserIdList = value
                return self
            }
            @discardableResult
            public func clearChgUserIdList() -> Im.Group.ImgroupChangeMemberRsp.Builder {
                builderResult.chgUserIdList.removeAll(keepingCapacity: false)
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Group.ImgroupChangeMemberRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Group.ImgroupChangeMemberRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Group.ImgroupChangeMemberRsp.Builder {
                builderResult = Im.Group.ImgroupChangeMemberRsp()
                return self
            }
            override public func clone() throws -> Im.Group.ImgroupChangeMemberRsp.Builder {
                return try Im.Group.ImgroupChangeMemberRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Group.ImgroupChangeMemberRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Group.ImgroupChangeMemberRsp {
                let returnMe:Im.Group.ImgroupChangeMemberRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Group.ImgroupChangeMemberRsp) throws -> Im.Group.ImgroupChangeMemberRsp.Builder {
                if other == Im.Group.ImgroupChangeMemberRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasChangeType {
                    changeType = other.changeType
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if !other.curUserIdList.isEmpty {
                    builderResult.curUserIdList += other.curUserIdList
                }
                if !other.chgUserIdList.isEmpty {
                    builderResult.chgUserIdList += other.chgUserIdList
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupChangeMemberRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupChangeMemberRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntchangeType = try codedInputStream.readEnum()
                        if let enumschangeType = Im.BaseDefine.GroupModifyType(rawValue:valueIntchangeType){
                            changeType = enumschangeType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntchangeType))
                        }

                    case 24:
                        resultCode = try codedInputStream.readUInt32()

                    case 32:
                        groupId = try codedInputStream.readUInt32()

                    case 40:
                        curUserIdList += [try codedInputStream.readUInt32()]

                    case 48:
                        chgUserIdList += [try codedInputStream.readUInt32()]

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupChangeMemberRsp.Builder {
                let resultDecodedBuilder = Im.Group.ImgroupChangeMemberRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueChangeType = jsonMap["changeType"] as? String {
                    resultDecodedBuilder.changeType = try Im.BaseDefine.GroupModifyType.fromString(jsonValueChangeType)
                }
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                if let jsonValueGroupId = jsonMap["groupId"] as? UInt {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)
                } else if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)!
                }
                if let jsonValueCurUserIdList = jsonMap["curUserIdList"] as? Array<UInt> {
                    var jsonArrayCurUserIdList:Array<UInt32> = []
                    for oneValueCurUserIdList in jsonValueCurUserIdList {
                        jsonArrayCurUserIdList.append(UInt32(oneValueCurUserIdList))
                    }
                    resultDecodedBuilder.curUserIdList = jsonArrayCurUserIdList
                }
                if let jsonValueChgUserIdList = jsonMap["chgUserIdList"] as? Array<UInt> {
                    var jsonArrayChgUserIdList:Array<UInt32> = []
                    for oneValueChgUserIdList in jsonValueChgUserIdList {
                        jsonArrayChgUserIdList.append(UInt32(oneValueChgUserIdList))
                    }
                    resultDecodedBuilder.chgUserIdList = jsonArrayChgUserIdList
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Group.ImgroupChangeMemberRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Group.ImgroupChangeMemberRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgroupShieldReq : GeneratedMessage {
        public typealias BuilderType = Im.Group.ImgroupShieldReq.Builder

        public static func == (lhs: Im.Group.ImgroupShieldReq, rhs: Im.Group.ImgroupShieldReq) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasShieldStatus == rhs.hasShieldStatus) && (!lhs.hasShieldStatus || lhs.shieldStatus == rhs.shieldStatus)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x0409
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var groupId:UInt32! = nil
        public fileprivate(set) var hasGroupId:Bool = false

        public fileprivate(set) var shieldStatus:UInt32! = nil
        public fileprivate(set) var hasShieldStatus:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasGroupId {
                return false
            }
            if !hasShieldStatus {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasGroupId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:groupId)
            }
            if hasShieldStatus {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:shieldStatus)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasGroupId {
                serialize_size += groupId.computeUInt32Size(fieldNumber: 2)
            }
            if hasShieldStatus {
                serialize_size += shieldStatus.computeUInt32Size(fieldNumber: 3)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Group.ImgroupShieldReq.Builder {
            return Im.Group.ImgroupShieldReq.classBuilder() as! Im.Group.ImgroupShieldReq.Builder
        }
        public func getBuilder() -> Im.Group.ImgroupShieldReq.Builder {
            return classBuilder() as! Im.Group.ImgroupShieldReq.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupShieldReq.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupShieldReq.Builder()
        }
        public func toBuilder() throws -> Im.Group.ImgroupShieldReq.Builder {
            return try Im.Group.ImgroupShieldReq.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Group.ImgroupShieldReq) throws -> Im.Group.ImgroupShieldReq.Builder {
            return try Im.Group.ImgroupShieldReq.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasGroupId {
                jsonMap["groupId"] = UInt(groupId)
            }
            if hasShieldStatus {
                jsonMap["shieldStatus"] = UInt(shieldStatus)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupShieldReq {
            return try Im.Group.ImgroupShieldReq.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Group.ImgroupShieldReq {
            return try Im.Group.ImgroupShieldReq.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if hasShieldStatus {
                output += "\(indent) shieldStatus: \(shieldStatus) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasShieldStatus {
                    hashCode = (hashCode &* 31) &+ shieldStatus.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Group.ImgroupShieldReq"
        }
        override public func className() -> String {
            return "Im.Group.ImgroupShieldReq"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Group.ImgroupShieldReq = Im.Group.ImgroupShieldReq()
            public func getMessage() -> Im.Group.ImgroupShieldReq {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x0409
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Group.ImgroupShieldReq.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Group.ImgroupShieldReq.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var groupId:UInt32 {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:UInt32) -> Im.Group.ImgroupShieldReq.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Im.Group.ImgroupShieldReq.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = nil
                return self
            }
            public var shieldStatus:UInt32 {
                get {
                    return builderResult.shieldStatus
                }
                set (value) {
                    builderResult.hasShieldStatus = true
                    builderResult.shieldStatus = value
                }
            }
            public var hasShieldStatus:Bool {
                get {
                    return builderResult.hasShieldStatus
                }
            }
            @discardableResult
            public func setShieldStatus(_ value:UInt32) -> Im.Group.ImgroupShieldReq.Builder {
                self.shieldStatus = value
                return self
            }
            @discardableResult
            public func clearShieldStatus() -> Im.Group.ImgroupShieldReq.Builder{
                builderResult.hasShieldStatus = false
                builderResult.shieldStatus = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Group.ImgroupShieldReq.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Group.ImgroupShieldReq.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Group.ImgroupShieldReq.Builder {
                builderResult = Im.Group.ImgroupShieldReq()
                return self
            }
            override public func clone() throws -> Im.Group.ImgroupShieldReq.Builder {
                return try Im.Group.ImgroupShieldReq.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Group.ImgroupShieldReq {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Group.ImgroupShieldReq {
                let returnMe:Im.Group.ImgroupShieldReq = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Group.ImgroupShieldReq) throws -> Im.Group.ImgroupShieldReq.Builder {
                if other == Im.Group.ImgroupShieldReq() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if other.hasShieldStatus {
                    shieldStatus = other.shieldStatus
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupShieldReq.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupShieldReq.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        groupId = try codedInputStream.readUInt32()

                    case 24:
                        shieldStatus = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupShieldReq.Builder {
                let resultDecodedBuilder = Im.Group.ImgroupShieldReq.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueGroupId = jsonMap["groupId"] as? UInt {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)
                } else if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)!
                }
                if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? UInt {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)
                } else if let jsonValueShieldStatus = jsonMap["shieldStatus"] as? String {
                    resultDecodedBuilder.shieldStatus = UInt32(jsonValueShieldStatus)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Group.ImgroupShieldReq.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Group.ImgroupShieldReq.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgroupShieldRsp : GeneratedMessage {
        public typealias BuilderType = Im.Group.ImgroupShieldRsp.Builder

        public static func == (lhs: Im.Group.ImgroupShieldRsp, rhs: Im.Group.ImgroupShieldRsp) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.hasResultCode == rhs.hasResultCode) && (!lhs.hasResultCode || lhs.resultCode == rhs.resultCode)
            fieldCheck = fieldCheck && (lhs.hasAttachData == rhs.hasAttachData) && (!lhs.hasAttachData || lhs.attachData == rhs.attachData)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id:			0x040a
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var groupId:UInt32! = nil
        public fileprivate(set) var hasGroupId:Bool = false

        ///0:successed 1:failed
        public fileprivate(set) var resultCode:UInt32! = nil
        public fileprivate(set) var hasResultCode:Bool = false

        public fileprivate(set) var attachData:Data! = nil
        public fileprivate(set) var hasAttachData:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasGroupId {
                return false
            }
            if !hasResultCode {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasGroupId {
                try codedOutputStream.writeUInt32(fieldNumber: 2, value:groupId)
            }
            if hasResultCode {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:resultCode)
            }
            if hasAttachData {
                try codedOutputStream.writeData(fieldNumber: 20, value:attachData)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if hasGroupId {
                serialize_size += groupId.computeUInt32Size(fieldNumber: 2)
            }
            if hasResultCode {
                serialize_size += resultCode.computeUInt32Size(fieldNumber: 3)
            }
            if hasAttachData {
                serialize_size += attachData.computeDataSize(fieldNumber: 20)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Group.ImgroupShieldRsp.Builder {
            return Im.Group.ImgroupShieldRsp.classBuilder() as! Im.Group.ImgroupShieldRsp.Builder
        }
        public func getBuilder() -> Im.Group.ImgroupShieldRsp.Builder {
            return classBuilder() as! Im.Group.ImgroupShieldRsp.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupShieldRsp.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupShieldRsp.Builder()
        }
        public func toBuilder() throws -> Im.Group.ImgroupShieldRsp.Builder {
            return try Im.Group.ImgroupShieldRsp.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Group.ImgroupShieldRsp) throws -> Im.Group.ImgroupShieldRsp.Builder {
            return try Im.Group.ImgroupShieldRsp.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasGroupId {
                jsonMap["groupId"] = UInt(groupId)
            }
            if hasResultCode {
                jsonMap["resultCode"] = UInt(resultCode)
            }
            if hasAttachData {
                jsonMap["attachData"] = attachData.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupShieldRsp {
            return try Im.Group.ImgroupShieldRsp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Group.ImgroupShieldRsp {
            return try Im.Group.ImgroupShieldRsp.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            if hasResultCode {
                output += "\(indent) resultCode: \(resultCode) \n"
            }
            if hasAttachData {
                output += "\(indent) attachData: \(attachData) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                if hasResultCode {
                    hashCode = (hashCode &* 31) &+ resultCode.hashValue
                }
                if hasAttachData {
                    hashCode = (hashCode &* 31) &+ attachData.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Group.ImgroupShieldRsp"
        }
        override public func className() -> String {
            return "Im.Group.ImgroupShieldRsp"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Group.ImgroupShieldRsp = Im.Group.ImgroupShieldRsp()
            public func getMessage() -> Im.Group.ImgroupShieldRsp {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id:			0x040a
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Group.ImgroupShieldRsp.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Group.ImgroupShieldRsp.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
            public var groupId:UInt32 {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:UInt32) -> Im.Group.ImgroupShieldRsp.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Im.Group.ImgroupShieldRsp.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = nil
                return self
            }
            ///0:successed 1:failed
            public var resultCode:UInt32 {
                get {
                    return builderResult.resultCode
                }
                set (value) {
                    builderResult.hasResultCode = true
                    builderResult.resultCode = value
                }
            }
            public var hasResultCode:Bool {
                get {
                    return builderResult.hasResultCode
                }
            }
            @discardableResult
            public func setResultCode(_ value:UInt32) -> Im.Group.ImgroupShieldRsp.Builder {
                self.resultCode = value
                return self
            }
            @discardableResult
            public func clearResultCode() -> Im.Group.ImgroupShieldRsp.Builder{
                builderResult.hasResultCode = false
                builderResult.resultCode = nil
                return self
            }
            public var attachData:Data {
                get {
                    return builderResult.attachData
                }
                set (value) {
                    builderResult.hasAttachData = true
                    builderResult.attachData = value
                }
            }
            public var hasAttachData:Bool {
                get {
                    return builderResult.hasAttachData
                }
            }
            @discardableResult
            public func setAttachData(_ value:Data) -> Im.Group.ImgroupShieldRsp.Builder {
                self.attachData = value
                return self
            }
            @discardableResult
            public func clearAttachData() -> Im.Group.ImgroupShieldRsp.Builder{
                builderResult.hasAttachData = false
                builderResult.attachData = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Group.ImgroupShieldRsp.Builder {
                builderResult = Im.Group.ImgroupShieldRsp()
                return self
            }
            override public func clone() throws -> Im.Group.ImgroupShieldRsp.Builder {
                return try Im.Group.ImgroupShieldRsp.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Group.ImgroupShieldRsp {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Group.ImgroupShieldRsp {
                let returnMe:Im.Group.ImgroupShieldRsp = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Group.ImgroupShieldRsp) throws -> Im.Group.ImgroupShieldRsp.Builder {
                if other == Im.Group.ImgroupShieldRsp() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if other.hasResultCode {
                    resultCode = other.resultCode
                }
                if other.hasAttachData {
                    attachData = other.attachData
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupShieldRsp.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupShieldRsp.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        groupId = try codedInputStream.readUInt32()

                    case 24:
                        resultCode = try codedInputStream.readUInt32()

                    case 162:
                        attachData = try codedInputStream.readData()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupShieldRsp.Builder {
                let resultDecodedBuilder = Im.Group.ImgroupShieldRsp.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueGroupId = jsonMap["groupId"] as? UInt {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)
                } else if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)!
                }
                if let jsonValueResultCode = jsonMap["resultCode"] as? UInt {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)
                } else if let jsonValueResultCode = jsonMap["resultCode"] as? String {
                    resultDecodedBuilder.resultCode = UInt32(jsonValueResultCode)!
                }
                if let jsonValueAttachData = jsonMap["attachData"] as? String {
                    resultDecodedBuilder.attachData = Data(base64Encoded:jsonValueAttachData, options: Data.Base64DecodingOptions(rawValue:0))!
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Group.ImgroupShieldRsp.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Group.ImgroupShieldRsp.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    final public class ImgroupChangeMemberNotify : GeneratedMessage {
        public typealias BuilderType = Im.Group.ImgroupChangeMemberNotify.Builder

        public static func == (lhs: Im.Group.ImgroupChangeMemberNotify, rhs: Im.Group.ImgroupChangeMemberNotify) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
            fieldCheck = fieldCheck && (lhs.hasChangeType == rhs.hasChangeType) && (!lhs.hasChangeType || lhs.changeType == rhs.changeType)
            fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
            fieldCheck = fieldCheck && (lhs.curUserIdList == rhs.curUserIdList)
            fieldCheck = fieldCheck && (lhs.chgUserIdList == rhs.chgUserIdList)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        ///cmd id: 			0x040b
        public fileprivate(set) var userId:UInt32! = nil
        public fileprivate(set) var hasUserId:Bool = false

        public fileprivate(set) var changeType:Im.BaseDefine.GroupModifyType = Im.BaseDefine.GroupModifyType.groupModifyTypeAdd
        public fileprivate(set) var hasChangeType:Bool = false
        public fileprivate(set) var groupId:UInt32! = nil
        public fileprivate(set) var hasGroupId:Bool = false

        ///现有的成员id
        public fileprivate(set) var curUserIdList:Array<UInt32> = Array<UInt32>()
        ///add: 表示添加成功的id,   del: 表示删除的id
        public fileprivate(set) var chgUserIdList:Array<UInt32> = Array<UInt32>()
        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            if !hasUserId {
                return false
            }
            if !hasChangeType {
                return false
            }
            if !hasGroupId {
                return false
            }
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasUserId {
                try codedOutputStream.writeUInt32(fieldNumber: 1, value:userId)
            }
            if hasChangeType {
                try codedOutputStream.writeEnum(fieldNumber: 2, value:changeType.rawValue)
            }
            if hasGroupId {
                try codedOutputStream.writeUInt32(fieldNumber: 3, value:groupId)
            }
            if !curUserIdList.isEmpty {
                for oneValuecurUserIdList in curUserIdList {
                    try codedOutputStream.writeUInt32(fieldNumber: 4, value:oneValuecurUserIdList)
                }
            }
            if !chgUserIdList.isEmpty {
                for oneValuechgUserIdList in chgUserIdList {
                    try codedOutputStream.writeUInt32(fieldNumber: 5, value:oneValuechgUserIdList)
                }
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasUserId {
                serialize_size += userId.computeUInt32Size(fieldNumber: 1)
            }
            if (hasChangeType) {
                serialize_size += changeType.rawValue.computeEnumSize(fieldNumber: 2)
            }
            if hasGroupId {
                serialize_size += groupId.computeUInt32Size(fieldNumber: 3)
            }
            var dataSizeCurUserIdList:Int32 = 0
            for oneValuecurUserIdList in curUserIdList {
                dataSizeCurUserIdList += oneValuecurUserIdList.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeCurUserIdList
            serialize_size += 1 * Int32(curUserIdList.count)
            var dataSizeChgUserIdList:Int32 = 0
            for oneValuechgUserIdList in chgUserIdList {
                dataSizeChgUserIdList += oneValuechgUserIdList.computeUInt32SizeNoTag()
            }
            serialize_size += dataSizeChgUserIdList
            serialize_size += 1 * Int32(chgUserIdList.count)
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Im.Group.ImgroupChangeMemberNotify.Builder {
            return Im.Group.ImgroupChangeMemberNotify.classBuilder() as! Im.Group.ImgroupChangeMemberNotify.Builder
        }
        public func getBuilder() -> Im.Group.ImgroupChangeMemberNotify.Builder {
            return classBuilder() as! Im.Group.ImgroupChangeMemberNotify.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupChangeMemberNotify.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Im.Group.ImgroupChangeMemberNotify.Builder()
        }
        public func toBuilder() throws -> Im.Group.ImgroupChangeMemberNotify.Builder {
            return try Im.Group.ImgroupChangeMemberNotify.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Im.Group.ImgroupChangeMemberNotify) throws -> Im.Group.ImgroupChangeMemberNotify.Builder {
            return try Im.Group.ImgroupChangeMemberNotify.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasUserId {
                jsonMap["userId"] = UInt(userId)
            }
            if hasChangeType {
                jsonMap["changeType"] = changeType.toString()
            }
            if hasGroupId {
                jsonMap["groupId"] = UInt(groupId)
            }
            if !curUserIdList.isEmpty {
                var jsonArrayCurUserIdList:Array<UInt> = []
                for oneValueCurUserIdList in curUserIdList {
                    jsonArrayCurUserIdList.append(UInt(oneValueCurUserIdList))
                }
                jsonMap["curUserIdList"] = jsonArrayCurUserIdList
            }
            if !chgUserIdList.isEmpty {
                var jsonArrayChgUserIdList:Array<UInt> = []
                for oneValueChgUserIdList in chgUserIdList {
                    jsonArrayChgUserIdList.append(UInt(oneValueChgUserIdList))
                }
                jsonMap["chgUserIdList"] = jsonArrayChgUserIdList
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupChangeMemberNotify {
            return try Im.Group.ImgroupChangeMemberNotify.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Im.Group.ImgroupChangeMemberNotify {
            return try Im.Group.ImgroupChangeMemberNotify.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasUserId {
                output += "\(indent) userId: \(userId) \n"
            }
            if (hasChangeType) {
                output += "\(indent) changeType: \(changeType.description)\n"
            }
            if hasGroupId {
                output += "\(indent) groupId: \(groupId) \n"
            }
            var curUserIdListElementIndex:Int = 0
            for oneValueCurUserIdList in curUserIdList  {
                output += "\(indent) curUserIdList[\(curUserIdListElementIndex)]: \(oneValueCurUserIdList)\n"
                curUserIdListElementIndex += 1
            }
            var chgUserIdListElementIndex:Int = 0
            for oneValueChgUserIdList in chgUserIdList  {
                output += "\(indent) chgUserIdList[\(chgUserIdListElementIndex)]: \(oneValueChgUserIdList)\n"
                chgUserIdListElementIndex += 1
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasUserId {
                    hashCode = (hashCode &* 31) &+ userId.hashValue
                }
                if hasChangeType {
                     hashCode = (hashCode &* 31) &+ changeType.hashValue
                }
                if hasGroupId {
                    hashCode = (hashCode &* 31) &+ groupId.hashValue
                }
                for oneValueCurUserIdList in curUserIdList {
                    hashCode = (hashCode &* 31) &+ oneValueCurUserIdList.hashValue
                }
                for oneValueChgUserIdList in chgUserIdList {
                    hashCode = (hashCode &* 31) &+ oneValueChgUserIdList.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Im.Group.ImgroupChangeMemberNotify"
        }
        override public func className() -> String {
            return "Im.Group.ImgroupChangeMemberNotify"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Im.Group.ImgroupChangeMemberNotify = Im.Group.ImgroupChangeMemberNotify()
            public func getMessage() -> Im.Group.ImgroupChangeMemberNotify {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            ///cmd id: 			0x040b
            public var userId:UInt32 {
                get {
                    return builderResult.userId
                }
                set (value) {
                    builderResult.hasUserId = true
                    builderResult.userId = value
                }
            }
            public var hasUserId:Bool {
                get {
                    return builderResult.hasUserId
                }
            }
            @discardableResult
            public func setUserId(_ value:UInt32) -> Im.Group.ImgroupChangeMemberNotify.Builder {
                self.userId = value
                return self
            }
            @discardableResult
            public func clearUserId() -> Im.Group.ImgroupChangeMemberNotify.Builder{
                builderResult.hasUserId = false
                builderResult.userId = nil
                return self
            }
                public var changeType:Im.BaseDefine.GroupModifyType {
                    get {
                        return builderResult.changeType
                    }
                    set (value) {
                        builderResult.hasChangeType = true
                        builderResult.changeType = value
                    }
                }
                public var hasChangeType:Bool{
                    get {
                        return builderResult.hasChangeType
                    }
                }
            @discardableResult
                public func setChangeType(_ value:Im.BaseDefine.GroupModifyType) -> Im.Group.ImgroupChangeMemberNotify.Builder {
                  self.changeType = value
                  return self
                }
            @discardableResult
                public func clearChangeType() -> Im.Group.ImgroupChangeMemberNotify.Builder {
                   builderResult.hasChangeType = false
                   builderResult.changeType = .groupModifyTypeAdd
                   return self
                }
            public var groupId:UInt32 {
                get {
                    return builderResult.groupId
                }
                set (value) {
                    builderResult.hasGroupId = true
                    builderResult.groupId = value
                }
            }
            public var hasGroupId:Bool {
                get {
                    return builderResult.hasGroupId
                }
            }
            @discardableResult
            public func setGroupId(_ value:UInt32) -> Im.Group.ImgroupChangeMemberNotify.Builder {
                self.groupId = value
                return self
            }
            @discardableResult
            public func clearGroupId() -> Im.Group.ImgroupChangeMemberNotify.Builder{
                builderResult.hasGroupId = false
                builderResult.groupId = nil
                return self
            }
            ///现有的成员id
            public var curUserIdList:Array<UInt32> {
                get {
                    return builderResult.curUserIdList
                }
                set (array) {
                    builderResult.curUserIdList = array
                }
            }
            @discardableResult
            public func setCurUserIdList(_ value:Array<UInt32>) -> Im.Group.ImgroupChangeMemberNotify.Builder {
                self.curUserIdList = value
                return self
            }
            @discardableResult
            public func clearCurUserIdList() -> Im.Group.ImgroupChangeMemberNotify.Builder {
                builderResult.curUserIdList.removeAll(keepingCapacity: false)
                return self
            }
            ///add: 表示添加成功的id,   del: 表示删除的id
            public var chgUserIdList:Array<UInt32> {
                get {
                    return builderResult.chgUserIdList
                }
                set (array) {
                    builderResult.chgUserIdList = array
                }
            }
            @discardableResult
            public func setChgUserIdList(_ value:Array<UInt32>) -> Im.Group.ImgroupChangeMemberNotify.Builder {
                self.chgUserIdList = value
                return self
            }
            @discardableResult
            public func clearChgUserIdList() -> Im.Group.ImgroupChangeMemberNotify.Builder {
                builderResult.chgUserIdList.removeAll(keepingCapacity: false)
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Im.Group.ImgroupChangeMemberNotify.Builder {
                builderResult = Im.Group.ImgroupChangeMemberNotify()
                return self
            }
            override public func clone() throws -> Im.Group.ImgroupChangeMemberNotify.Builder {
                return try Im.Group.ImgroupChangeMemberNotify.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Im.Group.ImgroupChangeMemberNotify {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Im.Group.ImgroupChangeMemberNotify {
                let returnMe:Im.Group.ImgroupChangeMemberNotify = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Im.Group.ImgroupChangeMemberNotify) throws -> Im.Group.ImgroupChangeMemberNotify.Builder {
                if other == Im.Group.ImgroupChangeMemberNotify() {
                    return self
                }
                if other.hasUserId {
                    userId = other.userId
                }
                if other.hasChangeType {
                    changeType = other.changeType
                }
                if other.hasGroupId {
                    groupId = other.groupId
                }
                if !other.curUserIdList.isEmpty {
                    builderResult.curUserIdList += other.curUserIdList
                }
                if !other.chgUserIdList.isEmpty {
                    builderResult.chgUserIdList += other.chgUserIdList
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupChangeMemberNotify.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupChangeMemberNotify.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 8:
                        userId = try codedInputStream.readUInt32()

                    case 16:
                        let valueIntchangeType = try codedInputStream.readEnum()
                        if let enumschangeType = Im.BaseDefine.GroupModifyType(rawValue:valueIntchangeType){
                            changeType = enumschangeType
                        } else {
                            try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntchangeType))
                        }

                    case 24:
                        groupId = try codedInputStream.readUInt32()

                    case 32:
                        curUserIdList += [try codedInputStream.readUInt32()]

                    case 40:
                        chgUserIdList += [try codedInputStream.readUInt32()]

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Im.Group.ImgroupChangeMemberNotify.Builder {
                let resultDecodedBuilder = Im.Group.ImgroupChangeMemberNotify.Builder()
                if let jsonValueUserId = jsonMap["userId"] as? UInt {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)
                } else if let jsonValueUserId = jsonMap["userId"] as? String {
                    resultDecodedBuilder.userId = UInt32(jsonValueUserId)!
                }
                if let jsonValueChangeType = jsonMap["changeType"] as? String {
                    resultDecodedBuilder.changeType = try Im.BaseDefine.GroupModifyType.fromString(jsonValueChangeType)
                }
                if let jsonValueGroupId = jsonMap["groupId"] as? UInt {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)
                } else if let jsonValueGroupId = jsonMap["groupId"] as? String {
                    resultDecodedBuilder.groupId = UInt32(jsonValueGroupId)!
                }
                if let jsonValueCurUserIdList = jsonMap["curUserIdList"] as? Array<UInt> {
                    var jsonArrayCurUserIdList:Array<UInt32> = []
                    for oneValueCurUserIdList in jsonValueCurUserIdList {
                        jsonArrayCurUserIdList.append(UInt32(oneValueCurUserIdList))
                    }
                    resultDecodedBuilder.curUserIdList = jsonArrayCurUserIdList
                }
                if let jsonValueChgUserIdList = jsonMap["chgUserIdList"] as? Array<UInt> {
                    var jsonArrayChgUserIdList:Array<UInt32> = []
                    for oneValueChgUserIdList in jsonValueChgUserIdList {
                        jsonArrayChgUserIdList.append(UInt32(oneValueChgUserIdList))
                    }
                    resultDecodedBuilder.chgUserIdList = jsonArrayChgUserIdList
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Im.Group.ImgroupChangeMemberNotify.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Im.Group.ImgroupChangeMemberNotify.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

}
extension Im.Group.ImnormalGroupListReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Group.ImnormalGroupListReq> {
        var mergedArray = Array<Im.Group.ImnormalGroupListReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Group.ImnormalGroupListReq? {
        return try Im.Group.ImnormalGroupListReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Group.ImnormalGroupListReq {
        return try Im.Group.ImnormalGroupListReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Group.ImgroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImnormalGroupListReq {
        return try Im.Group.ImnormalGroupListReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Group.ImnormalGroupListReq {
        return try Im.Group.ImnormalGroupListReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImnormalGroupListReq {
        return try Im.Group.ImnormalGroupListReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImnormalGroupListReq {
        return try Im.Group.ImnormalGroupListReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImnormalGroupListReq {
        return try Im.Group.ImnormalGroupListReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Group.ImnormalGroupListReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Group.ImnormalGroupListReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Group.ImnormalGroupListRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Group.ImnormalGroupListRsp> {
        var mergedArray = Array<Im.Group.ImnormalGroupListRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Group.ImnormalGroupListRsp? {
        return try Im.Group.ImnormalGroupListRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Group.ImnormalGroupListRsp {
        return try Im.Group.ImnormalGroupListRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Group.ImgroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImnormalGroupListRsp {
        return try Im.Group.ImnormalGroupListRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Group.ImnormalGroupListRsp {
        return try Im.Group.ImnormalGroupListRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImnormalGroupListRsp {
        return try Im.Group.ImnormalGroupListRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImnormalGroupListRsp {
        return try Im.Group.ImnormalGroupListRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImnormalGroupListRsp {
        return try Im.Group.ImnormalGroupListRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "groupVersionList": return self.groupVersionList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Group.ImnormalGroupListRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Group.ImnormalGroupListRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "groupVersionList": return self.groupVersionList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "groupVersionList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.GroupVersionInfo> else {
                    return
                }
                self.groupVersionList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Group.ImgroupInfoListReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Group.ImgroupInfoListReq> {
        var mergedArray = Array<Im.Group.ImgroupInfoListReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Group.ImgroupInfoListReq? {
        return try Im.Group.ImgroupInfoListReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Group.ImgroupInfoListReq {
        return try Im.Group.ImgroupInfoListReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Group.ImgroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupInfoListReq {
        return try Im.Group.ImgroupInfoListReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Group.ImgroupInfoListReq {
        return try Im.Group.ImgroupInfoListReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupInfoListReq {
        return try Im.Group.ImgroupInfoListReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupInfoListReq {
        return try Im.Group.ImgroupInfoListReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupInfoListReq {
        return try Im.Group.ImgroupInfoListReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "groupVersionList": return self.groupVersionList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Group.ImgroupInfoListReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Group.ImgroupInfoListReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "groupVersionList": return self.groupVersionList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "groupVersionList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.GroupVersionInfo> else {
                    return
                }
                self.groupVersionList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Group.ImgroupInfoListRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Group.ImgroupInfoListRsp> {
        var mergedArray = Array<Im.Group.ImgroupInfoListRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Group.ImgroupInfoListRsp? {
        return try Im.Group.ImgroupInfoListRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Group.ImgroupInfoListRsp {
        return try Im.Group.ImgroupInfoListRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Group.ImgroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupInfoListRsp {
        return try Im.Group.ImgroupInfoListRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Group.ImgroupInfoListRsp {
        return try Im.Group.ImgroupInfoListRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupInfoListRsp {
        return try Im.Group.ImgroupInfoListRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupInfoListRsp {
        return try Im.Group.ImgroupInfoListRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupInfoListRsp {
        return try Im.Group.ImgroupInfoListRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "groupInfoList": return self.groupInfoList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Group.ImgroupInfoListRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Group.ImgroupInfoListRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "groupInfoList": return self.groupInfoList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "groupInfoList":
                guard let newSubscriptValue = newSubscriptValue as? Array<Im.BaseDefine.GroupInfo> else {
                    return
                }
                self.groupInfoList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Group.ImgroupCreateReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Group.ImgroupCreateReq> {
        var mergedArray = Array<Im.Group.ImgroupCreateReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Group.ImgroupCreateReq? {
        return try Im.Group.ImgroupCreateReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Group.ImgroupCreateReq {
        return try Im.Group.ImgroupCreateReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Group.ImgroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupCreateReq {
        return try Im.Group.ImgroupCreateReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Group.ImgroupCreateReq {
        return try Im.Group.ImgroupCreateReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupCreateReq {
        return try Im.Group.ImgroupCreateReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupCreateReq {
        return try Im.Group.ImgroupCreateReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupCreateReq {
        return try Im.Group.ImgroupCreateReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "groupType": return self.groupType
        case "groupName": return self.groupName
        case "groupAvatar": return self.groupAvatar
        case "memberIdList": return self.memberIdList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Group.ImgroupCreateReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Group.ImgroupCreateReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "groupType": return self.groupType
            case "groupName": return self.groupName
            case "groupAvatar": return self.groupAvatar
            case "memberIdList": return self.memberIdList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "groupType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.GroupType else {
                    return
                }
                self.groupType = newSubscriptValue
            case "groupName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupName = newSubscriptValue
            case "groupAvatar":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupAvatar = newSubscriptValue
            case "memberIdList":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.memberIdList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Group.ImgroupCreateRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Group.ImgroupCreateRsp> {
        var mergedArray = Array<Im.Group.ImgroupCreateRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Group.ImgroupCreateRsp? {
        return try Im.Group.ImgroupCreateRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Group.ImgroupCreateRsp {
        return try Im.Group.ImgroupCreateRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Group.ImgroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupCreateRsp {
        return try Im.Group.ImgroupCreateRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Group.ImgroupCreateRsp {
        return try Im.Group.ImgroupCreateRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupCreateRsp {
        return try Im.Group.ImgroupCreateRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupCreateRsp {
        return try Im.Group.ImgroupCreateRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupCreateRsp {
        return try Im.Group.ImgroupCreateRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "resultCode": return self.resultCode
        case "groupId": return self.groupId
        case "groupName": return self.groupName
        case "userIdList": return self.userIdList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Group.ImgroupCreateRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Group.ImgroupCreateRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "resultCode": return self.resultCode
            case "groupId": return self.groupId
            case "groupName": return self.groupName
            case "userIdList": return self.userIdList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.groupId = newSubscriptValue
            case "groupName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.groupName = newSubscriptValue
            case "userIdList":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.userIdList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Group.ImgroupChangeMemberReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Group.ImgroupChangeMemberReq> {
        var mergedArray = Array<Im.Group.ImgroupChangeMemberReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Group.ImgroupChangeMemberReq? {
        return try Im.Group.ImgroupChangeMemberReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Group.ImgroupChangeMemberReq {
        return try Im.Group.ImgroupChangeMemberReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Group.ImgroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupChangeMemberReq {
        return try Im.Group.ImgroupChangeMemberReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Group.ImgroupChangeMemberReq {
        return try Im.Group.ImgroupChangeMemberReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupChangeMemberReq {
        return try Im.Group.ImgroupChangeMemberReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupChangeMemberReq {
        return try Im.Group.ImgroupChangeMemberReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupChangeMemberReq {
        return try Im.Group.ImgroupChangeMemberReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "changeType": return self.changeType
        case "groupId": return self.groupId
        case "memberIdList": return self.memberIdList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Group.ImgroupChangeMemberReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Group.ImgroupChangeMemberReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "changeType": return self.changeType
            case "groupId": return self.groupId
            case "memberIdList": return self.memberIdList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "changeType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.GroupModifyType else {
                    return
                }
                self.changeType = newSubscriptValue
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.groupId = newSubscriptValue
            case "memberIdList":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.memberIdList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Group.ImgroupChangeMemberRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Group.ImgroupChangeMemberRsp> {
        var mergedArray = Array<Im.Group.ImgroupChangeMemberRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Group.ImgroupChangeMemberRsp? {
        return try Im.Group.ImgroupChangeMemberRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Group.ImgroupChangeMemberRsp {
        return try Im.Group.ImgroupChangeMemberRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Group.ImgroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupChangeMemberRsp {
        return try Im.Group.ImgroupChangeMemberRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Group.ImgroupChangeMemberRsp {
        return try Im.Group.ImgroupChangeMemberRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupChangeMemberRsp {
        return try Im.Group.ImgroupChangeMemberRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupChangeMemberRsp {
        return try Im.Group.ImgroupChangeMemberRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupChangeMemberRsp {
        return try Im.Group.ImgroupChangeMemberRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "changeType": return self.changeType
        case "resultCode": return self.resultCode
        case "groupId": return self.groupId
        case "curUserIdList": return self.curUserIdList
        case "chgUserIdList": return self.chgUserIdList
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Group.ImgroupChangeMemberRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Group.ImgroupChangeMemberRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "changeType": return self.changeType
            case "resultCode": return self.resultCode
            case "groupId": return self.groupId
            case "curUserIdList": return self.curUserIdList
            case "chgUserIdList": return self.chgUserIdList
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "changeType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.GroupModifyType else {
                    return
                }
                self.changeType = newSubscriptValue
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.groupId = newSubscriptValue
            case "curUserIdList":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.curUserIdList = newSubscriptValue
            case "chgUserIdList":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.chgUserIdList = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Group.ImgroupShieldReq: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Group.ImgroupShieldReq> {
        var mergedArray = Array<Im.Group.ImgroupShieldReq>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Group.ImgroupShieldReq? {
        return try Im.Group.ImgroupShieldReq.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Group.ImgroupShieldReq {
        return try Im.Group.ImgroupShieldReq.Builder().mergeFrom(data: data, extensionRegistry:Im.Group.ImgroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupShieldReq {
        return try Im.Group.ImgroupShieldReq.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Group.ImgroupShieldReq {
        return try Im.Group.ImgroupShieldReq.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupShieldReq {
        return try Im.Group.ImgroupShieldReq.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupShieldReq {
        return try Im.Group.ImgroupShieldReq.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupShieldReq {
        return try Im.Group.ImgroupShieldReq.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "groupId": return self.groupId
        case "shieldStatus": return self.shieldStatus
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Group.ImgroupShieldReq.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Group.ImgroupShieldReq
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "groupId": return self.groupId
            case "shieldStatus": return self.shieldStatus
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.groupId = newSubscriptValue
            case "shieldStatus":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.shieldStatus = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Group.ImgroupShieldRsp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Group.ImgroupShieldRsp> {
        var mergedArray = Array<Im.Group.ImgroupShieldRsp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Group.ImgroupShieldRsp? {
        return try Im.Group.ImgroupShieldRsp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Group.ImgroupShieldRsp {
        return try Im.Group.ImgroupShieldRsp.Builder().mergeFrom(data: data, extensionRegistry:Im.Group.ImgroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupShieldRsp {
        return try Im.Group.ImgroupShieldRsp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Group.ImgroupShieldRsp {
        return try Im.Group.ImgroupShieldRsp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupShieldRsp {
        return try Im.Group.ImgroupShieldRsp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupShieldRsp {
        return try Im.Group.ImgroupShieldRsp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupShieldRsp {
        return try Im.Group.ImgroupShieldRsp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "groupId": return self.groupId
        case "resultCode": return self.resultCode
        case "attachData": return self.attachData
        default: return nil
        }
    }
}
extension Im.Group.ImgroupShieldRsp.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Group.ImgroupShieldRsp
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "groupId": return self.groupId
            case "resultCode": return self.resultCode
            case "attachData": return self.attachData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.groupId = newSubscriptValue
            case "resultCode":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.resultCode = newSubscriptValue
            case "attachData":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.attachData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Im.Group.ImgroupChangeMemberNotify: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Im.Group.ImgroupChangeMemberNotify> {
        var mergedArray = Array<Im.Group.ImgroupChangeMemberNotify>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Im.Group.ImgroupChangeMemberNotify? {
        return try Im.Group.ImgroupChangeMemberNotify.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Im.Group.ImgroupChangeMemberNotify {
        return try Im.Group.ImgroupChangeMemberNotify.Builder().mergeFrom(data: data, extensionRegistry:Im.Group.ImgroupRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupChangeMemberNotify {
        return try Im.Group.ImgroupChangeMemberNotify.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Im.Group.ImgroupChangeMemberNotify {
        return try Im.Group.ImgroupChangeMemberNotify.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupChangeMemberNotify {
        return try Im.Group.ImgroupChangeMemberNotify.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Im.Group.ImgroupChangeMemberNotify {
        return try Im.Group.ImgroupChangeMemberNotify.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Im.Group.ImgroupChangeMemberNotify {
        return try Im.Group.ImgroupChangeMemberNotify.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "userId": return self.userId
        case "changeType": return self.changeType
        case "groupId": return self.groupId
        case "curUserIdList": return self.curUserIdList
        case "chgUserIdList": return self.chgUserIdList
        default: return nil
        }
    }
}
extension Im.Group.ImgroupChangeMemberNotify.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Im.Group.ImgroupChangeMemberNotify
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "userId": return self.userId
            case "changeType": return self.changeType
            case "groupId": return self.groupId
            case "curUserIdList": return self.curUserIdList
            case "chgUserIdList": return self.chgUserIdList
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "userId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.userId = newSubscriptValue
            case "changeType":
                guard let newSubscriptValue = newSubscriptValue as? Im.BaseDefine.GroupModifyType else {
                    return
                }
                self.changeType = newSubscriptValue
            case "groupId":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.groupId = newSubscriptValue
            case "curUserIdList":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.curUserIdList = newSubscriptValue
            case "chgUserIdList":
                guard let newSubscriptValue = newSubscriptValue as? Array<UInt32> else {
                    return
                }
                self.chgUserIdList = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
